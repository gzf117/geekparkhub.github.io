# 修性之道 Python Blog

@(2020-1-28)[ Docs Language:简体中文 & English|Programing Python|Website:[www.geekparkhub.com](https://www.geekparkhub.com/)|![OpenSource](https://img.shields.io/badge/Open%20Source-%E2%9D%A4-brightgreen.svg) | ![GitHub repo size in bytes](https://img.shields.io/github/repo-size/geekparkhub/geekparkhub.github.io.svg) | GeekDeveloper:[JEEP-711](https://github.com/jeep711)|Github:[github.com/geekparkhub](https://github.com/geekparkhub)|Gitee:[gitee.com/geekparkhub](https://gitee.com/geekparkhub) ]

## 🐍  Python Technology 修性之道 得之淡然 失之泰然 🐍

![Alt text](https://raw.githubusercontent.com/geekparkhub/geekparkhub.github.io/master/technical_guide/assets/media/python/opening/python_1.jpg)

- **极客实验室是极客国际公园旗下为未来而构建的极客社区;**
- **我们正在构建一个活跃的小众社区,汇聚众多优秀开发者与设计师;**
- **关注极具创新精神的前沿技术&分享交流&项目合作机会等互联网行业服务;**
- **Open开放 `·` Creation创想 `|` OpenSource开放成就梦想 GeekParkHub共建前所未见!**
- **Future Vision : Establishment of the Geek Foundation;**
- **GeekParkHub GithubHome:**<https://github.com/geekparkhub>
- **GeekParkHub GiteeHome:**<https://gitee.com/geekparkhub>
- **欢迎贡献`各领域开源野生Blog`&`笔记`&`文章`&`片段`&`分享`&`创想`&`OpenSource Project`&`Code`&`Code Review`**
- 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈 issues: [geekparkhub.github.io/issues](https://github.com/geekparkhub/geekparkhub.github.io/issues) 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈
- **`Official Public Email`**
- Group Email：<geekparkhub@outlook.com> —— <hackerparkhub@outlook.com> —— <hackerpark@hotmail.com>
- User Email：<jeep711.home.@gmail.com> —— <jeep-711@outlook.com>
- System Email：<systemhub-711@outlook.com>
- Service Email：<servicehub-711@outlook.com>


-------------------


[TOC]



## 🔥 0. 在学习Python之前你需要了解 🔥
> 在继续学习本路线之前,你应该了解一些基本计算机编程/操作系统命令行/环境变量/进制等等术语.
> 
> Python是一种广泛使用的高级解释型编程语言,并且支持多种编程范式, 包括面向对象、命令式、函数式和过程式编程.
> 
> 在Python技术界有个不成文的说法，那就是Life is short you need Python (人生苦短, 我用Python)
> 
> 此学习路线将基于Python3编程语言进行详细操作.
> 
> 如果你学习过```Java``` & ```Scala``` & ```GoLang``` & ```PHP``` & ```Ruby```等编程语言, 将有助于你更快了解掌握Python核心技术与思想.



## 💥 1. Python 简介 💥
> Python是一种广泛使用的解释型、高级编程、通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年, Python的设计哲学强调代码的可读性和简洁的语法，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库等.   —— [维基百科](https://zh.wikipedia.org/zh-hans/Python)



## 💥  2. Python 发展历史 💥
> Python 是由 Guido van Rossum 在八十年代末和九十年代初, 在荷兰国家数学和计算机科学研究所设计出来的.
> 
> Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等.
> 
>  像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License)协议.
>  
>  现在 Python 是由一个核心开发团队在维护, Guido van Rossum 仍然占据着至关重要的作用, 指导其进展.
>  
>  Python 2.7 被确定为最后一个 Python 2.x 版本, 它除了支持 Python 2.x 语法外，还支持部分Python 3.1 语法.



## 💥 3. Python 特点 💥
> 1.易于学习：Python有相对较少的关键字, 结构简单, 明确定义的语法, 学习起来更加简单.
> 
> 2.易于阅读：Python代码定义的更清晰.
> 
> 3.易于维护：Python的成功在于它的源代码是相当容易维护.
> 
> 4.一个广泛的标准库：Python的最大的优势之一是丰富的库, 跨平台的，在UNIX，Windows和Macintosh兼容很好.
> 
> 5.互动模式：互动模式的支持, 可以从终端输入执行代码并获得结果的语言, 互动的测试和调试代码片断.
> 
> 6.可移植：基于其开放源代码的特性, Python已经被移植（也就是使其工作）到许多平台.
> 
> 7.可扩展：如果你需要一段运行很快的关键代码, 或者是想要编写一些不愿开放的算法, 你可以使用C或C++完成那部分程序, 然后从你的Python程序中调用.
> 
> 8.数据库：Python提供所有主要的商业数据库的接口.
> 
> 9.GUI编程：Python支持GUI可以创建和移植到许多系统调用.
> 
> 10.可嵌入: 你可以将Python嵌入到C/C++程序, 让你的程序的用户获得"脚本化"的能力.



## 💥 4. Python 应用范围 💥
> 网络应用程序 / GUI开发 / 操作系统 / 科学计算 / 自动化运维 / 大数据 / 云计算 / 人工智能等等


## 💥 5. Python 环境搭建 💥
> 因为Python是跨平台, 它可以运行在Windows、Mac和各种Linux/Unix系统上, 在Windows上写Python程序,放到Linux上也是能够运行.
> 
> 目前Python有两个版本, 一个是2.x版, 一个是3.x版, 这两个版本是不兼容, 由于3.x版越来越普及, 本次将以最新Python 3.8.1版本为基础, 请确保你的电脑上安装的Python版本是最新的3.8.x版本


### 5.1 Python Download
> [Python 官网 : www.python.org](https://www.python.org/) | [Python 文档 : www.python.org/doc](https://www.python.org/doc/)


### 5.2 Python For Linux
> 在Python官网下载Python 3.8.1源码安装包,  [点击下载 Python 3.8.1 For Gzipped source tarball](https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz), 下载以```.tgz```安装包.
> 
> 1.解压安装包,并重命名
> ``` bash
> [root@systemhub511 ~]# cd /opt/software/
> [root@systemhub511 software]# tar -zxvf Python-3.8.1.tgz -C /opt/module/
> [root@systemhub511 software]# cd /opt/module/
> [root@systemhub511 module]# mv Python-3.8.1 python
> [root@systemhub511 module]# cd python/
> [root@systemhub511 python]# pwd
> /opt/module/python
> [root@systemhub511 python]# 
> ``` 
> 
> 2.设置环境变量 | ```sudo vim /etc/profile```
> ```
> [root@systemhub511 ~]# vim /etc/profile
> ```
> 3.定义环境变量,将配置信息写入至profile文件中
> ```
> ## SET_PYTHON_HOME
> export PYTHON_HOME=/opt/module/python
> export PATH=$PATH:$PYTHON_HOME/bin
> ``` 
> 4.写入完毕后, 按ESC键, 输入`:wq!`保存并退出.
> 
> 5.刷新配置文件 | ```source /etc/profile```
> ```
> [root@systemhub511 ~]# source /etc/profile
> ```
> 
> 6.运行Python
> 
> ``` python
> [root@systemhub511 ~]# python3
> Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)
> [Clang 6.0 (clang-600.0.57)] on darwin
> Type "help", "copyright", "credits" or "license" for more information.
> >>> print ("Hello, world!")
> Hello, world!
> >>> 
> ```

### 5.3 Python For Mac OS
> 如果你正在使用Mac, 系统是OS X>=10.9, 系统则自带的Python版本是2.7, 要安装最新的Python 3.8.1, 有两个方法：
> 
> 方法一：在Python官网下载Python 3.8.1安装程序,  [点击下载 Python 3.8.1 For macOS 64-bit installer](https://www.python.org/ftp/python/3.8.1/python-3.8.1-macosx10.9.pkg), 下载后双击运行并安装.
> 
> 方法二：如果安装了[Homebrew](https://brew.sh/)，直接通过命令```brew install python3```安装即可.
> 
> 按照上述方法完成安装, (可以通过命令行窗口进入python并开在交互式解释器中开始编写Python代码), 运行Python3
> ``` python
> systemhub:~ system$ python3
> Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)
> [Clang 6.0 (clang-600.0.57)] on darwin
> Type "help", "copyright", "credits" or "license" for more information.
> >>> print ("Hello, world!")
> Hello, world!
> >>> 
```

### 5.4 Python For Windows
> 首先根据你的Windows版本(64位或32位), 在Python官网下载Python 3.8.1安装64位程序,  [点击下载 Python 3.8.1 For Windows x86-64 executable installer](https://www.python.org/ftp/python/3.8.1/python-3.8.1-amd64.exe), 下载后, 特别要注意勾上`Add Python 3.8 to PATH`，然后点“Install Now”即可完成安装.
> 
> ![enter image description here](https://www.liaoxuefeng.com/files/attachments/1048401552601344/l)
> 
> 在Windows上运行Python时, 请先启动命令行, 然后运行python


### 5.4 Download Python IDE For PyCharm
> 集成开发环境 (IDE：Integrated Development Environment) : Python IDE For PyCharm
> 
> PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统.
> 
> PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制.
> 
> [PyCharm Download : www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)
> 
> ![enter image description here](https://www.jetbrains.com/pycharm/img/screenshots/complexLook@2x.jpg)



## 💥 6. Python 基本语法 注意事项 💥
> 1.在Python中严格区分字母大小写.
> 
> 2.Python中每一行就是一条语句, 每条语句以换行结束.
> 
> 3.Python中每一行语句不要过长 (规范中建议每行不要超过80个字符).
> 
> 4.一条语句可以分多行编写, 多行编写时语句后以```\```反斜杠结尾.
> 
> 5.Python是缩进严格的语言, 所以在Python中不要随便写缩进.
> 
> 6.在Python中使用`#`表示注释,`#`后的内容都属于注释, 注释的内容将会被解释器所忽略.
> 
> `Python 基础篇 - 基本语法`
> ``` py
> # -*- coding:utf-8 -*-
> #
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 基本语法 | Basic grammar
> # @File : 01_BasicGrammar.py
> # @Description : Python 基础篇 - 基本语法 | Python Basics-Basic Syntax
> 
> # 01 即表示注释 | Means comment
> 
> # 02 print 打印语句 Hello, World! | print statement Hello, World!
> print('Hello, World!')
> 
> # 03 当前`\`表示换行 | Current `\` means line break
> print('当前\
> 表示换行')
> ```


## 💥 7. Python 基础篇 💥
### 7.1 Python 常量 & 变量 & 标识符 & 命名规范
#### 7.1.1 `常量`
> 所谓常量就是不能变的变量, 比如常用的数学常数π就是一个常量.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 常量 & 变量 | Constants & variables
> # @File : 02_constant_variable.py
> # @Description : Python 基础篇 - 常量 & 变量 | Python Basics-Constants & Variables
> 
> # 定义常量 | Defining constants
> print(16)
> 
> # 常量演示 | Constant demo
> print('Name is Jack')
> ```
    

#### 7.1.2 `变量`
> 变量不仅可以是数字，还可以是任意数据类型, 变量在程序中就是用一个变量名表示, 变量名必须是`大小写英文`、`数字`和`_`下划线的组合, 且不能用数字开头.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 常量 & 变量 | Constants & variables
> # @File : 02_constant_variable.py
> # @Description : Python 基础篇 - 常量 & 变量 | Python Basics-Constants & Variables
> 
> # 定义变量 | Defining variables
> name = 'Jack'
> print(name)
> 
> # 变量演示 | Variables demo
> number = 16
> print(number * number)
> ```


#### 7.1.3 `标识符 & 命名规范`
> 在Python中所有可以自主命名的内容(变量名、函数名、类名)都属于标识符.
> `标识符规范` : 可以含有`字母`、`数字`、`_`、但是不能使用数字开头且不能使用Python中的`关键字`和`保留字`.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 标识符 & 命名规范 | Identifiers & naming conventions
> # @File : 03_Identifier_naming_convention.py
> # @Description : Python 基础篇 - 标识符 & 命名规范 | Python Basics-Identifiers & Naming Conventions
> 
> # 定义 标识符 | Definition identifier
> 
> # 定义变量 | Defining variables
> person_name = 'Jerry'
> person_sex = 'man'
> person_age = 20
> 
> 
> # 定义函数 | Defining functions
> def persons_info(name, sex, age):
>     print("PersonName: " + name, ", PersonSex: " + sex, ", PersonAge:", age)
>     return
> 
> 
> # 调用函数 | call function
> persons_info(person_name, person_sex, person_age)
> ```
> 
> `命名规范`：在Python中遵循两种命名规范 : `下划线命名法`/ `帕斯卡命名法`
> 
> `下划线命名法` : 所有字母小写, 单词之间以_下划线分割.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 标识符 & 命名规范 | Identifiers & naming conventions
> # @File : 03_Identifier_naming_convention.py
> # @Description : Python 基础篇 - 标识符 & 命名规范 | Python Basics-Identifiers & Naming Conventions
> 
> # 定义 命名规范 | Definition Naming Convention
> # 定义 下划线命名法 | Defining Underscore nomenclature
> def addition_calculation(num1, num2):
>     print("Result =", num1 + num2)
>     return
> 
> 
> # 调用函数 | call function
> addition_calculation(100, 100)
> ```
> `帕斯卡命名法` ：首字母大写, 每个单词开头字母大写, 其余字母小写.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 标识符 & 命名规范 | Identifiers & naming conventions
> # @File : 03_Identifier_naming_convention.py
> # @Description : Python 基础篇 - 标识符 & 命名规范 | Python Basics-Identifiers & Naming Conventions
> 
> # 定义 命名规范 | Definition Naming Convention
> # 定义 帕斯卡命名法 | Definition Pascal nomenclature
> def MultiplicationCalculation(num1, num2):
>     print("Result =", num1 * num2)
>     return
> 
> 
> # 调用函数 | call function
> MultiplicationCalculation(100, 100)
> ```


### 7.2 Python 数据类型
> 计算机顾名思义就是可以做数学计算的机器, 因此计算机程序理所当然地可以处理各种数值。但是计算机能处理的远不止数值, 还可以处理文本、图形、音频、视频、网页等各种各样的数据, 不同的数据需要定义不同的数据类型。
> 
> 在Python中能够直接处理的数据类型有以下几种 : 
#### 7.2.1 `整数`
> Python可以处理任意大小的整数, 当然包括负整数, 在程序中的表示方法和数学上的写法一模一样.
> 
> 计算机由于使用二进制, 所以有时候用十六进制表示整数比较方便, 十六进制用`0x`前缀和0-9，a-f表示, 例如: `0xff00`, `0xa5b4c3d2`等等.
> 
> ```
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 整数 | Definition integer
> object_widths = 18
> # 如果数字的长度过大, 可以使用下划线作为分隔符 | If the number is too long, you can use an underscore as a separator
> object_lengths = 18_15_16
> print(object_widths * object_lengths)
> ```

#### 7.2.2 `浮点数`
> 浮点数也就是小, 之所以称为浮点数, 是因为按照科学记数法表示时, 一个浮点数的小数点位置是可变的.
> 
> 整数和浮点数在计算机内部存储的方式是不同的, 整数运算永远是精确的, 而浮点数运算则可能会有四舍五入的误差.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 浮点数 | Definition Floating point
> assets = 5242414.455
> incomes = 500.36
> print(assets + incomes)
> ``` 


#### 7.2.3 `字符串` & `格式化`
> 字符串是以单引号`'`, 双引号`"`, 三重引号`'''`括起来的任意文本.
> 
> 在Python中采用的格式化方式和C语言是一致的, 用`%`占位符实现, 常见的占位符有：
> 
> `%d`表示用整数替换占位符 / `%f`表示用浮点数替换占位符
> 
> `%s`表示用字符串替换占位符 / `%x`表示用十六进制整数替换占位符
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 字符串 | Definition String
> # 定义 (单引号)修饰字符串 | Define (single quote) decorated strings
> saying = 'Le vent se lève, il faut tenter de vivre!\n'
> 
> # 定义 (双引号)修饰字符串 | Define (double quotes) decorated strings
> quotes = "A man who is artistic for art often gets the most pleasure from the least important and mundane image!\n"
> 
> # 定义 (单引号嵌套双引号)修饰字符串 | Define (single-quoted nested double-quoted) decorated strings
> talks = 'Arthur · Conan · Doyle: "Hard work creates talent!"\n'
> 
> # 定义 (三重引号)修饰长字符串 | Definition (triple quotes) to decorate long strings
> fragment = '''We must go deep into life, 
> Only then can you get novel effects and extraordinary cooperation, 
> And this in itself is more irritating than any imagination!'''
> 
> print(saying, quotes, talks, fragment)
> print("------------------------------------------------------\n")
> 
> # 定义 格式化 字符串 | Definition Format string
> # 使用加号拼接字符串 | Use plus sign to concatenate strings
> words = 'py' + 'thon'
> nums = 666
> print('words = ' + words)  # Output result: words = python
> # 多个参数 | Multiple parameters
> print('result = ', words, nums)  # Output result: result = 456
> print("------------------------------------------------------\n")
> 
> # 在字符串中指定占位符 | Specifying placeholders in strings
> word1 = 'odd_number= 135%s' % '7911'  # Output result: odd_number= 1357911
> word2 = 'even_number= 24%s810%s' % ('6', '12')  # Output result: even_number= 24681012
> word3 = 'assets= %.2f' % 555.456  # Output result: assets= 555.46
> word4 = 'assets=  %d' % 555.95  # Output result: assets=  555
> 
> # 通过`f`来创建格式化字符串 | Create a formatted string with `f`
> result = f'result= {word1} {word2}'  # Output result: result= odd_number= 1357911 even_number= 24681012
> print(word1, word2, word3, word4, result)
> print("------------------------------------------------------\n")
> 
> # 格式化 字符串综合练习 | Format string synthesis exercise
> word = 'py' + 'thon'
> print('人生苦短 ' + '快选 ' + word)
> print('人生苦短', '快选', word)
> print('人生苦短 快选 %s' % word)
> print(f'人生苦短 快选 {word}')
> print("------------------------------------------------------\n")
> 
> # 字符串 复制 (将字符串和数字相乘) | String copy (multiply strings and numbers)
> info = 'Learning!\t'
> info = info * 20
> print(info)
> print("------------------------------------------------------\n")
> ``` 


#### 7.2.4 `转义字符`
> 转义字符`\`可以转义很多字符, 比如`\n`表示换行, `\t`表示制表符, 字符`\`本身也要转义, 所以`\\`表示的字符就是`\`.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 转义字符 | Definition escape character
> talk = 'Arthur · Conan · Doyle:\t "Hard work creates talent!\\"\n'
> print(talk)
> print("------------------------------------------------------\n")
> ``` 

#### 7.2.5 `布尔值`
> 布尔值和布尔代数的表示完全一致, 一个布尔值只有`True`、`False`两种值, 要么是True, 要么是False.
> 
> 在Python中可以直接用`True`、`False`表示布尔值 (请注意大小写).
> 
> 布尔值可以用`and`、`or`和`not`运算,
> `and`运算是与运算, 只有所有条件都为`True`, `and`运算结果才是`True`.
> `or`运算是或运算, 只要其中有一个条件为`True`, `or`运算结果就是`True`.
> `not`运算是非运算, 它是一个单目运算符, 把`True`变成`False`, `False`变成`True`.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 布尔值 | Definition Boolean value
> print('True=', True)  # Output result: True
> print('False=', False)  # Output result: False
> print('3 > 2=', 3 > 2)  # Output result: True
> print('3 < 2=', 3 < 2)  # Output result: False
> 
> print('True and True=', True and True)  # Output result: True
> print('True and False=', True and False)  # Output result: False
> print('3 < 2 and 3 < 2=', 3 < 2 and 3 < 2)  # Output result: False
> 
> print('True or True=', True or True)  # Output result: True
> print('True or False=', True or False)  # Output result: True
> print('3 < 2 or 3 < 2=', 3 < 2 or 3 < 2)  # Output result: False
> 
> print('not True', not True)  # Output result: False
> print('not False', not False)  # Output result: True
> print('not 3 > 2', not 3 > 2)  # Output result: False
> 
> if 20 >= 18:
>     print('大于等于')
> else:
>     print('小于等于')
> 
> print("------------------------------------------------------\n")
> ``` 

#### 7.2.6 `空值`
> 空值是Python里一个特殊的值, 用`None`表示, `None`不能理解为`0`, 因为`0`是有意义的, 而`None`是一个特殊的空值.
> 
> 此外Python还提供了列表、字典等多种数据类型, 还允许创建自定义数据类型, 后面会继续讲到.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 空值 | Definition Null value
> data = None
> print(data)
> print("------------------------------------------------------\n")
> ``` 

#### 7.2.7 `类型检查`
> 通过`type()`类型检查, 可以检查只能变量值类型, 该函数会将检查的结果作为返回值返回, 也可以通过变量来接收函数的返回值.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 类型检查 | Type check
> values1 = 123456  # Output result: <class 'int'>
> values2 = '123456'  # Output result: <class 'str'>
> values3 = None  # Output result: <class 'NoneType'>
> values4 = True  # Output result: <class 'bool'>
> values5 = 555.456  # Output result: <class 'float'>
> print(type(values1), type(values2), type(values3), type(values4), type(values5))
> ``` 




### 7.3 Python 对象
> Python是一门面向对象的编程语言, 所以一切皆对象!
> 
> 程序运行当中所有数据都是存储到内存当中然后再运行.
> 
> 对象就是内存中专门用来存储指定数据的一块区域.

#### 7.3.1 对象的结构
> 每个对象中都要保存三种数据`id` / `type` / `value`
> 
> `id (标识)`:  id用来标识对象的唯一性, 每一个对象都有唯一的id, 对象一旦创建则它的id永远不能再改变.
> 
> `type (类型)`: 类型用来标识当前对象所属的类型, 类型决定了对象有哪些功能, 通过type()函数来查看对象的类型.
> 
> ` value (值)`: 值就是对象中存储的具体的数据, 对象分成两大类: `可变对象` /  `不可变对象`.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 对象结构 | Object structure
> # @File : 05_object_structure.py
> # @Description : Python 基础篇 -  对象结构 | Python Basics-Object Structure
> 
> # 对象结构 | Object structure
> object_structure = '13579'
> print('id=', id(object_structure))
> print('type=', type(object_structure))
> print('value=', object_structure)
> ```

### 7.4 Python 变量和对象
> 对象并没有直接存储到变量中, 在Python中变量更像是给对象起了一个别名.
> 
> 变量中存储的不是对象的值, 而是对象的id(内存地址).
> 
> 当使用变量时, 实际上就是在通过对象id在查找对象.
> 
> 变量中保存的对象, 只有在为变量重新赋值时才会改变.
> 
> 变量和变量之间是相互独立的，修改一个变量不会影响另一个变量.


### 7.5 Python 类型转换
> 所谓的类型转换, 将一个类型的对象转换为其他对象.
> 
> 类型转换不是改变对象本身的类型, 而是根据当前对象的值创建一个新对象.
> 
> 类型转换分为四个函数:  `int()`/ `float()` / `str()` / `bool()`
> 
> `int()`可以用来将其他的对象转换为整型.
> 
> `float()`和`int()`基本一致, 不同的是它会将对象转换为浮点数.
> 
> `str()`可以将对象转换为字符串.
> 
> `bool()`可以将对象转换为布尔值, 任何对象都可以转换为布尔值.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 类型转换 | Type conversion
> # @File : 06_type_conversion.py
> # @Description : Python 基础篇 - 类型转换 | Python Basics-Type Conversion
> 
> # 类型转换 | Type conversion
> data = '13579'
> data = int(data)
> data = float(data)
> data = str(data)
> data = bool(data)
> 
> print('id=', id(data))
> print('type=', type(data))
> print('value=', data)
> ```

### 7.6 Python 运算符(操作符)
> 运算符可以对一个值或多个值进行运算或各种操作.
> 
> 运算符的分类: ```算术运算符``` / ```赋值运算符``` / ```关系运算符``` / ```逻辑运算符``` / ```条件运算符```.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 运算符 | Operator
> # @File : 07_operator.py
> # @Description : Python 基础篇 - 运算符 | Python Fundamentals-Operators
> 
> # 运算符 | Operator
> 
> # 算术运算符 | Arithmetic operator
> # (`+` 加法运算符) | (`-` 减法运算符) | (`*` 乘法运算符) | (`**` 幂运算) | (`/` 除法运算符) | (`//` 整除运算符) | (`%` 取余运算符)
> nums = ((12 + 12 - 10) * 12) // 2
> print('result=', nums)
> 
> # 赋值运算符 | Assignment operator
> # (`=` 将等号右侧值赋给等号左侧变量) | (`+=` 等价于 `x = x + 1`) | (`-=` 等价于 `x = x - 1`) | (`*=` 等价于 `x = x * 1`)
> # (`**=` 等价于 `x = x ** 1`) | (`/=` 等价于 `x = x / 1`) | (`//=` 等价于 `x = x // 1`) | (`%=` 等价于 `x = x % 1`)
> nums1 = 1
> nums1 += 100
> nums1 -= 1
> nums1 *= 1
> nums1 **= 2
> nums1 /= 10
> nums1 //= 16
> nums1 %= 12
> print('result=', nums1)
> 
> # 关系运算符 | Relational operator
> # (`>` 大于运算符) | (`>=` 大于等于运算符) | (`<` 小于运算符) | (`<=` 小于运算符)
> # (`==` 等于运算符) | (`!=` 不等于运算符) | (`is` 比较两个对象是否是同一对象) | (`is not` 比较两个对象是否不是同一对象)
> nums2 = 10 > 20
> nums2 = 10 >= 20
> nums2 = 10 < 20
> nums2 = 10 <= 20
> nums2 = '10' == '20'
> nums2 = '10' != '20'
> print('result=', nums2)
> 
> # 逻辑运算符 | Logical Operators
> # (`not` 逻辑非) | (`and` 逻辑与) | (`or` 逻辑或) |
> nums3 = True
> # not可以对符号右侧的值进行非运算, 对于布尔值非运算会对其进行取反操作, True变False, False变True, 对于非布尔值非运算会先将其转换为布尔值然后再取反
> nums3 = not nums3
> # and可以对符号两侧的值进行与运算, 只有在符号两侧的值都为True时才会返回True, 只要有一个False就返回False
> nums3 = True and True
> nums3 = True and False
> # or可以对符号两侧的值进行或运算, 或运算两个值中只要有一个True就会返回True
> nums3 = True or True
> nums3 = True or False
> print(nums3)
> 
> # 非布尔值的与或运算
> # 与运算, 如果第一个值是False则直接返回第一个值, 否则返回第二个值
> nums4 = 1 and 2
> nums4 = 1 and 0
> nums4 = 0 and 1
> nums4 = 0 and None
> print(nums4)
> 
> # 或运算, 如果第一个值是True则直接返回第一个值, 否则返回第二个值
> nums5 = 1 or 2
> nums5 = 1 or 0
> nums5 = 0 or 1
> nums5 = 0 or None
> print(nums5)
> 
> # 条件运算符 | Conditional operator
> # 语法: 语句一 if 条件表达式 else 语句二
> # 执行流程:  条件运算符在执行时会先对条件表达式进行求值判断, 如果判断结果为True则执行语句一并返回执行结果, 如果判断结果为False则执行语句二并返回执行结果
> if 20 > 18:
>     print('大于等于')
> else:
>     print('小于等于')
> 
> nums6 = 50
> nums7 = 60
> nums8 = 10
> mins = nums6 if (nums6 < nums7 and nums6 < nums8) else (nums7 if nums7 < nums8 else nums8)
> print('min=', mins)
> ```


#### 7.6.1 Python 运算符优先级
> 从最高到最低优先级的所有运算符
| 运算符      |     描述 |
| :--------: | :--------:|
| `**`    |   指数(最高优先级) |
| `~ + -`    |   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |
| `* / % //`    |   乘，除，取模和取整除 |
| `+ -`    |   加法减法 |
| `>> <<`    |   右移，左移运算符 |
| `&`    |   位 'AND' |
| `^`    |   位运算符 |
| `<= < > >=`    |   比较运算符 |
| `<> == !=`    |   等于运算符 |
| `= %= /= //= -= += *= **=`    |   赋值运算符 |
| `is is not`    |   	身份运算符 |
| `in not in`    |   成员运算符 |
| `not and or`    |   逻辑运算符 |



### 7.7 Python 流程控制语句
> Python代码在执行时是按照自上向下顺序执行.
> 
> 通过流程控制语句, 可以改变程序的执行顺序, 也可以让指定的程序反复执行多次.
> 
> 流程控制语句分成两大类：`条件判断语句` / `循环语句`


#### 7.7.1 条件判断语句
> ``` python 
> 语法：if 条件表达式 : 
>             代码块
> ```
> 
> 执行的流程: if语句在执行时会先对条件表达式进行求值判断.
> 
>  如果为True则执行if后的语句, 如果为False则不执行.
>  
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 流程控制 | Process control
> # @File : 08_process_control.py
> # @Description : Python 基础篇 - 流程控制 | Python Basics - Process control
> 
> # 流程控制 | Process control
> 
> # 定义 条件判断语句 | Definition Conditional Judgment
> if True:
>     print("Output_1")
>     print("Output_2")
>     print("Output_3")
> 
> 
> # 定义 身份验证函数 | Define authentication function
> def verification(user_name_input, user_password_input, user_token_input):
>     # print('\nPlease enter UserName....')
>     if user_name_input == 'system' or user_name_input == 'System':
>         print('‖-------------------------------------------------‖')
>         print('\n‖ Username Verification Successful !', user_name_input, '..... ‖\n')
>         print('‖-------------------------------------------------‖\n')
>         # print('\nPlease enter Password....\n')
>         if user_password_input == 'xxx':
>             print('‖-------------------------------------------------‖')
>             print('\n‖ Password Verification Successful', user_name_input, '..... ‖\n')
>             print('‖-------------------------------------------------‖')
>             # print('\nPlease enter Token....\n')
>             if user_token_input == '000000':
>                 print('‖-------------------------------------------------‖')
>                 print('\n‖ Token Verification Successful, Welcome', user_name_input, '! ‖\n')
>                 print('‖-------------------------------------------------‖')
>             else:
>                 print('\n', user_token_input, 'Token Error!')
>         else:
>             print('\n', user_password_input, 'Password Error!')
>     else:
>         print('\n', user_name_input, 'UserName Error!')
> 
> 
> # 定义 参数 | Definition parameter
> name = input('\nPlease enter UserName....\n')
> password = input('\nPlease enter Password....\n')
> token = input('\nPlease enter Token....\n')
> 
> # 调用 身份验证函数 | Transfer authentication function
> verification(name, password, token)
> ```

#### 7.7.2 循环语句
> 循环语句可以使指定的代码块重复指定的次数.
> 
> 循环类型分为三种: `while循环` /  `for循环` / `循环嵌套`.
> 
> 在Python 中没有`do..while`循环.

##### 7.7.2.1 while循环
> while循环 语法：
> 
> ``` python
> while 判断条件(condition)：
>     执行语句(statements)……
> ```
##### 7.7.2.2 for循环
> for循环 语法：
> 
> ``` python
> for iterating_var in sequence:
>    statements(s)
> ```

##### 7.7.2.3 循环嵌套
> Python while 循环嵌套语法：
> ``` python
> while expression:
>   while expression:
>      statement(s)
>   statement(s)
> ```
> 
> Python for 循环嵌套语法
> ``` python
> for iterating_var in sequence:
>    for iterating_var in sequence:
>       statements(s)
>    statements(s)
> ```

##### 7.7.2.4 循环控制语句
> 循环控制语句可以更改语句执行的顺序, Python支持以下循环控制语句:
| 控制语句      |     描述 |
| :-------- | --------:|
| `break 语句`    |   在语句块执行过程中终止循环, 并且跳出整个循环. |
| `continue 语句`    |   在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环. |
| `pass 语句`    |   pass是空语句，是为了保持程序结构的完整性. |

> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 流程控制 | Process control
> # @File : 08_process_control.py
> # @Description : Python 基础篇 - 流程控制 | Python Basics - Process control
> 
> # 流程控制 | Process control
> 
> # 定义 循环语句 | Definition loop statement
> # while循环 | while loop
> x = 0
> while x < 10:
>     print(x, 'Life is short, choose python quickly！')
>     x += 1
> else:
>     print('End\n')
> 
> # for循环 | for loop
> fruits = ['banana', 'apple', 'mango']
> for fruit in fruits:  # 第二个实例
>     print('当前水果 :', fruit)
> print('Good bye!\n')
> 
> # 循环嵌套 | Loop nesting
> i = 0
> while i < 9:
>     i += 1
>     j = 0
>     while j < i:
>         j += 1
>         print(f"{j} * {i} = {i * j}\t", end=' ')
>     print()
> ```


### 7.8 Python 数据结构 集合
> 序列是Python中最基本的数据结构, 序列中的每个元素都分配一个数字 - 它的位置或索引, 第一个索引是0, 第二个索引是1,依此类推, 列表的索引也可以是负数,如果索引是负数, 则从后向前获取元素, -1表示倒数第一个, -2表示倒数第二个以此类推.
> 
> Python有6个序列的内置类型, 但最常见的是列表和元组.
> 
> 序列都可以进行的操作包括索引, 切片, 加, 乘, 检查成员.

#### 7.8.1 列表 (list)
> 列表是最常用的Python数据类型, 它可以作为一个方括号内的逗号分隔值出现.
> 
> 列表中可以保存多个有序的数据, 列表是用来存储对象的对象.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 列表 | Definition list
> list1 = [1, 2, 3, 4, 5]
> 
> # 获取列表元素长度 | Get list element length
> print('lens=', len(list1))
> 
> # 访问列表中的值 | Access value in list
> print(list1[1])
> 
> # 更新列表 | update list
> list1.append(6)
> 
> # 向列表指定位置插入元素 | Insert an element at a specified position in the list
> list1.insert(3, 7)
> 
> # 使用新的序列扩展当前序列 | Extend current sequence with new sequence
> list1.extend([8, 9])
> 
> # 定义 迭代列表元素 | Definition iteration
> for data in list1:
>     print('data=', data)
> 
> # 删除列表元素 | Remove list element
> del list1[2]
> 
> # 根据索引删除指定元素并返回被删除元素的值 | Deletes the specified element based on the index and returns the value of the deleted element
> delete_value = list1.pop(3)
> print('delete_value=', delete_value)
> 
> # 根据指定元素删除元素值 | Delete element value based on specified element
> list1.remove(5)
> 
> # 将列表元素反转 | Reverse list element
> list1.reverse()
> 
> # 对列表元素进行排序,默认为升序排序 | Sort list elements, default is ascending
> list1.sort()
> list1.sort(reverse=True)
> 
> # 清空列表 | clear the list
> list1.clear()
> 
> print('list1=', list1)
> ```

##### 7.8.1.1 `列表 切片`
> 切片指从现有列表中获取一个子列表.
> 
>  切片语法1：`list[起始:结束]`
>  通过切片获取元素时会包括起始位置的元素, 不会包括结束位置的元素.
>  
>  切片语法2: `list[起始:结束:步长]`
>  步长表示每次获取元素的间隔，默认值是1, 步长不能是0但是可以是负数.
>  
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 列表 | Definition list
> list1 = [1, 2, 3, 4, 5]
> # 定义 列表切片 | Definition list slice
> # 如果省略结束位置则会一直截取到最后 | If the end position is omitted, it will be intercepted to the end.
> print('list1[1:]: ', list1[1:])
> # 如果省略起始位置则会从第一个元素开始截取 | If the starting position is omitted, it will be truncated from the first element
> print('list1[:3]: ', list1[:3])
> # 如果起始位置和结束位置全部省略则相当于创建一个列表的副本
> print('list1[:]: ', list1[:])
> # 通过切片获取元素时会包括起始位置的元素,不会包括结束位置的元素
> print('list1[1:5]: ', list1[1:5])
> # 定义 步长 | Definition Stride
> print('list1[1:4:1]: ', list1[1:4:1])
> print('list1[::1]: ', list1[::-1])
> ```

##### 7.8.1.2 `列表 脚本操作符`
> 列表对 `+` 和 `*` 的操作符与字符串相似, `+` 号用于组合列表, `*` 号用于重复列表.
| Python 表达式      |     	结果 |   描述   |
| :--------: | :--------:| :------: |
| `len([1, 2, 3])`    |   3 |  长度  |
| `[1, 2, 3] + [4, 5, 6]`    |   [1, 2, 3, 4, 5, 6] |  组合  |
| `['Hi!'] * 4`    |   ['Hi!', 'Hi!', 'Hi!', 'Hi!'] |  重复  |
| `3 in [1, 2, 3]` and `3 not in [1, 2, 3]`    |   True / False |  元素是否存在于列表中  |
| `for x in [1, 2, 3]: print x,`    |   1 2 3 |  迭代  |
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 列表 | Definition list
> list2 = [1, 2, 3, 4, 5, 6]
> list3 = ['C', 'C++', 'C#', 'Html', 'Java', 'PHP', 'Python', 'Scala', 'GoLang', 'R', 'Ruby', 'SQL']
> 
> # 定义 元素是否存在于列表中 | Defines whether the element exists in the list
> print('Python' in list3)
> print('Python' not in list3)
> 
> # 定义 迭代 | Definition iteration
> for data in list3:
>     print('data=', data)
> 
> # 定义 组合列表 | Definition Combination list
> list2 = [1, 2, 3, 4, 5, 6] + [7, 8, 9, 10, 11]
> 
> # 定义 重复列表 | Definition repeat list
> list3 = list3 * 4
> 
> # 获取列表长度 | Get list length
> print('list2 length=', len(list2))
> print('list3 length=', len(list3))
> ```


##### 7.8.1.3 `列表 内置函数 & 方法`
> 方法和函数基本上是一样, 只不过方法必须通过`object.方法()`的形式调用.
> 
> Python包含以下函数:
| 序号      |     函数 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `cmp(list1, list2)` |  比较两个列表的元素  |
| 2    |   `len(list)` |  列表元素个数  |
| 3    |   `max(list)` |  返回列表元素最大值  |
| 4    |   `min(list)` |  返回列表元素最小值  |
| 5    |   `list(seq)` |  将元组转换为列表  |

> Python包含以下方法:
| 序号      |     方法 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `lists.append(obj)` |  在列表末尾添加新的对象  |
| 2    |   `lists.count(obj)` |  统计某个元素在列表中出现的次数  |
| 3    |   `lists.extend(seq)` |  在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）  |
| 4    |   `lists.index(obj)` |  从列表中找出某个值第一个匹配项的索引位置  |
| 5    |   `lists.insert(index, obj)` |  将对象插入列表  |
| 6    |   `lists.pop([index=-1])` |  移除列表中的一个元素（默认最后一个元素），并且返回该元素的值  |
| 7    |   `lists.remove(obj)` |  移除列表中某个值的第一个匹配项  |
| 8    |   `lists.reverse()` |  反向列表中元素  |
| 9    |   `lists.sort(cmp=None, key=None, reverse=False)` |  对原列表进行排序  |


#### 7.8.2 序列 (seq)
> 序列是Python中最基本的一种数据结构, 数据结构指计算机中数据存储的方式.
> 
> 序列用于保存一组有序的数据, 所有的数据在序列当中都有一个唯一的位置(索引).并且序列中的数据会按照添加的顺序来分配索引.
> 
> 序列的分类 : 
> 
> `可变序列`[序列中的元素可以改变] : `列表(list)`
> 
> `不可变序列`[序列中的元素不能改变]: `字符串(str)` `元组(tuple)`


#### 7.8.3 range
>  range()是一个函数, 可以用来生成一个自然数的序列.
>  
>  range语法: 该函数需要三个参数  1.`起始位置(可以省略,默认是0)` | 2.`结束位置` | 3.`步长(可以省略,默认是1)`
>  
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义ragne() 生成自然数的序列函数 | Definition ragne() Sequence > function to generate natural numbers
> r1 = range(5)
> r2 = range(0, 10, 2)
> 
> print('r1=', r1, list(r1))
> print('r2=', r2, list(r2))
> 
> for x in range(60):
>     print('r3 =', x)
> ```

#### 7.8.4 元祖 (tuple)
> Python的元组与列表类似, 不同之处在于元组的元素不能修改, 即含义为元组是一个不可变的序列.
> 
> 元组使用`()`小括号, 列表使用`[]`方括号.
> 
> 元组创建很简单, 只需要在括号中添加元素, 并使用逗号隔开即可.
> 
> ```元组运算符```: 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组.
| Python 表达式      |     	结果 |   描述   |
| :--------: | :--------:| :------: |
| `len([1, 2, 3])`    |   3 |  长度  |
| `[1, 2, 3] + [4, 5, 6]`    |   [1, 2, 3, 4, 5, 6] |  组合  |
| `['Hi!'] * 4`    |   ['Hi!', 'Hi!', 'Hi!', 'Hi!'] |  重复  |
| `3 in [1, 2, 3]` and `3 not in [1, 2, 3]`    |   True / False |  元素是否存在于列表中  |
| `for x in [1, 2, 3]: print x,`    |   1 2 3 |  迭代  |

> ```元组索引截取```: 因为元组也是一个序列, 所以可以访问元组中的指定位置的元素, 也可以截取索引中的一段元素.
| Python 表达式      |     结果 |   描述   |
| :--------: | :--------:| :------: |
| `L[2]`    |   	'SPAM!' |  读取第三个元素  |
| `L[-2]`    |   	'Spam' |  反向读取，读取倒数第二个元素  |
| `L[1:]`    |   ('Spam', 'SPAM!') |  截取元素  |

> ```元组内置函数```: 
| 序号      |     函数 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `cmp(list1, list2)` |  比较两个列表的元素  |
| 2    |   `len(list)` |  列表元素个数  |
| 3    |   `max(list)` |  返回列表元素最大值  |
| 4    |   `min(list)` |  返回列表元素最小值  |
| 5    |   `tuple(seq)` |  将列表转换为元组  |

> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 元祖 | Definition Tuple
> # 创建元祖 | Create Tuple
> tuples1 = (1, 2, 3, 4, 5, 6, 7, 8)
> # 创建 无关闭分隔符 元祖 | Created without closing separator
> tuples2 = 1, 2, 3, 4, 5, 6, 7, 8
> 
> # 定义 元祖解包 将元祖中每一个元素赋值给每一个变量
> a, b, c, d, e, f, g, h = tuples2
> a, b, *c = tuples1
> print('a=', a)
> print('b=', b)
> print('c=', c)
> print('d=', d)
> print('e=', e)
> print('f=', f)
> print('g=', g)
> print('h=', h)
> 
> # 修改元组 | Modify tuple
> tuples3 = 9, 10, 11
> tuples4 = tuples2 + tuples3
> print('tuples4=', tuples4)
> 
> # 删除元组 | Delete tuple
> del tuples4
> 
> # 访问元组 | Access tuple
> print('tuples1[0]=', tuples1[0])
> print('tuples2[0:5]=', tuples2[0:5])
> print('tuples2=', tuples2)
> ```


#### 7.8.5 字典 (dict)
> 字典属于一种新的数据结构称为映射mapping, 字典是另一种可变容器模型且可存储任意类型对象.
> 
> 字典的每个键值`key=>value`对用冒号`:`分割, 每个键值对之间用逗号`,`分割, 整个字典包括在花括号`{}`中.

##### 7.8.5.1 `字典 内置函数 & 方法`
> Python中字典包含了以下内置函数: 
| 序号      |     函数名 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `cmp(dict1, dict2)` |  比较两个字典元素  |
| 2    |   `len(dict)` |  计算字典元素个数，即键的总数  |
| 3    |   `str(dict)` |  输出字典可打印的字符串表示  |
| 4    |   `type(variable)` |  返回输入的变量类型，如果变量是字典就返回字典类型  |

> Python中字典包含了以下内置方法: 
| 序号      |     方法名 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `dict.clear()` |  删除字典内所有元素  |
| 2    |   `dict.copy()` |  返回一个字典的浅复制  |
| 3    |   `dict.fromkeys(seq[, val])` |  创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值  |
| 4    |   `dict.get(key, default=None)` |  返回指定键的值，如果值不在字典中返回default值  |
| 5    |   `dict.has_key(key)` |  如果键在字典dict里返回true，否则返回false  |
| 6    |   `dict.items()` |  以列表返回可遍历的(键, 值) 元组数组  |
| 7    |   `dict.keys()` |  以列表返回一个字典所有的键  |
| 8    |   `dict.setdefault(key, default=None)` |  和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default  |
| 9    |   `dict.update(dict2)` |  把字典dict2的键/值对更新到dict里  |
| 10    |   `dict.values()` |  以列表返回字典中的所有值  |
| 11    |   `pop(key[,default])` |  删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值  |
| 12    |   popitem() |  返回并删除字典中的最后一对键和值  |

> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 字典 | Definition dictionary
> # 创建 字典 | Create dictionary
> d1 = {'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E', 'f': 'F', 'g': 'G', 'h': 'H'}
> d2 = dict([('a', 'A'), ('b', 'B'), ('c', 'C'), ('d', 'D'), ('e', 'E'), ('f', 'F'), ('g', 'G'), ('h', 'H')])
> d3 = {'j': 'J', 'k': 'K', 'l': 'L'}
> # 获取字典中键值对个数 | Get the number of key-value pairs in the dictionary
> print('d1_len=', len(d1))
> 
> # 访问字典中的值 | Accessing values ​​in a dictionary
> print("d1['b']=", d1['b'])
> 
> # 通过方法访问字典中的值 | Accessing values ​​in a dictionary via methods
> print("d1.get('b')=", d1.get('b'))
> print("d1.get('j')=", d1.get('j', 'defaults'))
> 
> # 修改字典 | Modify dictionary
> d1['h'] = 'h'
> d1.setdefault('g', 'G')
> d1.setdefault('i', 'I')
> d1.update(d3)
> print('d1=', d1)
> 
> # 删除字典元素 | Delete dictionary element
> del d1['a']
> d1.popitem()
> d1.pop('f')
> print("d1.pop('z')", d1.pop('z', 'defaults'))
> print('d1=', d1)
> d2.clear()
> print('d2=', d2)
> 
> # 字典浅复制 | Dictionary shallow copy
> d4 = {'m': 'M', 'n': 'N', 'o': 'O', 'p': 'P', 'q': 'Q'}
> # 复制后的对象和原对象是完全独立的, 两个对象之间的变化不会影响
> d5 = d4.copy()
> print('d4=', d4, 'd4_id=', id(d4))
> print('d5=', d5, 'd5_id=', id(d5))
> 
> # 遍历 字典 | Traversal dictionary
> # 调用keys()方法, 该方法将返回一个序列, 该序列中保存字典中所有的键
> for k1 in d4.keys():
>     print('key=', k1, 'value=', d4[k1])
> 
> # 调用values()方法, 该方法将返回一个序列, 该序列中保存字典中所有的值
> for v1 in d4.values():
>     print('v1=', v1)
> 
> # 调用items()方法, 该方法会返回一个(字典中所有项)的序列, 序列中包含双值子序列
> for k2, v2 in d4.items():
>     print('res=', k2, '=>', v2)
> ```

#### 7.8.6 集合 (set)
> 集合和列表非常相似, 集合不同点在于: 
> 
> `1.集合中只能存储不可变对象` / `2.集合中存储的对象是无序(不是按照元素的插入顺序保存)` / `3.集合中不能出现重复的元素`
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 集合 | Definition collection
> # 创建 集合 | Create collection
> s1 = set()  # 定义 空set集合 | Definition empty set collection
> s2 = {'a', 'c', 'd', 'r', 'g', 'p'}
> s3 = set([1, 2, 5, 6, 8])  # 调用set()方法将列表转换为集合
> s4 = set([(1, 2, 3, 4), (6, 8, 7, 10)])  # 调用set()方法将元祖转换为集合
> s5 = set({'a': 'A', 'b': 'B', 'c': 'C'})  # 调用set()方法将字典转换为集合, 但包含字典中的键
> s6 = set('Python')  # 调用set()方法将字符串转换为集合
> 
> print('s1=', s1, '\t s2=', s2)
> print('s3=', s3, '\t s4=', s4)
> print('s5=', s5, '\t s6=', s6)
> 
> # 获取集合元素个数 | Get the number of collection elements
> print('len(s5)=', len(s5))
> 
> # 检查集合中的指定元素 | Check specified element in collection
> print('d' in s5)
> 
> # 向集合中添加元素 | Add elements to the collection
> s2.add('k')
> s2.update(s4)
> s2.update(s5)
> s2.update(s6)
> print('s2=', s2)
> 
> # 删除集合 | Remove collections and elements
> # 随机删除集合元素 | Remove collection elements randomly
> s5.pop()
> print('s5=', s5)
> 
> # 指定删除集合元素 | Specifies to delete collection elements
> # s5.remove('a')
> print('s5=', s5)
> 
> # 清空集合所有元素 | Clear all elements of the collection
> s6.clear()
> print('s6=', s6)
> 
> # 集合 浅复制 | Collection shallow copy
> s7 = set([1, 2, 5, 6, 8])
> # 复制后的对象和原对象是完全独立的, 两个对象之间的变化不会影响
> s8 = s7.copy()
> print('s7=', s7, 's7_id=', id(s7))
> print('s8=', s8, 's8_id=', id(s8))
> 
> # 集合 运算 | Set operation
> s9 = {1, 2, 3, 4, 5}
> s10 = {1, 2, 3, 4, 5, 6, 7}
> 
> # `&` 交集运算 | `&` Intersection operation
> res1 = s9 & s10
> print('Intersection_Operation=', res1)  # Output result: Intersection_Operation= {3, 4, 5}
> 
> # `|` 并集运算 | `|` Union Set Operation
> res2 = s9 | s10
> print('Union_Set_Operation=', res2)  # Output result: Union_Set_Operation= {1, 2, 3, 4, 5, 6, 7}
> 
> # `-` 差集运算 | `-` Difference Set Operation
> res3 = s9 - s10
> print('Difference_Set_Operation=', res3)  # Output result: Difference_Set_Operation= {1, 2}
> 
> # `^` 异或集运算 | `^` XOR set operation
> res4 = s9 ^ s10
> print('XOR_Set_Operation=', res4)  # Output result: XOR_Set_Operation= {1, 2, 6, 7}
> 
> # `<=` 检查集合是否为另一个集合的子集 | `<=` Checks if a collection is a subset of another collection
> # 如果a集合中的元素全部在b集合中出现, 则a集合称之为b集合的子集, b集合即使a集合的超集
> collection_subset = s9 <= s10
> print('Collection_Subset=', collection_subset)  # Output result: Collection_Subset= True
> 
> # `<` 检查集合是否为另一个集合的真子集 | `<` Checks if a set is a true subset of another set
> # 如果超集b中含有子集a中的所有元素, 并且b中包含a中没有的元素则称之b为真超集, a是b的真子集
> res5 = {1, 2, 3} < {1, 2, 3, 4, 5}
> print('res5=', res5)  # res5= True
> 
> # `>=` 检查集合是否为另一个集合的超集 | `> =` Checks if a collection is a superset of another collection
> res6 = s9 >= s10
> print('res6=', res6)  # res6= False
> 
> # `>` 检查集合是否为另一个集合的真超集 | `>` Check if a collection is a true superset of another collection
> res7 = s9 > s10
> print('res7=', res7)  # res7= False
> ```

### 7.9 Python 函数
#### 7.9.1 函数 简介
> 函数是组织好的, 可重复使用的, 用来实现单一或相关联功能的代码段.
> 
> 函数能提高应用的模块性和代码的重复利用率, 已经知道Python提供了许多内建函数, 比如print(), 但你也可以自己创建函数, 这被叫做用户自定义函数.
> 
> **1.定义一个函数**
> 
> 你可以定义一个由自己想要功能的函数, 以下是简单的规则：
> 
> 函数代码块以`def`关键词开头, 后接函数标识符名称和圆括号`()`.
> 
> 任何传入参数和自变量必须放在圆括号中间, 圆括号之间可以用于定义参数.
> 
> 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明.
> 
> 函数内容以冒号起始, 并且缩进.
> 
> `return [表达式]` 结束函数, 选择性地返回一个值给调用方, 不带表达式的return相当于返回None.
> 
> **2.定义 函数 语法**
> 默认情况下, 参数值和参数名称是按函数声明中定义的顺序匹配起来的.
> ``` py
> def functionname( parameters ):
>    "函数_文档字符串"
>    function_suite
>    return [expression]
> ```
> **3.函数定义与调用**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> 
> # 定义函数 | Defining functions
> def functions():
>     print('\nI am a function !\n')
> 
> 
> # 调用函数 | call function
> functions()
> ```

#### 7.9.2 函数 参数 & 参数传递方式
> 在定义函数时可以在函数名后的()中定义数量不等的形参, 多个形参之间使用英文状态下的逗号`,`隔开.
> 
> `形参 (形式参数)` : 定义形参就相当于在函数内部声明了变量, 但是并不赋值.
> 
> `实参 (实际参数)`: 如果函数定义时指定了形参, 那么在调用函数时也必须传递实参, 实参将会赋值给对应的形参, 简单来，有几个形参就得传几个实参.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions1(num1, num2, num3=30):
>     print('res=', num1 * num2 * num3)
> 
> 
> # 调用函数 | call function
> functions1(10, 20)
> ```
> 
> **1.实参的传递方式**
> 
> `位置参数`: 位置参数就是将对应位置的实参复制给对应位置的形参, 第一个实参赋值给第一个形参, 第二个实参赋值给第二个形参以此类推. 例如: `functions1(10, 20)`
> 
> `关键字参数` : 可以不按照形参定义的顺序去传递, 而直接根据参数名去传递参数, 位置参数和关键字参数可以混合使用, 混合使用关键字和位置参数时，必须将位置参数写到前面. 例如: `functions1(10, 20, num3=30)`
> 
> **2.实参类型**
> 
>  函数在调用时解析器不会检查实参的类型, 实参可以传递任意类型的对象.
>  
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions2(num):
>     # 在函数中对形参进行重新赋值, 不会影响其他的变量
>     # a = 20
>     # num是一个列表尝试修改列表中的元素
>     # 如果形参执行的是一个对象，可以通过形参去修改对象时, 会影响到所有指向该对象的变量
>     num[0] = 30
>     print('num =', num, id(num))
> 
> values = 10
> values = [1, 2, 3]
> 
> # 调用函数 | call function
> functions2(values)
> functions2(values.copy())
> functions2(values[:])
> ```
> 
> **3.装包：不定长参数**
> 在定义函数时候,可以在形参前添加`*`星号, 这种定义的函数中的形参将会获取所有的实参, 它将所有的实参保存到元祖中.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> # `*num1` 将接受所为位置参数并且会将实参统一保存元祖中
> def functions3(*nums1):
>     print('nums1=', nums1, 'type=', type(nums1))
> 
> 
> # 调用函数 | call function
> functions3()
> functions3(1, 3, 5, 7, 9)
> 
> 
> # 定义函数 | Defining functions
> def functions4(*nums):
>     res = 0  # 定义初始化变量, 保存结果集
>     for data in nums:
>         res += data
>     print('res=', res)
> 
> 
> # 调用函数 | call function
> functions4(6)
> functions4(6, 6)
> functions4(6, 6, 6)
> functions4(6, 6, 6, 6)
> functions4(6, 6, 6, 6, 6)
> 
> 
> # 定义函数 | Defining functions
> # `**` 形参可以接收其他关键字参数, 它将这些参数保存在字典中
> # 字典中keys就是参数的名字, 字典中values就是参数的值
> def functions5(**nums):
>     print('**nums=', nums, 'type=', type(nums))
> 
> 
> # 调用函数 | call function
> functions5()
> ```
> 
> **4.参数解包**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions6(nums1, nums2, nums3):
>     print('sum=', nums1 + nums2 + nums3)
> 
> 
> # 定义 元祖 | Definition Tuple
> tuples = (10, 10, 10)
> # 调用函数 | call function
> # 传递参数时,可以在序列类型参数前添加`*`星号,这样称之为参数解包,会自动将序列中的元素依次作为参数传递
> functions6(*tuples)
> 
> 
> # 定义函数 | Defining functions
> def functions7(nums1, nums2, nums3):
>     print('nums1=', nums1, 'nums2=', nums2, 'nums3=', nums3)
> 
> 
> # 定义字典 | Definition Dictionary
> dictionary = {'nums1': '1', 'nums2': '2', 'nums3': '3'}
> # 调用函数 | call function
> # 通过`**`对字典进行解包操作
> functions7(**dictionary)
> ```


#### 7.9.3 返回值
> 返回值就是函数执行以后返回的结果.
> 
> 可以通过`return`关键字来指定函数的返回值.
> 
> 可以之间使用函数返回值,也可以通过变量来接收函数返回值.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions8():
>     return 100
> 
> 
> # 调用函数 | call function
> r = functions8()
> print('r=', r)
> 
> 
> # 定义函数 | Defining functions
> def functions9(*nums):
>     res = 0  # 定义初始化变量, 保存结果集
>     for data in nums:
>         res += data
>         return res
> 
> 
> # 调用函数 | call function
> r1 = functions9(10)
> print('r1=', r1 + 10)
> ```

#### 7.9.4 文档字符串 
> `help()`是python中的内置函数, 通过此函数可以查询python中的函数使用方法, 也称之为帮助文档.
> 
> 使用语法：`help(函数对象)`
> 
> 在自定义函数时, 可以在该函数内部定义文档字符串,等价于自定义函数说明.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 调用help函数
> help(print)  # 查询print函数使用方法
> help(dict)  # 查询dict函数使用方法
> help(map)  # 查询map函数使用方法
> 
> 
> def functions10(value1: int, value2: bool, value3: str = 'string') -> int:
>     '''
>     自定义函数 实例
> 
>     自定义函数 作用：
> 
>     自定义函数 参数：
>         `value1` 作用 / 类型 / 默认值 .....
>         `value2` 作用 / 类型 / 默认值 .....
>         `value3` 作用 / 类型 / 默认值 .....
>     '''
>     print('functions10')
> 
> 
> help(functions10)  # 查询自定义函数使用方法
> ```


#### 7.9.5 作用域 & 命名空间
> **1.作用域**：作用域是指变量生效的区域.
> 在python中作用域分为两种：`全局作用域` / `函数作用域`.
> 
> `全局作用域`：
> - 全局作用域在程序执行时创建, 在程序执行结束时销毁.
> - 所有函数意外的区域全都是全局作用域.
> - 在全局作用域中定义变量，都属于全局变量, 全局变量可以在程序任意位置被访问.
> 
> 
> `函数作用域`：
> - 函数作用域在函数调用时创建, 在调用结束后销毁.
> - 函数每一次调用时就会产生一个新的函数作用域.
> - 在函数作用域中定义变量都是局部变量, 只能在函数内部访问.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 作用域 | Scope
> # 定义变量 用于全局作用域 | Define variables for global scope
> variables = 10
> 
> 
> # 定义函数 | Defining functions
> def functions11():
>     '''
>     定义变量 用于局部作用域 | Define variables for local scope
>     `data2`变量定义在函数内部,所以它的作用域就是在函数内部,函数外部无法访问
>     :return:
>     '''
>     data2 = 10
>     global data1  # 声明`data1`在函数内部变量为全局变量
>     data1 = 10
> 
>     print('函数内部声明全局变量=', data1)
>     print('函数内部=', data2)
> 
> 
> print('函数外部=', variables)
> functions11()
> ```
> 
> **2.命名空间**：是指变量存储的位置, 每一个变量都需要存储到指定的命名空间当中.
> - 每一个作用域都会有自身对应的命名空间.
> - 全局命名空间用来保存全局变量, 函数命名空间用来保存函数中的变量.
> - 命名空间实际上就是字典, 是专门用来保存变量的字典.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 命名空间 | Namespaces
> '''
> `locals()`函数用来获取当前作用域的命名空间, 返回值类型是字典类型
> 如果在全局作用域中调用此函数则是获取全局命名空间
> 如果在函数作用域中调用次函数则是获取函数命名空间
> '''
> namespaces = locals()
> print('Namespaces=', namespaces, '\ntype=', type(namespaces))
> 
> 
> # 定义函数 | Defining functions
> def functions12():
>     '''
>     `globals()`函数可以用来在任意位置获取全局命名空间
>     '''
>     namespaces1 = globals()
>     print('Namespaces=', namespaces1, '\ntype=', type(namespaces1))
> 
> 
> # 调用函数 | call function
> functions12()
> ```


#### 7.9.6 递归
> 简单的说递归函数就是在函数中自己调用自己.
> 
> 递归是解决问题的一种方式, 整体思想是将一个大的问题分解为若干个小问题,直到问题无法分解时,在去解决问题.
> 
> 递归式函数分为两个条件：
> - 1.`基线条件`：问题可以分解为最小问题, 当满足基线条件时,递归就不再执行.
> - 2.`递归条件`：将问题继续分解条件.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 递归 | Recursive
> # 无穷递归: 如果此函数被调用时,容易导致程序内存溢出,效果类似于死循环
> def functions13():
>     functions13()
> 
> 
> # 定义 递归函数 | Defining Recursive functions
> # 求任意数字的阶乘 | Find the factorial of any number
> def functions14(num: int) -> int:
>     # 定义 基线条件: 判断num是否等于1, 如果等于1则不再进行递归调用
>     if num == 1:
>         return 1
>     else:
>         # 定义 递归条件：如果num=10则返回num*自身函数(num-1)的阶乘 => 10 * 9!
>         return num * functions14(num - 1)
> 
> 
> # 求任意数字的幂次方 | Find the power of any number
> def functions15(num1, num2):
>     # 定义 基线条件: 求1幂运算
>     if num2 == 1:
>         return num1
>     else:
>         # 定义 递归条件
>         return num1 * functions15(num1, num2 - 1)
> 
> 
> # 定义 检查回文 函数 | Definition check palindrome function
> def check_palindrome(string):
>     # 定义 基线条件
>     if len(string) < 2:
>         return True
>     elif string[0] != string[-1]:
>         return False
>     # 定义 递归条件
>     return check_palindrome(string[1: 1])
> 
> 
> # 调用函数 | call function
> print('functions14=', functions14(10))
> print('functions15=', functions15(8, 6))
> print('check_palindrome=', check_palindrome('abccba'))
> print('check_palindrome=', check_palindrome('abc'))
> print('check_palindrome=', check_palindrome('123'))
> print('check_palindrome=', check_palindrome('123321'))
> ```


#### 7.9.7 高阶函数
> 高阶函数英文叫`Higher-order function`.
> 
> 高阶函数至少符合两个特点: 接受一个或多个函数作为参数或将函数作为返回值返回的函数就称之为高阶函数.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 高阶函数 | higherOrderFunctions
> list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
> 
> 
> # 定义 检查偶数数函数 | Definition check even function
> def even_function(num):
>     if num % 2 == 0:
>         return True
>     return False
> 
> 
> # 定义 检查奇数函数 | Definition check odd function
> def odd_function(num):
>     if num % 3 == 0:
>         return True
>     return False
> 
> 
> # 定义 检查 列表中大于6的数值函数
> def more_than_the(num):
>     if num > 6:
>         return True
>     return False
> 
> 
> # 定义函数 | Defining functions
> def higher_order_function(functions, data):
>     new_list = []  # 定义 空集合, 用于储存奇数集合
>     for x in data:
>         if functions(x):
>             new_list.append(x)
>     return new_list
> 
> 
> # 调用函数 | call function
> print('higher_order_function=', higher_order_function(even_function, list_1))
> print('higher_order_function=', list(filter(odd_function, list_1)))
> print('higher_order_function=', list(filter(more_than_the, list_1)))
> ```


##### 7.9.7.1 匿名函数
> 匿名函数`lambda`函数表达式(语法糖).
> 
> `lambda`函数表达式专门用来创建一些简单函数, 它是函数创建的又一种方式.
> 
> 匿名函数一般都是作为参数使用, 其他地方一般不会使用.
> 
> 匿名函数语法: `lambda` 参数列表: 返回值
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 匿名函数 | Anonymous function
> anonymous_function01 = (lambda a, b: a * b)
> anonymous_function02 = (lambda a, b: a + b)(30, 30)
> anonymous_function03 = (lambda x: x % 2 == 0)
> anonymous_function04 = (lambda x: x % 2 != 0)
> anonymous_function05 = (lambda x: x > 5)
> 
> print('anonymous_function01=', anonymous_function01)
> print('anonymous_function02=', anonymous_function02)
> print('anonymous_function03=', list(filter(anonymous_function03, list_1)))
> print('anonymous_function04=', list(filter(anonymous_function04, list_1)))
> print('anonymous_function05=', list(filter(anonymous_function05, list_1)))
> ```


##### 7.9.7.2 map()函数
> map()函数可以对可迭代对象中所有元素做指定的操作, 然后将其添加到一个新的对象中返回.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # map函数 | map function
> maps1 = map(lambda x: x + 1, list_1)
> maps2 = map(lambda x: x ** 2, list_1)
> print('maps1=', list(maps1))
> print('maps2=', list(maps2))
> ```

##### 7.9.7.3 sort()方法
> 该方法用来对列表中的元素进行排序, 默认是直接比较列表中的元素的大小.
> 
> 在sort()可以接收一个关键字参数,  key需要一个函数作为参数, 当设置了函数作为参数.
> 
> 每次都会以列表中的一个元素作为参数来调用函数, 并且使用函数的返回值来比较元素的大小
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # sort方法 | sort method
> list_2 = ['b', 'a', 'd', 'c']
> list_3 = ['bb', 'aaa', 'dddd', 'ccccc']
> list_2.sort()
> # list_3.sort(key=len)
> 
> print('sort=', list_2)
> print('sort=', list_3)
> ```

##### 7.9.7.4 sorted()函数
> 此函数和sort()的用法基本一致, 但是sorted()可以对任意的序列进行排序, 并且使用sorted()排序不会影响原来的对象, 而是返回一个新对象.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # sorted函数 | sorted function
> list_4 = [3, '1', 5, '9', 2, '4', 7, 6]
> print('Before sorting: ', list_4)
> print('Sorted: ', sorted(list_4, key=int))
> print('After sorting: ', list_4)
> 
> list_5 = 'iighrghcjshfjkewhfiwlkgoaggdljhsjdewkfk'
> print('Before sorting: ', list_5)
> print('Sorted: ', sorted(list_5, key=str))
> print('After sorting: ', list_5)
> ```


##### 7.9.7.5 闭包
> 将函数作为返回值返回也是一种高阶函数, 称为叫做闭包.
> 
> 通过闭包可以创建一些只有当前函数能访问的变量.
> 
> 可以将一些私有的数据藏到的闭包中.
> 
> 形成闭包的要件： 1.函数嵌套 / 2.将内部函数作为返回值返回 / 3.内部函数必须要使用到外部函数的变量
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 闭包 | Closure
> # 定义函数 | Defining functions
> def functions16():
>     def inner():
>         print('inner !')
> 
>     # 将内部函数作为返回值 | Using internal functions as return values
>     return inner
> 
> 
> # 调用函数 | call function
> print('functions16=', functions16())
> '''
> r16是一个函数, 是调用functions16()后返回的函数
> 此函数是在functions16()内部定义, 并不是全局函数
> 所以此函数总是能访问到functions16()函数内的变量
> '''
> r16 = functions16()
> r16()
> 
> 
> # 定义函数 | Defining functions
> def functions17():
>     # 定义 内部空集合 | Definition Internal empty collection
>     nums = []
> 
>     # 定义 内部函数 | Definition internal function
>     def functions18(num):
>         # 添加集合元素 | Adding collection elements
>         nums.append(num)
>         # 计算返回平均值 | Calculate return average
>         return sum(nums) / len(nums)
> 
>     # 将内部函数作为返回值返回 | Return internal function as return value
>     return functions18
> 
> 
> # 调用函数 | call function
> # 在外部无法访问内部空集合, 只有在内部可以访问, 即表示变量的私有属性
> functions19 = functions17()
> print('functions19=', functions19(30))
> print('functions19=', functions19(3020))
> print('functions19=', functions19(5020))
> ```


##### 7.9.7.6 装饰器
> 装饰器既是在不修改原函数的情况下来对函数进行扩展.
> 
> 只需要根据现有的函数来创建一个新的函数.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 装饰器 | Decorator
> # 定义函数 | Defining functions
> '''
> 当前方式, 已经可以在不修改源代码的情况下对函数进行扩展
> 但是当前方式要求在每扩展一个函数就要手动创建一个新的函数实在是太麻烦
> 为了解决这个问题, 则创建一个函数, 让这个函数可以自动的帮助生产函数
> '''
> 
> def functions20(num1, num2):
>     print('res=', num1 * num2)
> 
> 
> # 定义函数 | Defining functions
> def functions21(num1, num2):
>     print('Start Calculating...')
>     functions20(num1, num2)
>     print('End Calculation...')
> 
> 
> # 调用函数 | call function
> functions21(5, 6)
> 
> # 定义函数 | Defining functions
> '''
> 此函数用来对其他函数进行扩展, 使其他函数可以在执行前后打印日志信息
> 函数参数：`fun` 需要扩展的函数对象
> '''
> 
> 
> def extension_function(fun):
>     '''
>     定义 装饰器函数 | Define decorator function
> 
>     `decorator_function()`函数就称之为装饰器
>     通过装饰器可以在不修改原来函数的情况下来对函数进行扩展
>     在开发中都是通过装饰器来扩展函数的功能
>     在定义函数时可以通过`@`装饰器来使用指定的装饰器来装饰当前的函数
>     可以同时为一个函数指定多个装饰器, 这样函数将会按照从内向外的顺序被装饰
> 
>     非必填参数 args
>     非必填参数 keywords
>     :param fun:
>     :return:
>     '''
> 
>     def decorator_function(*args, **keywords):
>         print('Begin execution')
>         # 调用被扩展函数 | Call the extended function
>         result = fun(*args, **keywords)
>         print('End execution')
>         # 返回函数执行结果 | Returns the result of function execution
>         return result
> 
>     # 返回新函数 | Return new function
>     return decorator_function
> 
> 
> funs = extension_function(functions20)
> r18 = funs(10, 20)
> 
> # 定义 扩展函数 | Definition extension function
> '''
>     在定义函数时可以通过`@`装饰器来使用指定的装饰器来装饰当前的函数
>     可以同时为一个函数指定多个装饰器, 这样函数将会按照从内向外的顺序被装饰
> '''
> 
> 
> # 引入 自定义装饰器 | Introducing custom decorators
> @extension_function
> def hello():
>     print('Hello World ~')
> 
> 
> # 调用函数 | call function
> hello()
> ```


### 7.10 Python 面向对象
> **1. 什么是对象**
> - 对象是内存中专门用来存储数据的一块区域.
> - 对象中可以存放各种数据(比如集合、数据类型、代码)等等.
> 
> **2. 对象由三部分组成**
> - [1] 对象的标识 (id)
> - [2] 对象的类型 (type)
> - [3] 对象的值 (value)
> 
> **3. 面向对象 (OOP)**
> - Python是一门面向对象的编程语言.
> - 所谓的面向对象的语言, 简单理解就是语言中的所有操作都是通过对象来进行的.
> 
> **4. 面向过程编程语言** 
> - 简单理解就是语言中的所有操作都是通过对象来进行的.
> - 面向过程的编程语言: 面向过程指将程序的逻辑分解为一个一个的步骤,通过对每个步骤的抽象来完成程序.
> - 面向过程的编程思想: 将一个功能分解为一个一个小的步骤, 通过完成一个一个的小的步骤来完成一个程序, 这种编程方式符合我们人类的思维, 编写起来相对比较简单, 但是以这种方式编码的往往只适用于一个功能, 如果要在实现其他功能, 即使功能相差极小, 也往往要重新编写代码, 所以它可复用性比较低, 并且难于维护.
> 
> **5. 面向对象编程语言**
> - 面向对象的编程语言关注的是对象而不关注过程.
> - 对于面向对象的语言来说, 一切都是对象.
> - 面向对象的编程思想: 将所有的功能统一保存到对应的对象中,  要使用某个功能直接找到对应的对象即可, 这种方式的编码比较容易阅读, 并且比较易于维护, 容易复用.
> 
> **6. 面向对象 三大特征**
> - 封装: 确保对象中数据安性
> - 继承: 保证对象的可扩展性
> - 多态: 保证程序灵活性


####  7.10.1 类 class
> **1. 类的简介**
> 目前所学习的对象都是Python内置的对象.
> 
> 但是内置对象并不能满足所有的需求, 所以在开发中经常需要自定义一些对象.
> 
> 类就是一个用来创建对象的对象, 对象是类的实例, 如果多个对象是通过一个类创建的, 则称这些对象是一类对象.
> 
> **2. 定义 类**
> 定义 类的语法:
> ```
> class 类名([父类]):
>     代码块
> ```
> 类和对象都是对现实生活中的事物或程序中的内容的抽象.
> 
> 实际上所有的事物都由两部分构成: 1.数据 (属性) / 2.行为 (方法)
> 
> 在类的代码块中可以定义变量和函数.
> 
> 变量会成为该类实例的公共属性, 所有的该类实例都可以通过`对象.属性名`形式访问.
> 
> 函数会成为该类实例的公共方法, 所有该类实例都可以通过`对象.方法名()`形式调用方法.
> 
> ⚠️  注意 ⚠️ : 方法调用时, 第一个参数由解析器自动传递, 所以定义方法时至少要定义一个形参.
> 
> 类中定义的属性和方法都是公共的, 任何该类实例都可以访问.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 定义 实例 | Definition instance
> # 创建int实例 | Create an int instance
> nums = int(100)
> print('nums=', nums, type(nums))
> 
> 
> # 定义 类 | Definition class
> class CoreClass:
>     pass
> 
> 
> # 创建对象实例 | Create Object instance
> cc = CoreClass()
> cc1 = CoreClass()
> cc2 = CoreClass()
> cc3 = CoreClass()
> print('cc=', cc, type(cc))
> 
> # 检查对象实例 | Check object instance
> res1 = isinstance(cc, CoreClass)
> res2 = isinstance(cc1, CoreClass)
> res3 = isinstance(cc2, CoreClass)
> res4 = isinstance(cc2, int)
> print('res1=', res1)
> print('res2=', res2)
> print('res3=', res3)
> print('res4=', res4)
> 
> # 定义 类 | Definition class
> class Product():
>     # 定义 属性 | Definition attribute
>     product_name = 'Mobile phone'
>     product_size = '26 * 30'
>     product_weight = 20
>     product_colour = 'black'
> 
>     # 定义 方法 | Definition method
>     def product_info(self):
>         print('product_info')
> 
> 
> # 创建实例 | Create instance
> p1 = Product()
> p2 = Product()
> 
> # 调用 属性 | Call attribute
> r1 = p1.product_name
> r2 = p2.product_colour
> print('product_name=', r1)
> print('product_colour=', r2)
> 
> # 调用 方法 | Call method
> p1.product_info()
> p2.product_info()
> ```
> 
> **3. 属性 & 方法**
> 当调用一个对象的属性时, 解析器会先在当前对象中寻找是否含有该属性, 如果有则直接返回当前的对象的属性值, 如果没有则去当前对象的类对象中去寻找, 如果有则返回类对象的属性值, 如果类对象中依然没有则报错.
> 
> 类对象和实例对象中都可以保存属性&方法.
> 
> 如果这个属性&方法是所有的实例共享, 则应该将其保存到类对象中.
> 如果这个属性&方法是某个实例独有, 则应该保存到实例对象中.
> 
> 一般情况下, 属性保存到实例对象中, 而方法需要保存到类对象中.
> 方法每次被调用时解析器都会自动传递第一个实参, 第一个参数就是调用方法的对象本身, 一般都会将这个参数命名为`self`
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 定义 类 | Definition class
> class Product:
>     # 定义 属性 | Definition attribute
>     product_name = 'Mobile phone'
>     product_size = '26 * 30'
>     product_weight = 20
>     product_colour = 'black'
> 
>     # 定义 方法 | Definition method
>     def product_info(self):
>         print('product_info=', self.product_name, self.product_size, self.product_weight, self.product_colour)
> 
> 
> # 创建实例 | Create instance
> p1 = Product()
> p2 = Product()
> 
> # 调用 属性 | Call attribute
> r1 = p1.product_name = 'Apple Mobile phone'
> r2 = p2.product_colour = 'Gradient color'
> print('product_name=', r1)
> print('product_colour=', r2)
> 
> # 调用 方法 | Call method
> p1.product_info()
> p2.product_info()
> ```
> 
> **5. 对象的初始化**
> 在类中可以定义一些特殊方法, 以`__`下划线开头, 以`__`下划线结尾的方法称之为特殊方法.
> 
> 特殊方法由Python解析器自动调用, 不需要开发者自己调用, 特殊方法将会在特殊的时刻自动调用.
> 
> **5.1. 创建对象的流程**
> ```
> obj = Object()的运行流程
> 1. 创建变量
> 2. 在内存中创建新对象
> 3. __init__(self)方法执行
> 4. 将对象id赋值给变量
> ```
> init会在对象创建以后立刻执行, init可以用来向新创建的对象中初始化属性, 调用类创建对象时, 类后面的所有参数都会依次传递到init()中.
> 
>`类的基本结构`
> ```
> class 类名([父类]) :
> 
>     公共属性... 
>     
>     # 对象初始化方法
>     def __init__(self, ...):
>         ...
> 
>     # 其他方法    
>     def method_1(self, ...):
>         ...
> 
>     def method_2(self, ...):
>         ...
> 
>     ...   
> ```
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 对象 初始化 | Object initialization
> # 定义 类 | Definition class
> class Commodity:
>     # 定义初始化方法 | Define the initialization method
>     def __init__(self, commodity_brand, commodity_model, commodity_colour, commodity_operating_system, commodity_ram,commodity_of_sale, commodity_price):
>         self.commodity_brand = commodity_brand
>         self.commodity_model = commodity_model
>         self.commodity_colour = commodity_colour
>         self.commodity_operating_system = commodity_operating_system
>         self.commodity_ram = commodity_ram
>         self.commodity_of_sale = commodity_of_sale
>         self.commodity_price = commodity_price
> 
>     # 定义 自定义 方法 | Define custom method
>     def commodity_info(self):
>         print('Commodity Info:', self.commodity_brand,
>               self.commodity_model, self.commodity_colour, self.commodity_operating_system, self.commodity_ram,
>               self.commodity_of_sale, self.commodity_price)
> 
> 
> # 创建实例 | Create instance
> commodity_1 = Commodity('Apple', 'iphone X', 'White', 'Ios', '256GB', 'Global', '4500RMB')
> commodity_2 = Commodity('Samsung', 'S3', 'Blue', 'Android', '16GB', 'Global', '900RMB')
> commodity_3 = Commodity('Huawei', 'P30', 'Black', 'Android', '256GB', 'Global', '5600RMB')
> 
> # 调用 方法 | Call method
> commodity_1.commodity_info()
> commodity_2.commodity_info()
> commodity_3.commodity_info()
> ```

####  7.10.2 封装
> 封装是面向对象的三大特性之一, 封装指的是隐藏对象中一些不希望被外部所访问到的私有属性或方法.
> 
> 使用封装确实增加了类的定义的复杂程度, 但是它也确保了数据的安全性.
> 
> 将对象的属性名修改为隐藏属性名, 目的是让调用者无法随意修改对象中的属性, 增加getter&setter方法, 很好的控制的属性是否是只读性.
> 
> 定义私有属性需要提供`getter`&`setter`方法使外部可以访问到属性.
> 
> getter 获取对象中的指定属性 (get_属性名)
> 
> setter 用来设置对象的指定属性 (set_属性名)
> 
> 如果希望属性是只读则可以直接去掉setter方法, 如果希望属性不能被外部访问则可以直接去掉getter方法.
> 
> 提供`getter`&`setter`方法的作用: 
> 
> 使用setter方法设置属性, 可以增加数据的验证, 确保数据的值是正确性.
> 
> 使用getter方法获取属性, 使用setter方法设置属性, 可以在读取属性和修改属性的同时做一些其他的处理, getter方法还可以表示一些计算的属性.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 面向对象 (封装) | Object-oriented (encapsulation)
> # 定义 类 | Definition class
> class Animals:
> 
>     # 定义 初始化方法 | Definition initialization method
>     def __int__(self, animal_name, animal_type, animal_age, animal_diet):
>         self.hidden_animal_name = animal_name
>         self.hidden_animal_type = animal_type
>         self.hidden_animal_age = animal_age
>         self.hidden_animal_diet = animal_diet
> 
>     # 自定义方法 | Custom method
>     def info(self):
>         print('info=', self.hidden_animal_name, self.hidden_animal_type, self.hidden_animal_age,  self.hidden_animal_diet)
> 
>    '''
>     定义 getter&setter方法 | Define getter & setter method
>     get_xxx()方法 用来获取对象属性
>     set_xxx()方法 用来修改对象属性
>     '''
> 
>     def get_animal_name(self):
>         return self.hidden_animal_name
> 
>     def set_animal_name(self, animal_name):
>         self.hidden_animal_name = animal_name
> 
>     def get_animal_type(self):
>         return self.hidden_animal_type
> 
>     def set_animal_type(self, animal_type):
>         self.hidden_animal_type = animal_type
> 
>     def get_animal_age(self):
>         return self.hidden_animal_age
> 
>     def set_animal_age(self, animal_age):
>         if animal_age > 0:
>             self.hidden_animal_age = animal_age
> 
>     def get_animal_diet(self):
>         return self.hidden_animal_diet
> 
>     def set_animal_diet(self, animal_diet):
>         self.hidden_animal_diet = animal_diet
> 
> 
> # 创建实例 | Create instance
> animals_1 = Animals()
> 
> # 为实例赋值 | Assigning values ​​to instances
> animals_1.set_animal_name('Cat')
> animals_1.set_animal_type('Feline')
> animals_1.set_animal_age(10)
> animals_1.set_animal_diet('Fish')
> 
> # 调用 方法 | Call method
> animals_1.info()
> ```
> 
> 可以为对象的属性使用双下划线开头，`__xxx`
> 
> 双下划线开头的属性是对象的隐藏属性, 隐藏属性只能在类的内部访问, 无法通过对象访问, 以`__`开头的属性是隐藏属性, 无法通过对象访问.
> 
> 使用`__`开头的属性, 实际上依然可以在外部访问, 一般会将一些私有属性(不希望被外部访问的属性)以`_`单下划线开头.
> 
> 一般情况下使用`_`单下划开头的属性都是私有属性, 没有特殊需要应避免修改私有属性.
> 
> **1. property装饰器**
> - property装饰器用来将get方法转换为对象的属性.
> - 添加为property装饰器后可以像调用属性一样使用get方法.
> - 使用property装饰的方法, 必须和属性名保持一致性.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # Property 装饰器 | property decorator
> # 定义 类 | Definition class
> class Zoo():
>     # 定义 初始化方法 | Definition initialization method
>     def __int__(self, animal_name, animal_type, animal_age, animal_diet):
>         self._animal_name = animal_name
>         self._animal_type = animal_type
>         self._animal_age = animal_age
>         self._animal_diet = animal_diet
> 
>     # 自定义方法 | Custom method
>     def info(self):
>         print('info=', self._animal_name, self._animal_type, self._animal_age, self._animal_diet)
> 
>     # 定义 getter&setter方法 | Define getter & setter method
>     @property
>     def animal_name(self):
>         return self._animal_name
> 
>     @property
>     def animal_type(self):
>         return self._animal_type
> 
>     @property
>     def animal_age(self):
>         return self._animal_age
> 
>     @property
>     def animal_diet(self):
>         return self._animal_diet
> 
>     @animal_name.setter
>     def animal_name(self, animal_name):
>         self._animal_name = animal_name
> 
>     @animal_type.setter
>     def animal_type(self, animal_type):
>         self._animal_type = animal_type
> 
>     @animal_age.setter
>     def animal_age(self, animal_age):
>         self._animal_age = animal_age
> 
>     @animal_diet.setter
>     def animal_diet(self, animal_diet):
>         self._animal_diet = animal_diet
> 
> 
> # 创建实例 | Create instance
> z = Zoo()
> 
> # 为实例赋值 | Assigning values ​​to instances
> z.animal_name = 'lion'
> z.animal_type = 'Feline'
> z.animal_age = 12
> z.animal_diet = 'Meat'
> 
> # 调用 方法 | Call method
> z.info()
> 
> # 调用 属性 | # 调用 属性
> print('animal_name=', z.animal_name)
> print('animal_type=', z.animal_type)
> print('animal_age=', z.animal_age)
> print('animal_diet=', z.animal_diet)
> ```



####  7.10.3 继承
> 继承是面向对象三大特性之一, 通过继承可以使一个类获取到其他类中的属性和方法.
> 
> 在定义类时可以在类名后的括号中指定当前类的父类(超类、基类、super), 子类(衍生类)可以直接继承父类中的所有的属性和方法.
> 
> 通过继承可以直接让子类获取到父类的方法或属性, 避免编写重复性的代码, 可通过继承来对一个类进行扩展, 并且也符合OCP原则.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 继承 | inherit
> # 定义 父类 | Definition father class
> class Cars:
>     # 定义 汽车信息 方法 | Definition car information method
>     def car_info(self):
>         print('Car info')
> 
> 
> # 定义子类  继承父类 | Defining subclasses inheriting parent classes
> class BMW(Cars):
>     def bmv_info(self):
>         print('BMW info')
> 
> 
> # 创建实例 | Create instance
> bmw = BMW()
> 
> # 子类实例 调用方法 | Subclass instance call method
> bmw.car_info()
> bmw.bmv_info()
> 
> # 检查对象实例 | Check object instance
> instance_res1 = isinstance(bmw, Animals)
> instance_res2 = isinstance(bmw, Cars)
> instance_res3 = isinstance(bmw, BMW)
> 
> print('instance_res1=', instance_res1)
> print('instance_res2=', instance_res2)
> print('instance_res3=', instance_res3)
> 
> # issubclass() 检查一个类是否是另一个类的子类
> issubclass_res1 = issubclass(BMW, Animals)
> issubclass_res2 = issubclass(Cars, BMW)
> issubclass_res3 = issubclass(BMW, Cars)
> issubclass_res4 = issubclass(Cars, object)
> issubclass_res5 = issubclass(BMW, object)
> 
> print('issubclass_res1=', issubclass_res1)
> print('issubclass_res2=', issubclass_res2)
> print('issubclass_res3=', issubclass_res3)
> print('issubclass_res4=', issubclass_res4)
> print('issubclass_res5=', issubclass_res5)
> ```
> 
> **1. 方法重写**
> - 如果在子类中如果有和父类同名的方法, 则通过子类实例去调用方法时, 会调用子类的方法而不是父类的方法, 这个特点就称之为方法的重写(覆盖 Override).
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 继承 | inherit
> # 定义 父类 | Definition father class
> class Cars:
>     # 定义 汽车信息 方法 | Definition car information method
>     def car_info(self):
>         print('Car info')
> 
> 
> # 定义子类  继承父类 | Defining subclasses inheriting parent classes
> class BMW(Cars):
>     def bmv_info(self):
>         print('BMW info')
> 
>     # 方法重写 | Method rewrite
>     def car_info(self):
>         print('Car info = BMW')
> 
> 
> # 创建实例 | Create instance
> bmw = BMW()
> 
> # 子类实例 调用方法 | Subclass instance call method
> bmw.car_info()
> bmw.bmv_info()
> ```
> 
> - 调用方法优先级: 当调用一个对象的方法时, 会优先去当前对象中寻找是否具有该方法, 如果有则直接调用, 如果没有, 则去当前对象的父类中寻找, 如果父类中有则直接调用父类中的方法, 如果没有, 则去父类的父类中寻找, 以此类推直到找到object, 如果依然没有找到则出现异常.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 调用 方法优先级 | Call method priority
> # 定义 父类 A | Definition father class A
> class A(object):
>     def cores(self):
>         print('AAA')
> 
> 
> # 定义 子类 B 继承 父类 A | Definition subclass B inherits parent class A
> class B(A):
>     def cores(self):
>         print('BBB')
> 
> 
> # 定义 子类 C 继承 B | Definition subclass C inherits B
> class C(B):
>     def cores(self):
>         print('CCC')
> 
> 
> # 创建实例 | Create instance
> c = C()
> 
> # 调用方法 | Calling method
> c.cores()  # OutPut CCC
> ```
> 
> **2. super()**
> - 希望可以直接调用父类的`__init__`来初始化父类中定义的属性.
> - `super()`可以用来获取当前类的父类, 并且通过super()返回对象调用父类方法时, 不需要传递self.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # super()
> # 定义 父类 | Definition father class
> class Car:
>     # 定义 初始化方法 | Definition initialization method
>     def __int__(self, car_name):
>         self._car_name = car_name
> 
>     # 定义 getter&setter方法 | Define getter & setter method
>     @property
>     def car_name(self):
>         return self._car_name
> 
>     @car_name.setter
>     def car_name(self, car_name):
>         self._car_name = car_name
> 
>     # 定义 汽车信息 方法 | Definition car information method
>     def car_info(self):
>         print('Car info')
> 
> 
> # 定义子类  继承父类 | Defining subclasses inheriting parent classes
> # 父类中的所有方法都会被子类继承, 包括特殊方法, 但也可以重写特殊方法
> class Bmw(Car):
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self, car_name, car_colour):
>         self._car_colour = car_colour
>         # 调用 父类方法 | Call parent method
>         super().__int__(car_name)
> 
>     # 定义 getter&setter方法 | Define getter & setter method
>     @property
>     def car_colour(self):
>         return self._car_colour
> 
>     @car_colour.setter
>     def car_colour(self, car_colour):
>         self._car_colour = car_colour
> 
>     def bmv_info(self):
>         print('BMW info=', self._car_name, self._car_colour)
> 
>     # 方法重写 | Method rewrite
>     def car_info(self):
>         print('Car info = BMW')
> 
> 
> # 创建实例 | Create instance
> bmw = Bmw('bmw M6', 'blue')
> 
> # 子类实例 调用方法 | Subclass instance call method
> bmw.car_info()
> bmw.bmv_info()
> ```
> 
> **3. 多重继承**
> 在Python中是支持多重继承, 也就是可以为一个类同时指定多个父类.
> 
> 可以在类名的()括号后边添加多个类来实现多重继承.
> 
> 多重继承会使子类同时拥有多个父类, 并且会获取到所有父类中的方法.
> 
> 在开发中没有特殊的情况, 应该尽量避免使用多重继承, 因为多重继承会让代码过于复杂.
> 
> 如果多个父类中有同名的方法, 则会现在第一个父类中寻找, 然后找第二个, 然后找第三个, 前边父类的方法会覆盖后边父类的方法.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 多重继承 | Multiple inheritance
> # 定义 父类 D | Definition father class D
> class D(object):
>     def cores(self):
>         print('DDD')
> 
> 
> # 定义 子类E | Definition subclass E 
> class E(object):
>     def cores(self):
>         print('EEE')
> 
> 
> # 定义 子类 F 多重继承 D E | Definition Subclass F Multiple inheritance D E
> class F(D, E):
>     def cores(self):
>         print('FFF')
> 
> # 获取当前类的所有父类 | Get all parent classes of the current class
> print('F.__bases__ =', F.__bases__)
> 
> # 创建实例 | Create instance
> f = F()
> 
> # 调用方法 | Calling method
> f.cores()  # OutPut FFF
> ```


####  7.10.4 多态
> 多态是面向对象的三大特征之一, 多态可以理解为对象的多种形态, 一个对象可以以不同的形态呈现.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 面向对象 (多态) | Object-oriented (polymorphic)
> # 定义 类 | Definition class
> class G:
>     def __init(self, infos):
>         self._infos = infos
> 
>     @property
>     def infos(self):
>         return self._infos
> 
>     @infos.setter
>     def infos(self, infos):
>         self._infos = infos
> 
> 
> # 定义 类 | Definition class
> class H:
>     def __init(self, infos):
>         self._infos = infos
> 
>     @property
>     def infos(self):
>         return self._infos
> 
>     @infos.setter
>     def infos(self, infos):
>         self._infos = infos
> 
> 
> # 定义 类 | Definition class
> class J:
>     pass
> 
> 
> # 创建实例 | Create instance
> g = G()
> h = H()
> 
> # 为实例赋值 | Assigning values ​​to instances
> h.infos = 'H'
> g.infos = 'G'
> 
> 
> # 定义 全局函数 | Definition global function
> def info(obj):
>     # 定义 类型检查 | Definition type checking
>     '''
>     该函数只有obj是G类型的对象时才可以正常使用
>     其他类型的对象都无法使用该函数, 这个函数就违反了多态,
>     违反了多态的函数, 只适用于一种类型的对象, 无法处理其他类型对象, 这样导致函数的适应性非常差
>     注意: isinstance()此函数在开发中一般是不会使用
>     :param obj:
>     :return:
>     '''
>     if isinstance(obj, G):
>         print('infos =', obj.infos)
>     else:
>         print("no info!")
> 
> 
> # 调用函数 | call function
> info(g)
>```


####  7.10.5 类中的属性 & 方法
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 类中的属性 & 方法 | Properties & methods in the class
> # 定义 类 | Definition class
> # 类中可以包含: 类属性 / 实例属性 / 类方法 / 实例方法 / 静态方法
> class K(object):
>     # 定义 属性 | Definition attribute
>     '''
>     可以直接在类中定义的属性就称之为类属性
>     类属性可以通过类或实例进行访问
>     但是类属性只能通过类对象进行修改, 无法通过实例对象进行修改
>     '''
>     res_sum = 0
> 
>     # 定义 初始化方法 | Definition initialization method
>     '''
>     通过实例对象添加的属性属于实例属性
>     实例属性只能通过实例对象进行访问和修改, 类对象无法进行访问修改
>     '''
> 
>     def __init__(self):
>         self.infos = 'Info'
> 
>    # 定义 实例方法 | Defining instance methods
>     '''
>     在类中定义以`seIf`为第一个参数的方法称之为实例方法
>     实例方法在调用时Python解析器会将调用对象作为`seIf`传入
>     实例方法可以通过实例和类进行调用
>     当通过实例调用时, 会自动将当前调用对象作为`seIf`传入
>     当通过对象调用时, 不会自动传入`seIf`, 必须需要开发者手动传递`seIf`
>     '''
> 
>     def core_info(self):
>         print('core_info=', self)
> 
>     # 定义 类方法 | Definition class method
>     '''
>     在类内部使用`@classmethod`关键字来修饰类方法
>     类方法中第一个参数为`cls`, `cls`参数也会被自动传递, `cls`就是当前类的对象
>     类方法和实例方法的区别在于: 实例方法第一个参数为`seIf`, 而类方法第一个参数为`cls`
>     类方法可以通过类进行调用, 也可以通过实例进行调用
>     '''
> 
>     @classmethod
>     def core_cls(cls):
>         print('core_cls=', cls, cls.res_sum)
> 
>     # 定义 静态方法 | Definition static method
>     '''
>     在类中使用`@staticmethod`关键字来修饰静态方法
>     静态方法不需要指定任何的默认参数, 静态方法可以通过类和实例进行调用
>     静态方法基本上是和当前类无关的方法, 它只是存储当前类中的函数, 该方法一般在开发中作为工具方法使用
>     '''
> 
>     @staticmethod
>     def core_staticmethod():
>         print('core_staticmethod')
> 
> 
> # 创建实例 | Create instance
> k = K()
> 
> k.res_sum = 1000
> K.res_sum = 10000
> 
> print('k', k.res_sum)
> print('K', K.res_sum)
> 
> k.core_info()
> K.core_info(k)
> 
> k.core_staticmethod()
> K.core_staticmethod()
> ```


####  7.10.6 垃圾回收
> 程序运行过程中产生的垃圾会影响到程序运行性能, 所以这些垃圾必须被及时清理.
> 
> 在程序中没有被引用的对象就称之为垃圾,当垃圾对象过多以后会影响到程序运行性能.
> 
> 所以必须进行及时的垃圾回收, 所谓的垃圾回收就是将垃圾对象从内存中删除.
> 
>Python提供了自动的垃圾回收机制, 无需手动删除, 它会自动将没有被引用的对象删除.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 垃圾回收 | Garbage collection
> # 定义 类 | Definition class
> class U:
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self):
>         self.info = 'U class'
> 
>     # 定义 del特殊方法, 在对象被垃圾回收前调用该方法
>     def __del__(self):
>         print('Delete U class', self)
> 
> 
> # 创建实例 | Create instance
> u = U()
> 
> '''
> 垃圾回收 测试 | 将u实例定义为空, 此时只要没有任何变量对U对象进行引用, 则该实例在> 内存中就变成了垃圾, Python将自动进行垃圾回收
> '''
> a = None
> ```


####  7.10.7 特殊方法
> 特殊方法也称为魔术方法, 特殊方法都是使用`__`双下划线开头和结尾.
> 
> 特殊方法一般不需要开发者手动调用, 需要在一些特殊情况下自动执行.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 特殊方法 | Special method
> # 定义 类 | Definition class
> class Shape:
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self, name, lengths):
>         self.name = name
>         self.lengths = lengths
> 
>     '''
>     `__str__()` 该特殊方法会在尝试将对象转换为字符串时调用
>     该作用是可以用来指定对象转换为字符串的结果
>     '''
> 
>     def __str__(self):
>         return 'Shape [Name= %s , Lengths= %d]' % (self.name, self.lengths)
> 
>     '''
>     `__repr__()` 该特殊方法会在对当前对象使用`repr()`函数时调用
>     该作用是指定对象在`交互模式`中直接输出返回结果
>     '''
> 
>     def __repr__(self):
>         return 'This is the graphics class!'
> 
>     '''
>     其他特殊方法介绍 | Introduction of other special methods
>     
>     `object.__lt__(self, other)` 小于 < 
>     该特殊方法在对象进行小于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     `object.__le__(self, other)` 小于等于 <=
>     该特殊方法在对象进行小于等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     `object.__eq__(self, other)` 等于 ==
>     该特殊方法在对象进行等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     `object.__ne__(self, other)` 不等于 !=
>     该特殊方法在对象进行不等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     
>     `object.__gt__(self, other)` 大于 >
>     该特殊方法在对象进行大于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     
>     `object.__ge__(self, other)` 大于等于 >=
>     该特殊方法在对象进行大于等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     '''
> 
>     def __lt__(self, other):
>         return self.lengths < other.lengths
> 
>     def __le__(self, other):
>         return self.lengths <= other.lengths
> 
>     def __eq__(self, other):
>         return self.lengths == other.lengths
> 
>     def __ne__(self, other):
>         return self.lengths != other.lengths
> 
>     def __gt__(self, other):
>         return self.lengths > other.lengths
> 
>     def __ge__(self, other):
>         return self.lengths >= other.lengths
>     # 可通过bool来指定对象转换为布尔值
>     def __bool__(self):
>         return self.lengths > 150
>         
> # 创建实例 | Create instance
> s1 = Shape('Round', 158)
> s2 = Shape('Rectangle', 412)
> 
> # 当打印对象时实际上打印的是对象的中特殊方法> `__str__()`的返回值
> print('s1=', s1)  # s1= <__main__.Shape object at 0x10b524a60>
> print('s2=', s2)  # s2= <__main__.Shape object at 0x10b524ac0>
> 
> # 小于比较 | Less than comparison
> print('s1 < s2 =', s1 < s2)  # s1 < s2 = True
> print('s2 < s1 =', s2 < s1)  # s2 < s1 = False
> 
> # 小于等于比较 | Less than or equal comparison
> print('s1 <= s2 =', s1 <= s2)  # s1 <= s2 = True
> print('s2 <= s1 =', s2 <= s1)  # s2 <= s1 = False
> 
> # 等于比较 | Equal comparison
> print('s1 == s2 =', s1 == s2)  # s1 == s2 = False
> print('s2 == s1 =', s2 == s1)  # s1 == s2 = False
> 
> # 不等于比较 | Not equal to compare
> print('s1 != s2 =', s1 != s2)  # s1 != s2 = True
> print('s2 != s1 =', s2 != s1)  # s2 != s1 = True
> 
> # 大于比较 | Greater than comparison
> print('s1 > s2 =', s1 > s2)  # s1 > s2= False
> print('s2 > s1 =', s2 > s1)  # s2 > s1= True
> 
> # 大于等于比较 | Greater than or equal
> print('s1 >= s2 =', s1 >= s2)  # s1 >= s2 = False
> print('s2 >= s1 =', s2 >= s1)  # s2 >= s1 = True
> 
> 
> ```


####  7.10.8 模块
> 模块化指将一个完整的程序分解为若干个小的模块.
> 
> 采用模块化将程序分别编写到多个文件中.
> 
> 采用模块化优势：1.方便开发 / 2.方便维护 / 3.模块复用 / 4.解耦合
> 
> 在Python中以`.py`文件就是一个模块, 创建模块实际上就是创建一个python文件.
> 
> 注意：模块名要符号标识符规范.
> 
> **引入外部模块 语法如下:**
> 
> `import 模块名称` 或者 `import 模块名称 as 模块别名`
> 
> 可以引入同一个模块多次, 但是模块实例只会创建一个等同于单实例.
> 
> `import`可以在程序的任意位置调用, 但是一般情况下`import`语句都会统一写在程序的开头或最上方.
> 
> 在每一个模块内部都有`__name__`属性, 通过该属性可以获取模块名称.
> 
> `__name__`属性值为`__main__`的模块是主模块, 一个程序中只会有一个主模块.
> 
> 主模块就是直接通过python执行的模块.
> 
> **引入模块部分内容, 语法如下:**
> 
> `from 模块名称 import 变量1, 变量2....`
> 
> 引入到模块中所有内容, 因会容易出现代码冲突, 一般不会使用.
> 
> 在模块中以单下划线开头的变量只能在模块内部访问, 在通过`import *`引入时，不会引入_开头的变量.
> 
> `from 模块名称 import * `
> 
> **引入变量使用别名, 语法如下:**
> 
> `from 模块名称 import 变量 as 别名`
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 模块 | Module
> # 导入外部模块 (测试模块) | Import external module (test module)
> 
> import module.test_module
> import module.test_module as ts
> 
> print('test_module=', module.test_module)
> print('test_module __name__ =', module.test_module.__name__)
> print('ts=', ts)
> print('ts __name__ =', ts.__name__)
> print(__name__)
> 
> # 导入外部模块 | Import external module
> import module.core_module as cm
> 
> # 调用变量 | Call variable
> print(cm.nums1, cm.nums2)
> 
> # 创建实例 | Create instance
> cm.CoreModule('CoreModule')
> 
> # 调用函数 | call function
> cm.core_module_function()
> 
> # 引入模块部分内容 | Introducing module content
> from module.core_module import CoreModule, core_module_function
> 
> # 创建实例 | Create instance
> cm1 = CoreModule('CoreModule-1')
> 
> # 调用函数 | call function
> core_module_function()
> 
> # 引入变量使用别名 | Introduce variables using aliases
> from module.core_module import core_module_function as cmf
> 
> # 调用函数 | call function
> cmf()
> ```

####  7.10.9 包
> 包也是一个模块, 当模块中代码过多时或者模块需要被分解为多个模块时, 这时就需要使用到包.
> 
> 普通模块只是一个py文件, 而包是一个文件夹.
> 
> 包中必须要一个 `__init__.py` 文件, 该文件中可以包含有包中的主要内容.
> 
> `__pycache__` 是模块缓存文件
> 
> py代码在执行前需要被解析器先转换为机器码然后再执行, 所以在使用模块(包)时, 也需要将模块的代码先转换为机器码然后再交由计算机执行.
> 
> 而为了提高程序运行的性能, python会在编译过一次以后将代码保存到一个缓存文件中.
> 
> 在下次加载这个模块(包)时就可以不再重新编译而是直接加载缓存中编译好的代码即可.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 包 | Package
> # @File : __init__.py.py
> # @Description : Python 基础篇 - 包 | Python Basics-Packages
> 
> # 导入子模块 | Import submodule
> from module.simple_calculation.addition_calculation import addition_calculation_function as acf
> from module.simple_calculation.subtraction_calculation import subtraction_calculation_function as scf
> from module.simple_calculation.multiplication import multiplication_function as mf
> from module.simple_calculation.division_calculation import division_calculation_function as dcf
> 
> # 调用 简易加法函数 | Call simple addition function
> acf(10, 20)
> 
> # 调用 简易减法函数 | Call simple subtraction function
> scf(60, 10)
> 
> # 调用 简易乘法函数 | Call simple multiplication function
> mf(10, 10)
> 
> # 调用 简易除法函数 | Call simple division function
> dcf(81, 9)
> ```



####  7.10.10 Python 标准库
> 为了实现开箱即用的思想, Python中为开发者提供一个模块的标准库.
> 
> [Python Module Index | Python 标准库 docs.python.org/3.8/py-modindex](https://docs.python.org/3.8/py-modindex.html)
> 
> 在该标准库中有诸多很强大的模块供开发者直接使用.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # Python 标准库 | Python Standard Library
> # Global Module Index https://docs.python.org/3.8/py-modindex.html
> # 引入模块 | Introduce module
> '''
> `sys`模块提供一些变量和函数, 使开发者可以获取到Python解析器信息或者通过函数来操作Python解析器
> '''
> import sys
> 
> '''
> `pprint`模块提供了`pprint()`, 该方法可以用来对打印的数据做简单的格式化处理
> '''
> import pprint
> 
> # `sys.argv` 获取执行代码时命令行中所包含的参数
> # 该属性类型为列表, 列表中保存当前命令所有参数
> print(sys.argv)
> 
> # `sys.modules` 获取当前程序中引入的所有模块
> # modules类型为字典, 字典key为模块名称, 字典value为模块对象
> pprint.pprint(sys.modules)
> 
> # `sys.path` 列表中保存的是模块搜索路径
> pprint.pprint(sys.path)
> 
> # `sys.platform` 表示当前Python运行的操作平台
> print(sys.platform)
> 
> # `sys.exit()` 该函数用来退出程序
> # sys.exit('Program Exception, End!')
> 
> # `os模块` 可以让开发者对操作系统进行访问
> import os
> 
> # `os.environ` 通过该属性可以获取系统环境变量
> pprint.pprint(os.environ)
> 
> # `os.system()` 该函数可以在操作系统中执行命令行指令
> 
> # macOS & Linux 操作系统 命令行指令 | macOS & Linux operating system command line instructions
> os.system('ls -al')
> 
> # Windows 操作系统 命令行指令 | Windows operating system command line instructions
> os.system('dir')
> ```


### 7.11 Python 异常处理 & 文件

#### 7.11.1 异常
> 程序在运行过程当中不可避免的会出现一些错误, 这些错误在程序中称其为异常.
> 
> 程序运行过程中, 一旦出现异常将会导致程序立即终止, 异常后的代码将全部无法执行.

##### 7.11.1.1 处理异常
> 程序运行时出现异常目的并不是让程序直接终止, Python是希望在出现异常时开发者可以编写代码来对异常进行处理.
> 
> 处理异常语法: 
> 
> 说明: 可以将可能出现异常的代码放入到try语句, 这样如果代码没有错误则会正常执行,如果出现错误则会执行expect子句中的代码, 这样就可以通过代码来处理异常避免因为一个异常导致整个程序的终止.
> 
> ```
> try:
>         可能出现错误的代码块
>     except 异常类型 as 异常名:
>         处理异常 代码块
>     except 异常类型 as 异常名:
>         处理异常 代码块
>     except 异常类型 as 异常名:
>         处理异常 代码块
>     else：
>         无异常执行的代码块   
>     finally:
>        最终执行代码块
> ```

##### 7.11.1.2 抛出异常
> 当在函数中出现异常时如果在函数中对异常进行处理则异常不会再继续传播,如果函数中没有对异常进行处理则异常会继续向函数调用处传播, 如果函数调用处处理了异常则不再传播, 如果没有处理则继续向调用处传播, 直到传递到全局作用域, 如果依然没有处理则程序终止并且显示异常信息.
> 
> 在Python为开发者提供了多个异常对象: [Built-in Exceptions](https://docs.python.org/3.8/library/exceptions.html)
> 
> 当程序运行过程中出现异常以后, 所有的异常信息会被保存至专门的异常对象中, 而异常传播时, 实际上就是异常对象抛给了调用处.


##### 7.11.1.3 异常对象
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异常处理和文件操作 | Exception Handling and File Operations
> # @File : 12_exception_handling_and_file_operations.py
> # @Description : Python 基础篇 - 异常处理和文件操作 | Python Basics-Exception Handling and File Operations
> 
> print('Before the exception')
> try:
>     print(10 / 0)
> # Exception是所有异常类的父类, 所以如果except后跟的是Exception则会捕获到所有的异常
> except Exception as e:
>     print('Exception Info', e)
> finally:
>     print('无论是否出现异常, 最终该语句都会执行')
> print('After the exception')
> ```

##### 7.11.1.4 自定义异常对象
> 使用`raise`语句来抛出异常, `raise`语句后需要跟一个异常类或异常实例.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异常处理和文件操作 | Exception Handling and File Operations
> # @File : 12_exception_handling_and_file_operations.py
> # @Description : Python 基础篇 - 异常处理和文件操作 | Python Basics-Exception Handling and File Operations
> 
> # 定义 类 | Definition class
> class ExceptionClass(Exception):
> 
>     # 定义 加法函数 | Definition Addition function
>     def additions(self, num1, num2):
>         if num1 < 0 or num2 < 0:
>             raise ExceptionClass('Custom exception information')
>         res1 = num1 + num2
>         return res1
> 
> 
> if __name__ == '__main__':
>     # 创建实例 | Create instance
>     ec = ExceptionClass()
> 
>     # 调用函数 | call function
>     res2 = ec.additions(1, -1)
>     print(res2)
> ```

#### 7.11.2 文件I/O
> 通过Python程序来对计算机中各种文件进行增删改查操作.
> 
> [Built-in Functions](https://docs.python.org/3.8/library/functions.html) / [Global Module Index](https://docs.python.org/3.8/py-modindex.html)
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异常处理和文件操作 | Exception Handling and File Operations
> # @File : 12_exception_handling_and_file_operations.py
> # @Description : Python 基础篇 - 异常处理和文件操作 | Python Basics-Exception Handling and File Operations
> 
> # 文件 I/O | File I/O
> # 打开文件流 | Open file stream
> FILE_PATH = '../resources/row_file/part_metadata_user.txt'
> FILE_PATHS = '../resources/row_file/demo.jpg'
> # row_data = open(FILE_PATH, encoding='UTF-8')
> 
> # 读取文件流 | Read file stream
> # contents = row_data.read()
> # print('contents=', contents)
> 
> # 关闭文件流 | Close file stream
> # row_data.close()
> 
> # 使用 `with ... as ...` 语法 读取文件
> try:
>     with open(FILE_PATH, encoding='UTF-8') as row_data:
>         contents = row_data.read()
>         print('contents=', contents)
> except Exception as error:
>     print('Error info:', error)
> 
> # 自定义读取文件大小 | Custom read file size
> try:
>     with open(FILE_PATH, encoding='UTF-8') as row_data:
>         row_content = ''
>         SIZE = 328
>         while True:
>             content = row_data.read(SIZE)
>             if not content:
>                 print('Read finished\n')
>                 break
>             row_content += content
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('row_content=', row_content)
> 
> # 读取文件行内容 | Read file line content
> try:
>     with open(FILE_PATH, encoding='UTF-8') as row_data:
>         readline_content = row_data.readline()
>         readlines_content = row_data.readlines()
>         for x in row_data:
>             print('content=', x)
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('readline_content=', readline_content)
>     print('readlines_content=', readlines_content[1])
> 
> # 写入文件 | Write to file
> '''
> 'r'     open for reading (default)
> 'w'    open for writing, truncating the file first
> 'x'     open for exclusive creation, failing if the file already exists
> 'a'     open for writing, appending to the end of the file if it exists
> 'b'     binary mode
> 't'     text mode (default)
> '+'     open for updating (reading and writing)
> 
> 写入文件 参数 `r` : 表示当前文件为只读模式
> 写入文件 参数 `+` : 操作符添加功能
> 写入文件 参数 `w` : 表示写入内容时, 将覆盖当前所有文件内容, 如文件不存在, 则> 将创建文件并写入内容至文件中
> 写入文件 参数 `a` : 表示写入内容时, 将追加到当前文件中, 如文件不存在, 则将创> 建文件并写入内容至文件中
> '''
> try:
>     with open(FILE_PATH, 'a') as row_data:
>         # row_data.write('Write to file')
>         print(row_data)
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('row_data=', row_data)
> 
> # 读取 二进制文件 | Read binary file
> '''
> 'b'     binary mode
> 't'     text mode (default)
> '''
> try:
>     with open(FILE_PATHS, 'rb') as row_datas:
>         # byte_size = 100
>         # r = row_datas.read(byte_size)
>         # print('Binary File=', r)
>         # 写入 二进制文件 | Write binary file
>         NEW_FILE_PATH = '../resources/row_file/binary_data.jpg'
>         with open(NEW_FILE_PATH, 'wb') as new_binary_data:
>             byte_size = 1024 * 100
>             new_data = ''
>             while True:
>                 row_res = row_datas.read(byte_size)
>                 if not row_res:
>                     print('Read finished\n')
>                     break
>                 new_binary_data.write(row_res)
>                 new_data += new_binary_data
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('new_data=', new_data)
> 
> # 修改 & 查询 读取位置 | Modify & Inquire Read Location
> try:
>     with open(FILE_PATH, 'rb') as row_data:
>         SIZE = 328
>         '''
>         seek方法 参数说明
>         参数 一: 切换读取位置
>         参数 二: 计算位置方式 默认值0 从首部计算, 1 从当前位置计算 , 2 从末尾位置开始计算
>         '''
>         seek_data = row_data.seek(328)
>         tell_data = row_data.tell()
>         print('Read position -->', tell_data)
>         print(row_data.read(SIZE))
> except Exception as error:
>     print('Error info:', error)
> 
> # 文件其他操作 | File other operations
> # `os模块` 可以让开发者对操作系统进行访问
> import os
> from pprint import pprint
> 
> # 创建目录 | Create a directory
> mk = os.mkdir('../resources/row_file/test_dir')
> 
> # 删除目录 | Delete directory
> # rm = os.rmdir('../resources/row_file/test_dir')
> 
> # 查看当前或指定文件列表 | View a list of current or specified files
> dir = os.listdir('.')
> pprint(dir)
> 
> # 切换目录 | Change directory
> cd_dir = os.chdir('..')
> pprint(cd_dir)
> 
> # 查看当前文件目录 | View the current file directory
> pwd = os.getcwd()
> pprint(pwd)
> 
> # 文件重命名和移动文件 | File renaming And moving files
> # os.rename('xxx', 'yyy')
> 
> # 删除文件 | Delete Files
> os.remove(NEW_FILE_PATH)
> ```

## 💥 8. Python 高级篇💥
### 8.1 Python 正则表达式
> 正则表达式是一个特殊的字符序列, 它能帮助开发者方便检查一个字符串是否与某种模式匹配.
> 
> `re模块`使Python语言拥有全部的正则表达式功能.
> 
> `compile函数`根据一个模式字符串和可选的标志参数生成一个正则表达式对象, 该对象拥有一系列方法用于正则表达式匹配和替换.
> 
> `re模块`也提供了与这些方法功能完全一致的函数, 这些函数使用一个模式字符串做为它们的第一个参数.
> 
> **1. match function**
> 
> `re.match`尝试从字符串的起始位置匹配一个模式, 如果不是起始位置匹配成功的话, match()就返回none.
> 
> 函数语法: `re.match(pattern, string, flags=0)`
> 
> 函数参数说明 : 
> 
> | 参数      |     描述 |
> | :--------: | :--------:|
> | `pattern`    |   匹配的正则表达式 |
> | `string`    |   要匹配的字符串 |
> | `flags`    |   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 |
> 
> 匹配成功re.match方法返回一个匹配的对象, 否则返回None
> 
> 还可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式.
> 
> | 匹配对象方法      |     描述 |
> | :--------: | :--------:|
> | `group(num=0)`    |   匹配的整个表达式的字符串, group()可以一次输入多个组号, 在这种情况下它将返回一个包含那些组所对应值的元组 |
> | `groups()`    |   返回一个包含所有小组字符串的元组, 从1到 所含的小组号 |
> 
>**2. search method**
>
> `re.search`扫描整个字符串并返回第一个成功的匹配.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 正则表达式 | Regular expression
> # @File : 13_regular_expression.py
> # @Description : Python 进阶篇 - 正则表达式 | Python Advanced articles - Regular Expressions
> 
> # 导入模块 | Import module
> import re
> 
> # match函数 | match function
> '''
> `match`尝试从字符串的起始位置匹配一个模式
> 如果不是起始位置匹配成功的话, match()就返回None
> 函数 语法: `re.match(pattern, string, flags=0)`
> '''
> 
> 
> # 定义 函数 | Definition function
> def fun1():
>     # 在起始位置匹配 | Match at starting position
>     r1 = re.match('www', 'www.geekparkhub.com').span()
>     print(r1)
>     # 不在起始位置匹配 | Do not match at the beginning
>     r2 = re.match('com', 'www.geekparkhub.com')
>     print(r2)
> 
> 
> # 定义常量 | Defining constants
> data1 = 'Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.'
> 
> 
> # 定义 函数 | Definition function
> def fun2(values):
>     r3 = re.match(r'(.*?) .*? Open (.*) .*', values, re.M | re.I)
>     if r3:
>         print('r3.group()=', r3.group())
>         print('r3.group(1)=', r3.group(1))
>         print('r3.group(2)=', r3.group(2))
>     else:
>         print('Match failed!')
> 
> 
> # search 方法 | search method
> '''
> `re.search` 扫描整个字符串并返回第一个成功的匹配
> 函数语法: `re.search(pattern, string, flags=0)`
> '''
> 
> 
> # 定义 函数 | Definition function
> def fun3():
>     # 在起始位置匹配 | Match at starting position
>     r1 = re.search('www', 'www.geekparkhub.com').span()
>     print(r1)
>     # 不在起始位置匹配 | Do not match at the beginning
>     r2 = re.search('com', 'www.geekparkhub.com').span()
>     print(r2)
> 
> 
> # 定义 函数 | Definition function
> def fun4(values):
>     r4 = re.search(r'(.*?) .*? Open (.*) .*', values, re.M | re.I)
>     if r4:
>         print('r4.group()=', r4.group())
>         print('r4.group(1)=', r4.group(1))
>         print('r4.group(2)=', r4.group(2))
>     else:
>         print('Match failed!')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     fun1()
>     fun2(data1)
>     fun3()
>     fun4(data1)
> ```
> 
> **re.match与re.search的区别**
> re.match只匹配字符串的开始, 如果字符串开始不符合正则表达式, 则匹配失败, 函数返回None, 而re.search匹配整个字符串直到找到一个匹配.
> 
> **3. 检索和替换**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 正则表达式 | Regular expression
> # @File : 13_regular_expression.py
> # @Description : Python 进阶篇 - 正则表达式 | Python Advanced articles - Regular Expressions
> 
> # 导入模块 | Import module
> import re
> 
> # 检索和替换 | Retrieve and replace
> '''
> sub用于替换字符串中的匹配项
> 语法: `re.sub(pattern, repl, string, count=0, flags=0)`
> 参数: pattern : 正则中的模式字符串
>         repl : 替换的字符串, 也可为一个函数
>         string : 要被查找替换的原始字符串
>         count : 模式匹配后替换的最大次数, 默认 0 表示替换所有的匹配
> '''
> # 定义常量 | Defining constants
> data2 = '123-456-789 # 替换字符串中的匹配项'
> 
> 
> # 定义 函数 | Definition function
> def fun5(values):
>     # 删除`Python注释`字符串
>     r5 = re.sub(r'#.*$', "", values)
>     # 删除`-`字符串
>     r6 = re.sub(r'\D', "", values)
>     print('r5=', r5)
>     print('r6=', r6)
> 
> 
> '''
> repl 函数
> 将字符串中的匹配的数字乘11
> '''
> # 定义常量 | Defining constants
> data3 = 'P45G3GKFC755'
> 
> 
> # 定义 函数 | Definition function
> def fun6(matched):
>    r7 = int(matched.group('value'))
>     return str(r7 * 11)
> 
> 
> r8 = re.sub('(?P<value>\d+)', fun6, data3)
> print('r8=', r8)
> 
> # compile 函数 | compile function
> '''
> `compile`函数用于编译正则表达式, 生成一个正则表达式(Pattern)对象供> `match()`&`search()`这两个函数使用
> 函数语法: `re.compile(pattern[, flags])`
> 参数说明: `pattern` 一个字符串形式的正则表达式
>               `flags`可选项, 表示匹配模式, 比如忽略大小写, 多行模式等, 具体参数为：
>                     1. `re.I 忽略大小写` 2. `re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境`
>                     3. `re.M 多行模式` 4. `re.S 即为 . 并且包括换行符在内的任意字符 (. 不包括换行符)`
>                     5. `re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库`
>                     6. `re.X 为了增加可读性, 忽略空格和 # 后面的注释`
> '''
> # 定义常量 | Defining constants
> data4 = 'one12twothree34four'
> data5 = 'Hello Python'
> 
> 
> # 定义 函数 | Definition function
> def fun7(values):
>     r9 = re.compile(r'\d+')  # 用于匹配至少一个数字
>     r10 = r9.match(values, 3, 10)  # 从'1'的位置开始匹配
>     r11 = r10.group(0)
>     r12 = r10.start(0)
>     r13 = r10.end(0)
>     r14 = r10.span(0)
>     print('r10=', r10)
>     print('group=', r11)
>     print('start=', r12)
>     print('end=', r13)
>     print('span=', r14)
> 
> 
> # 定义 函数 | Definition function
> def fun8(values):
>     r15 = re.compile(r'([a-z]+) ([a-z]+)', re.I)  # `re.I`表示忽略大小写
>     r16 = r15.match(values)
>     r17 = r16.group(0)  # 返回匹配成功的整个子串
>     r18 = r16.group(1)  # 返回第一个分组匹配成功的子串
>     r19 = r16.group(2)  # 返回第二个分组匹配成功的子串
>     r20 = r16.span(1)  # 返回第一个分组匹配成功的子串的索引
>     r21 = r16.span(2)  # 返回第二个分组匹配成功的子串
>     r22 = r16.groups(1)  # 等价于 r16.group(1), r16.group(2), ...)
>     print('r16=', r16)
>     print('r17=', r17)
>     print('r18=', r18)
>     print('r19=', r19)
>     print('r20=', r20)
>     print('r20=', r20)
>     print('r21=', r21)
>     print('r22=', r22)
> 
> 
> # findall & finditer & split
> '''
> `findall` 在字符串中找到正则表达式所匹配的所有子串并返回一个列表, 如果没有找到匹配的则返回空列表
> 注意: `match` & `search` 是匹配一次, 而`findall`匹配所有
> 语法: `findall(string[, pos[, endpos]])`
> 参数说明: 
>             `string` 待匹配的字符串
>             `pos` 可选参数, 指定字符串的起始位置, 默认为0
>             `endpos` 可选参数指定字符串的结束位置, 默认为字符串的长度
>             
>=================================================================================
> 
> `finditer` 和 `findall` 类似, 在字符串中找到正则表达式所匹配的所有子串并把它们作为一个迭代器返回.
> 语法: `re.finditer(pattern, string, flags=0)`
> 参数说明: 
>             `pattern` 匹配的正则表达式
>             `string` 要匹配的字符串
>             `flags` 标志位用于控制正则表达式的匹配方式, 如是否区分大小写, 多行匹配等等
>             
> =================================================================================
> 
> `split` 方法按照能够匹配的子串将字符串分割后返回列表
> 语法: `re.split(pattern, string[, maxsplit=0, flags=0])`
> 参数说明: 
>             `pattern` 匹配的正则表达式
>             `string` 要匹配的字符串
>             `maxsplit` 分隔次数, `maxsplit=1`分隔一次, 默认为0, 不限制次数
>             `flags` 标志位用于控制正则表达式的匹配方式, 如是否区分大小写, 多行匹配等等
> '''
> # 查找字符串中所有数字
> # 定义常量 | Defining constants
> data6 = 'd4qw564df56qw456qw4f56q465df4qwef'
> 
> 
> # 定义 函数 | Definition function
> def fun9(values):
>     r23 = re.compile(r'\d+')  # 检索数字
>     r24 = r23.findall(values, 0, 33)
>     print('r24=', r24)
>     r25 = re.finditer(r'\d+', values)
>     for x in r25:
>         print('r25=', x.group())
> 
> 
> # 定义常量 | Defining constants
> data7 = 'Java, C, GoLang, Python'
> 
> 
> # 定义 函数 | Definition function
> def fun10(values):
>     r26 = re.split('(\W+)', values, 1)
>     print('r26=', r26)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     fun4(data1)
>     fun5(data2)
>     fun7(data4)
>     fun8(data5)
>     fun9(data6)
>     fun10(data7)
> ```
> **4. 正则表达式修饰符 - 可选标志**
> 
> 正则表达式可以包含一些可选标志修饰符来控制匹配的模式, 修饰符被指定为一个可选的标志, 多个标志可以通过按位 OR(|) 它们来指定, 如 re.I | re.M 被设置成 I 和 M 标志.
> 
> | 修饰符      |     	描述 |
> | :--------: | :--------:|
> | `re.I`    |   使匹配对大小写不敏感 |
> | `re.L`    |   做本地化识别 (locale-aware)匹配 |
> | `re.M`    |   多行匹配, 影响 ^ 和 $ |
> | `re.S`    |   使 . 匹配包括换行在内的所有字符 |
> | `re.U`    |   根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. |
> | `re.X`    |   该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 |
> 
> **4. 正则表达式模式**
> - 模式字符串使用特殊的语法来表示一个正则表达式：
> - 字母和数字表示他们自身, 一个正则表达式模式中的字母和数字匹配同样的字符串.
> - 多数字母和数字前加一个反斜杠时会拥有不同的含义.
> - 标点符号只有被转义时才匹配自身, 否则它们表示特殊的含义.
> - 反斜杠本身需要使用反斜杠转义.
> - 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 '\\t')匹配相应的特殊字符.
> - 下表列出了正则表达式模式语法中的特殊元素, 如果使用模式的同时提供了可选的标志参数, 某些模式元素的含义会改变.
> - 贪婪匹配:   默认向更多次数匹配  (底层用的是回溯算法)
> - 非贪婪匹配: 默认向更少次数匹配 (量词的后面加?号), (1)量词( * ? + {} )加上问号？表示非贪婪 惰性匹配, (2)例:.*?w 表示匹配任意长度任意字符遇到一个w就立即停止.
> 
> | 模式      |     	描述 |
> | :--------: | :--------:|
> | `^`    |   匹配字符串的开头 |
> | `$`    |   匹配字符串的末尾 |
> | `.`    |   匹配任意字符, 除了换行符, 当`re.DOTALL`标记被指定时, 则可以匹配包括换行符的任意字符 |
> | `[...]`    |   用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k' |
> | `[^...]`    |   不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符 |
> | `re*`    |  匹配0个或多个的表达式 |
> | `re+`    |   匹配1个或多个的表达式 |
> | `re?`    |   匹配0个或1个由前面的正则表达式定义的片段, 非贪婪方式 |
> | `re{ n}`    |   精确匹配n个前面表达式, 例如o{2}不能匹配"Bob"中的"o", 但是能匹配"food"中的两个o |
> | `re{ n,}`    |   匹配 n 个前面表达式, 例如o{2,}不能匹配"Bob"中的"o", 但能匹配 ="foooood"中的所有o, "o{1,}"等价于 "o+", "o{0,}"则等价于"o*" |
> | `re{ n, m}`    |   匹配 n 到 m 次由前面的正则表达式定义的片段, 贪婪方式 |
> | `a 或运算符 b`    |   	匹配a或b |
> | `(re)`    |   对正则表达式分组并记住匹配的文本 |
> | `(?imx)`    |   正则表达式包含三种可选标志：i, m, 或 x, 只影响括号中的区域 |
> | `(?-imx)`   |   正则表达式关闭 i, m, 或 x 可选标志, 只影响括号中的区域 |
> | `(?: re)`   |   类似 (...), 但是不表示一个组 |
> | `(?imx: re)`   |   在括号中使用i, m, 或 x 可选标志 |
> | `(?-imx: re)`   |   在括号中不使用i, m, 或 x 可选标志 |
> | `(?#...)`   |   注释 |
> | `(?= re)`   |   前向肯定界定符, 如果所含正则表达式以 ... 表示, 在当前位置成功匹配时成功否则失败, 但一旦所含表达式已经尝试, 匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边 |
> | `(?! re)`   |   前向否定界定符, 与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 |
> | `(?> re)`   |   匹配的独立模式, 省去回溯 |
> | `\w`   |   匹配字母数字及下划线 |
> | `\W`   |   匹配非字母数字及下划线 |
> | `\s`   |  匹配任意空白字符, 等价于 [\t\n\r\f] |
> | `\S`   |   匹配任意非空字符 |
> | `\d`   |   匹配任意数字, 等价于 [0-9] |
> | `\D`   |   匹配任意非数字 |
> | `\A`   |   匹配字符串开始 |
> | `\Z`   |  匹配字符串结束, 如果是存在换行, 只匹配到换行前的结束字符串 |
> | `\z`   |   匹配字符串结束 |
> | `\G`   |   匹配最后匹配完成的位置 |
> | `\b`   |   匹配一个单词边界, 也就是指单词和空格间的位置, 例如 'er\b' 可以匹配"never" 中的 'er', 但不能匹配 "verb" 中的 'er' |
> | `\B`   |   匹配非单词边界, 'er\B' 能匹配 "verb" 中的 'er', 但不能匹配 "never" 中的 'er' |
> | `\n, \t, 等`   |   匹配一个换行符, 匹配一个制表符等等 |
> | `\1...\9`   |   匹配第n个分组的内容 |
> | `\10`   |   匹配第n个分组的内容, 如果它经匹配, 否则指的是八进制字符码的表达式 |
> 
> **5. 正则表达式实例**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 正则表达式 | Regular expression
> # @File : 13_regular_expression.py
> # @Description : Python 进阶篇 - 正则表达式 | Python Advanced articles - Regular Expressions
> 
> # 正则表达式实例 | Regular expression example
> # 匹配 字符类 | Match character class
> '''
> 匹配 "Python" 或 "python" | Matches "Python" or "python"
> '''
> # 定义常量 | Defining constants
> data9 = 'Python'
> r29 = re.match(r'[Pp]', data9, re.M | re.I).group()
> print('r29=', r29)
> 
> '''
> 匹配 "ruby" 或 "rube" | Matches "ruby" or "rube"
> '''
> # 定义常量 | Defining constants
> data10 = 'rube'
> r30 = re.match(r'rub[ye]', data10, re.M | re.I).group()
> print('r30=', r30)
> 
> '''
> 匹配中括号内的任意一个字母 | Matches any letter in brackets
> '''
> # 定义常量 | Defining constants
> data11 = 'dswdwdwletters'
> r31 = re.search(r'[letter]', data11, re.M | re.I).group()
> print('r31=', r31)
> 
> '''
> 匹配任何数字, 类似 [0123456789] | Matches any number, like [0123456789]
> '''
> # 定义常量 | Defining constants
> data12 = '56468547564897748'
> r32 = re.search(r'[0-9]', data12, re.M | re.I).group()
> print('r32=', r32)
> 
> '''
> 匹配任何小写字母 | Matches any lowercase letter
> '''
> # 定义常量 | Defining constants
> data13 = 'Python'
> r33 = re.search(r'([a-z])', data13, re.M).group()
> print('r33=', r33)
> 
> '''
> 匹配任何大写字母 | Match any capital letter
> '''
> # 定义常量 | Defining constants
> data14 = 'Ai'
> r34 = re.search(r'([A-Z])', data14, re.M).group()
> print('r34=', r34)
> 
> '''
> 匹配任何字母及数字 | Match any letter and number
> '''
> # 定义常量 | Defining constants
> data15 = 'fe45dwq4'
> r35 = re.search(r'([a-zA-Z0-9])', data15, re.M | re.I).group()
> print('r35=', r35)
> 
> '''
> 除了index字母以外的所有字符 | All characters except the index letter
> '''
> # 定义常量 | Defining constants
> data16 = '4564d4d4wq847d4dqfefindex'
> r36 = re.finditer(r'[^index]', data16)
> for x in r36:
>     print('r36=', x.group())
> 
> '''
> 匹配除了数字外的字符 | Matches characters other than numbers
> '''
> # 定义常量 | Defining constants
> data17 = 'sfe4d55w74f4ef45wf4f45w6f4ew5f5w'
> r37 = re.findall(r'[^0-9]', data17)
> for x in r37:
>     print('r37=', x)
> 
> # 匹配 特殊字符类 | Match special character class
> '''
> 匹配除 "\n" 之外的任何单个字符, 要匹配包括 '\n'在内的任何字符, 请使用类似 '[.\n]' 模式
> '''
> # 定义常量 | Defining constants
> data18 = 'Hello\nWorld!'
> r38 = re.search(r'[^.\n]', data18, re.M | re.I).group()
> print('r38=', r38)
> 
> '''
> 匹配一个数字字符, 等价于 [0-9] | Matches a numeric character, equivalent to [0-9]
> '''
> # 定义常量 | Defining constants
> data19 = '78448522144455487'
> r39 = re.match(r'\d', data19).group()
> print('r39=', r39)
> 
> '''
> 匹配一个非数字字符。等价于 [^0-9] " | Matches a non-numeric character. Equivalent to [^ 0-9]
> '''
> # 定义常量 | Defining constants
> data20 = 'das78df448few5f2214wefe4455487fewfewf'
> r40 = re.match(r'\D', data20).group()
> print('r40=', r40)
> 
> '''
> 匹配任何空白字符, 包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]
> '''
> # 定义常量 | Defining constants
> data21 = 'vefewr\fefew\nkkkfj\rdwdw\t4474\vsqsq'
> r41 = re.search(r'\s', data21, re.U | re.I).group()
> print('r41=', r41)
> 
> '''
> 匹配任何非空白字符, 等价于 [^ \f\n\r\t\v] | Matches any non-whitespace character, equivalent to [^ \ f \ n \ r \ t \ v]
> '''
> # 定义常量 | Defining constants
> data22 = 'vefewr\fefew\nkkkfj\rdwdw\t4474\vsqsq'
> r42 = re.search(r'\S', data22, re.M | re.I).group()
> print('r42=', r42)
> 
> '''
> 匹配包括下划线的任何单词字符, 等价于'[A-Za-z0-9_]' | Matches any word character including underscore, equivalent to '[A-Za-z0-9_]'
'''
> # 定义常量 | Defining constants
> data23 = 'qsq454_qsq44dqw475d'
> r43 = re.search(r'\w', data23, re.M | re.I).group()
> print('r43=', r43)
> 
> '''
> 匹配任何非单词字符, 等价于 '[^A-Za-z0-9_]' | Matches any non-word character, equivalent to '[^ A-Za-z0-9_]'
> '''
> # 定义常量 | Defining constants
> data24 = 'qsq45_4qsq\t44dqw4_75d'
> r44 = re.search(r'[\W]', data24, re.M | re.I).group()
> print('r44=', r44)
> ```



### 8.2 Python Web开发
#### 8.2.1 前言
> 
> 最早的软件都是运行在大型机上的软件使用者通过“哑终端”登陆到大型机上去运行软件, 后来随着PC机的兴起, 软件开始主要运行在桌面上, 而数据库这样的软件运行在服务器端, 这种`Client / Server`模式简称`CS架构`.
> 
> 随着互联网的兴起, 人们发现CS架构不适合Web, 最大的原因是Web应用程序的修改和升级非常迅速, 而CS架构需要每个客户端逐个升级桌面App, 因此`Browser / Server`模式开始流行, 简称`BS架构`.
> 
> 在BS架构下客户端只需要浏览器, 应用程序的逻辑和数据都存储在服务器端, 浏览器只需要请求服务器获取Web页面, 并把Web页面展示给用户即可.
> 
> 当然Web页面也具有极强的交互性, 由于Web页面是用HTML编写, 而HTML具备超强的表现力, 并且服务器端升级后, 客户端无需任何部署就可以使用到新的版本, 因此BS架构迅速流行起来.
> 
> 如今除了重量级的软件如Office、Photoshop等, 大部分软件都以Web形式提供。比如新浪提供的新闻、博客、微博等服务均是Web应用.
> 
> **1. Web开发 发展演变**
> - 1.`静态WebPage`: 由文本编辑器直接编辑并生成静态的HTML页面, 如果要修改Web页面内容, 就需要再次编辑HTML源文件, 早期的互联网Web就是静态页面.
> - 2.`CGI编程`: 由于静态Web页面无法与用户交互, 比如用户填写了一个注册表单, 静态Web页面就无法处理, 要处理用户发送的动态数据, 出现了Common Gateway Interface, 简称CGI, 用C/C++编写.
> - 3.`ASP/JSP/PHP`: 由于Web应用特点是修改频繁, 用C/C++这样的低级语言非常不适合Web开发, 而脚本语言由于开发效率高, 与HTML结合紧密, 因此迅速取代了CGI模式, ASP是微软推出的用VBScript脚本编程的Web开发技术, 而JSP用Java来编写脚本, PHP本身则是开源的脚本语言.
> - 4.`MVC`: 为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题, Web应用也引入了`Model-View-Controller`的模式来简化Web开发, ASP发展为ASP.Net, JSP和PHP也有一大堆MVC框架.
> 
> 目前Web开发技术仍在快速发展中, 异步开发、新的MVVM前端技术层出不穷.
> 
> Python的诞生历史比Web还要早, 由于Python是一种解释型的脚本语言, 开发效率高, 所以非常适合用来做Web开发.
> 
> Python有上百种Web开发框架, 有很多成熟的模板技术, 选择Python开发Web应用, 不但开发效率高而且运行速度快.

#### 8.2.2 HTTP协议 简介
> 在Web应用中服务器把网页传给浏览器, 实际上就是把网页的HTML代码发送给浏览器, 让浏览器显示出来, 而浏览器和服务器之间的传输协议是HTTP, 所以HTML是一种用来定义网页的文本, 学会HTML就可以编写网页, HTTP是在网络上传输HTML的协议, 用于浏览器和服务器的通信.
> 
> 在地址栏输入`www.sina.com.cn`时浏览器将显示新浪首页, 就可以看到浏览器发给新浪服务器的请求：
> 
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/950413532592512)
> 
> `GET / HTTP/1.1` 含义
> `GET`表示一个读取请求, 将从服务器获得网页数据, `/`表示URL的路径, URL总是以`/`开头, `/`就表示首页, 最后的`HTTP/1.1`指示采用的HTTP协议版本是1.1, 目前HTTP协议的版本就是1.1, 但是大部分服务器也支持1.0版本, 主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接以加快传输速度.
> 
> `Host: www.sina.com.cn`含义
> 表示请求的域名是`www.sina.com.cn`, 如果一台服务器有多个网站, 服务器就需要通过Host来区分浏览器请求的是哪个网站.
> 
> HTTP响应分为Header和Body两部分(Body是可选项), 在Network中看到的Header最重要的几行如下:
> 
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/950413553562752)
> 
> `200 OK`含义
> `200`表示一个成功的响应, 后面的OK是说明, 失败的响应有404 Not Found：网页不存在, 500 Internal Server Error：服务器内部出错等等.
> 
> `Content-Type: text/html`含义
> `Content-Type`指示响应的内容, 这里是text/html表示HTML网页, 请注意浏览器就是依靠Content-Type来判断响应的内容是网页还是图片, 是视频还是音乐, 浏览器并不靠URL来判断响应的内容, 所以即使URL是`http://example.com/abc.jpg`, 它也不一定就是图片.
> 
> **HTTP请求**
> - 1.浏览器首先向服务器发送HTTP请求, 请求包括方法：GET还是POST, GET仅请求资源, POST会附带用户数据, 路径：/full/url/path, 域名：由Host头指定：Host: www.xxx.com, 以及其他相关的Header, 如果是POST，那么请求还包括一个Body, 包含用户数据.
> - 2.服务器向浏览器返回HTTP响应, 响应包括, 响应代码：200表示成功, 3xx表示重定向, 4xx表示客户端发送的请求有错误, 5xx表示服务器端处理时发生了错误, 响应类型：由Content-Type指定, 例如：`Content-Type: text/html;charset=utf-8`表示响应类型是HTML文本, 且编码是UTF-8, `Content-Type: image/jpeg`表示响应类型是JPEG格式的图片, 以及其他相关的Header, 通常服务器的HTTP响应会携带内容, 也就是有一个Body, 包含响应的内容, 网页的HTML源码就在Body中.
> - 3.如果浏览器还需要继续向服务器请求其他资源比如图片就再次发出HTTP请求, 重复步骤1、2, Web采用的HTTP协议采用了非常简单的请求-响应模式, 从而大大简化了开发, 当在编写一个页面时只需要在HTTP响应中把HTML发送出去, 不需要考虑如何附带图片、视频等, 浏览器如果需要请求图片和视频, 它会发送另一个HTTP请求, 因此一个HTTP请求只处理一个资源.
> 
> **HTTP格式**
> 每个HTTP请求和响应都遵循相同的格式, 一个HTTP包含Header和Body两部分, 其中Body是可选.
> HTTP协议是一种文本协议, 所以它的格式也非常简单, HTTP GET请求的格式:
> ```
> GET /path HTTP/1.1
> Header1: Value1
> Header2: Value2
> Header3: Value3
> ```
> 每个Header一行一个, 换行符是`\r\n`.
> 
> - HTTP POST请求的格式:
>  
> ```
> POST /path HTTP/1.1
> Header1: Value1
> Header2: Value2
> Header3: Value3
>  
> body data goes here...
> ```
> 当遇到连续两个`\r\n`时, Header部分结束, 后面的数据全部是Body.
> 
> - HTTP响应的格式:
> 
> ```
> 200 OK
> Header1: Value1
> Header2: Value2
> Header3: Value3
> 
> body data goes here...
> ```
> 
> HTTP响应如果包含body也是通过`\r\n\r\n`来分隔的, 请再次注意Body的数据类型由Content-Type头来确定, 如果是网页, Body就是文本, 如果是图片, Body就是图片的二进制数据.
> 
> 当存在Content-Encoding时, Body数据是被压缩的, 最常见的压缩方式是gzip, 所以看到Content-Encoding: gzip时, 需要将Body数据先解压缩才能得到真正的数据, 压缩的目的在于减少Body的大小加快网络传输.

#### 8.2.3 HTML 简介
> 网页中不但包含文字, 还有图片、视频、Flash小游戏, 有复杂的排版、动画效果, 所以HTML定义了一套语法规则, 来告诉浏览器如何把一个丰富多彩的页面显示出来.
> 
> 可以用文本编辑器编写HTML, 然后保存为hello.html, 双击或者把文件拖到浏览器中, 就可以看到效果:
> 
> ``` html
> <html>
> <head>
>   <title>Hello</title>
> </head>
> <body>
>   <h1>Hello, world!</h1>
> </body>
> </html>
> ```
> 
> HTML文档就是一系列的Tag组成, 最外层的Tag是`<html>`, 规范的HTML也包含`<head>...</head>`和`<body>...</body>`(注意不要和HTTP的Header、Body搞混了), 由于HTML是富文档模型, 所以还有一系列的Tag用来表示链接、图片、表格、表单等等.
> 
> **CSS 简介**
> 
> CSS是Cascading Style Sheets(层叠样式表)的简称, CSS用来控制HTML里所有元素如何展现, 比如给标题元素`<h1>`加一个样式, 变成48号字体, 灰色, 带阴影等.
> 
> ``` html
> <html>
> <head>
>   <title>Hello</title>
>   <style>
>     h1 {
>       color: #333333;
>       font-size: 48px;
>       text-shadow: 3px 3px 3px #666666;
>     }
>   </style>
> </head>
> <body>
>   <h1>Hello, world!</h1>
> </body>
> </html>
> ```
> 
> **JavaScript 简介**
> 
> JavaScript虽然名称有个Java, 但它和Java真的一点关系没有, JavaScript是为了让HTML具有交互性而作为脚本语言添加的, JavaScript既可以内嵌到HTML中, 也可以从外部链接到HTML中, 如果希望当用户点击标题时把标题变成红色, 就必须通过JavaScript来实现.
> ``` html
> <html>
> <head>
>   <title>Hello</title>
>   <style>
>     h1 {
>       color: #333333;
>       font-size: 48px;
>       text-shadow: 3px 3px 3px #666666;
>     }
>   </style>
>   <script>
>     function change() {
>       document.getElementsByTagName('h1')[0].style.color = '#ff0000';
>     }
>   </script>
> </head>
> <body>
>   <h1 onclick="change()">Hello, world!</h1>
> </body>
> </html>
> ```
> 
> 如果要学习Web开发, 首先要对HTML、CSS和JavaScript作一定的了解, HTML定义了页面的内容, CSS来控制页面元素的样式, 而JavaScript负责页面的交互逻辑.
> 
> 讲解HTML、CSS和JavaScript就可以写3本书, 对于优秀的Web开发人员来说, 精通HTML、CSS和JavaScript是必须的，这里推荐一个在线学习网站w3schools：http://www.w3school.com.cn/
> 
> 当使用Python或者其他语言开发Web应用时, 就是要在服务器端动态创建出HTML, 这样浏览器就会向不同的用户显示出不同的Web页面.


#### 8.2.4 WSGI 接口
> 了解了HTTP协议和HTML文档, 其实就明白了一个Web应用的本质就是:
> - 1 .浏览器发送一个HTTP请求.
> - 2.服务器收到请求, 生成一个HTML文档.
> - 3.服务器把HTML文档作为HTTP响应的Body发送给浏览器.
> - 4.浏览器收到HTTP响应, 从HTTP Body取出HTML文档并显示.
> 
> 所以最简单的Web应用就是先把HTML用文件保存好, 用一个现成的HTTP服务器软件接收用户请求, 从文件中读取HTML，返回.
> 正确的做法是底层代码由专门的服务器软件实现, 使用Python专注于生成HTML文档, 因为我们不希望接触到TCP连接、HTTP原始请求和响应格式, 所以需要一个统一的接口, 专心用Python编写Web业务.
> 
> 这个接口就是`WSGI`：(`Web Server Gateway Interface`)
> 
> WSGI接口定义非常简单, 它只要求Web开发者实现一个函数就可以响应HTTP请求, 下面演示最简单的Web版本的“Hello, web!”
> **1. 定义 WSGI处理函数**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : Web开发 | Web development
> # @File : _14_web_development.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # WSGI 接口 | WSGI interface
> 
> # 定义 HTTP处理函数 | Define HTTP handler function
> '''
> 参数说明:
>             `env` 包含所有HTTP请求信息的字典对象
>             `start_response` 发送HTTP响应的函数
> '''
> 
> 
> def wsgi_function(env, start_response):
>     start_response('200 OK', [('Content-Type', 'text/html')])
>     body = '<h1>Hello %s !</h1>' % (env['PATH_INFO'][1:] or 'web')
>     return [body.encode('UTF-8')]
> ```
> 
> **2. 定义 启动WSGI函数**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : Web开发 | Web development
> # @File : __init__.py.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # 导入模块 | Import module
> from wsgiref.simple_server import make_server as mk
> from _14_web_development._14_web_development import wsgi_function as wd
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 启动WSGI服务器 | Start the WSGI server
>     httpd = mk('', 9800, wd)
>     print('Serving HTTP on port 9800...')
>     httpd.serve_forever()
> ```
> **3. 启动 服务端口**
> ```
> 127.0.0.1 - - [26/] "GET /main HTTP/1.1" 200 21
> 127.0.0.1 - - [26/] "GET /favicon.ico HTTP/1.1" 200 28
> 127.0.0.1 - - [26/] "GET /world HTTP/1.1" 200 22
> 127.0.0.1 - - [26/] "GET /favicon.ico HTTP/1.1" 200 28
> 127.0.0.1 - - [26/] "GET /system HTTP/1.1" 200 23
> ```

#### 8.2.5 Web 框架
> 了解了WSGI框架并发现就是编写一个WSGI的处理函数, 针对每个HTTP请求进行响应.
> 
> 由于用Python开发一个Web框架十分容易, 所以Python有上百个开源的Web框架, 选择一个比较流行的Web框架——Flask来使用.
> 
> **1. 安装flask API**
> ```
> (venv) systemhub:python_server system$ pip install flask
> Collecting flask
> ```
> 
> **2. 编写处理程序**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : flask_server
> # @File : flask_server.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # 导入模块 | Import module
> from flask import Flask
> from flask import request as req
> 
> # 初始化 | initialization
> service = Flask(__name__)
> '''
> 请求类型 & 处理响应说明: 
>     请求类型：GET请求 | 处理响应：'/'  返回Home首页
>    请求类型：GET请求 | 处理响应：`/signin` 返回登录页, 显示登录表单
>     请求类型：POST | 处理响应：`/signin` 处理登录表单，显示登录结果
> '''
> 
> 
> # 定义 处理Home路由 | Define Handle Home routing
> @service.route('/', methods=['GET', 'POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def home():
>     return '''
>     <h1>Welcome to Home</h1> 
>     <p><a href="/signin">Sign In</a></p>
>     '''
> 
> 
> # 定义 处理登录路由 | Definition Handle Login Route
> @service.route('/signin', methods=['GET'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def signin_form():
>     return '''
>     <form action="/signin" method="post">
>     <p><input name="UserName"/></p>
>     <p><input name="PassWord" type="password"/></p>
>     <p><a href="/">Return Home</a></p>
>     <p><button type="submit">Sign In</button></p>
>     </form>
>     '''
> 
> 
> # 定义 登录路由 | Define login routes
> @service.route('/signin', methods=['POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def signin():
>     # 验证登录信息 | Verify login information
>     if req.form['UserName'] == 'Admin' and req.form['PassWord'] == 'password':
>         return '''
>         <h3>Hello Admin!</h3> <p><a href="/">Return Home</a></p>
>         '''
>     return '<h3>Bad UserName or PassWord.</h3>'
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 启动运行服务 | Start running service
>     service.run()
> ```
> 
> **3. 启动 服务端口**
> ```
> * Serving Flask app "flask_server" (lazy loading)
> * Environment: production
> WARNING: This is a development server. Do not use it in a production deployment.
> Use a production WSGI server instead.
> * Debug mode: off
> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
> 127.0.0.1 - - [2] "GET / HTTP/1.1" 200 -
> 127.0.0.1 - - [2] "GET /signin HTTP/1.1" 200 -
> 127.0.0.1 - - [2] "POST /signin HTTP/1.1" 200 -
> 127.0.0.1 - - [2] "GET / HTTP/1.1" 200 -
> ```
> 
> 实际的Web应该拿到用户名和口令后与数据库查询再比对, 来判断用户是否能登录成功.
> 
> 除了Flask, 常见的Python Web框架还有: 
> 
> [全能型Web框架 `Django`](https://www.djangoproject.com/) | [小巧的Web框架 `web.py`](http://webpy.org/)
> 
> [和Flask类似的Web框架 `Bottle`](http://bottlepy.org/) | [Facebook的开源异步Web框架 `Tornado`](http://www.tornadoweb.org/)


#### 8.2.6 Web Template
> Web框架把WSGI中拯救出来了, 现在只需要不断地编写函数带上URL, 就可以继续开发Web App.
> 
> 由于在Python代码里拼字符串是不现实的, 所以模板技术出现了.
> 
> 使用模板, 需要预先准备一个HTML文档, 该HTML文档不是普通的HTML, 而是嵌入了一些变量和指令, 然后根据传入的数据替换后得到最终的HTML发送给用户, 该过程称之为MVC：`Model-View-Controller`: 模型-视图-控制器
> 
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/951383573211136)
> 
> Python处理URL的函数就是C(控制器)：Controller负责业务逻辑, 比如检查用户名是否存在, 获取用户信息等等.
> 
> 包含变量`{{ name }}`的模板就是V(视图层)：View负责显示逻辑, 通过简单地替换一些变量, View最终输出的就是用户看到的HTML.
> 
> Model是用来传给View(视图层), 这样View在替换变量的时候就可以从Model中取出相应的数据, 只是因为Python支持关键字参数, 很多Web框架允许传入关键字参数, 然后在框架内部组装出一个dict作为Model.
> 
> Flask通过`render_template()`函数来实现模板的渲染, 和Web框架类似Python的模板也有很多种, Flask默认支持的模板是`jinja2`
> 
> **1. 安装 jinja2**
> ```
> (venv) systemhub:python_server system$ pip install jinja2
> ```
> 
> **2. 编写 模板**
> 
> - 2.1 home.html | 用来显示首页模板
> 
> ``` html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <title>Home Page</title>
> </head>
> <body>
> <h1 style="font-style:italic">Home</h1>
> </body>
> </html>
> ```
> 
> - 2.2 login.html | 用来显示登录表单模板
> 
> ``` html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <title>Please Sign In</title>
> </head>
> <body>
> {% if message %}
> <p style="color:red">{{ message }}</p>
> {% endif %}
> <form action="/signin" method="post">
>     <legend>Please sign in:</legend>
>     <p><input name="username" placeholder="Username" value="{{ username }}"></p>
>     <p><input name="password" placeholder="Password" type="password"></p>
>     <p><button type="submit">Sign In</button></p>
> </form>
> </body>
> </html>
> ```
> 
> - 2.3 main.html | 登录成功后个人主页模板
> 
> ```
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <title>Welcome, {{ username }}</title>
> </head>
> <body>
> <p>Welcome, {{ username }}!</p>
> </body>
> </html>
> ```
> 
> **3. 编写控制层 服务**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : mvc_server
> # @File : mvc_server.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # 导入模块 | Import module
> from flask import Flask, request as req, render_template as rt
> 
> # 初始化 | initialization
> service = Flask(__name__)
> 
> '''
> 请求类型 & 处理响应说明: 
>     请求类型：GET请求 | 处理响应：'/'  返回Home首页
>     请求类型：GET请求 | 处理响应：`/signin` 返回登录页, 显示登录表单
>     请求类型：POST | 处理响应：`/signin` 处理登录表单，显示登录结果
> '''
> 
> 
> # 定义 处理Home路由 | Define Handle Home routing
> @service.route('/', methods=['GET', 'POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def home():
>     return rt('home.html')
> 
> 
> # 定义 处理登录路由 | Definition Handle Login Route
> @service.route('/signin', methods=['GET'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def login():
>     return rt('login.html')
> 
> 
> # 定义 登录路由 | Define login routes
> @service.route('/signin', methods=['POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def signin():
>     # 验证登录信息 | Verify login information
>     username = req.form['username']
>     password = req.form['password']
>     if username == 'Admin' and password == '0000x':
>         return rt('main.html', username=username)
>     return rt('login.html', message='Bad username or password', username=username)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 启动运行服务 | Start running service
>     service.run()
> ```
> **4. 启动 MVC服务**
> ```
> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
>  * Serving Flask app "mvc_server" (lazy loading)
>  * Environment: production
>    WARNING: This is a development server. Do not use it in a production deployment.
>    Use a production WSGI server instead.
>  * Debug mode: off
>  127.0.0.1 - - [26] "GET / HTTP/1.1" 200 -
>  127.0.0.1 - - [2] "GET /signin HTTP/1.1" 200 -
>  127.0.0.1 - - [2] "POST /signin HTTP/1.1" 200 -
> ```
> 
> 通过MVC在Python代码中处理M：Model和C：Controller，而V：View是通过模板处理的, 这样就成功地把Python代码和HTML代码最大限度地分离了.
> 
> 使用模板的另一大好处是模板改起来很方便, 而且改完保存后刷新浏览器就能看到最新的效果.
> 除了Jinja2, 常见的模板还有: 
> - [Mako：用`<% ... %>`和`${xxx}`的一个模板](http://www.makotemplates.org/)
> - [Cheetah：也是用`<% ... %>`和`${xxx}`的一个模板](http://www.cheetahtemplate.org/)
> - [Django：Django是一站式框架，内置一个用`{% ... %}`和`{{ xxx }}`的模板](https://www.djangoproject.com/)


### 8.3 Python DataBase
#### 8.3.1 前言
> 程序运行的时数据都是在内存中的, 当程序终止的时, 通常都需要将数据保存到磁盘上, 无论是保存到本地磁盘, 还是通过网络保存到服务器上最终都会将数据写入磁盘文件.
> 
> 为了便于程序保存和读取数据, 而且能直接通过条件快速查询到指定的数据, 就出现了数据库(Database)这种专门用于集中存储和查询的软件.
> 
> 数据库软件诞生的历史非常久远, 早在1950年数据库就诞生了, 经历了网状数据库, 层次数据库, 现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的.
> 

#### 8.3.2 SQLite
> SQLite是一种嵌入式数据库, 它的数据库就是一个文件, 由于SQLite本身是C写的而且体积很小, 所以经常被集成到各种应用程序中, 甚至在iOS和Android的App中都可以集成.
> 
> Python定义了一套操作数据库的API接口, 任何数据库要连接到Python, 只需要提供符合Python标准的数据库驱动即可.
> 
> 由于SQLite的驱动内置在Python标准库中, 所以可以直接来操作SQLite数据库.
> 
> 使用Python的DB-API时, 只要搞清楚`Connection`和`Cursor`对象, 打开后一定记得关闭就可以放心地使用.
> 
> 使用`Cursor`对象执行`insert`, `update`, `delete`语句时, 执行结果由`rowcount`返回影响的行数就可以拿到执行结果.
> 
> 使用`Cursor`对象执行`select`语句时通过`featchall()`可以拿到结果集, 结果集是一个`list`, 每个元素都是一个`tuple`对应一行记录.
> 
> 在Python中操作数据库时, 要先导入数据库对应的驱动, 然后通过`Connection对象`和`Cursor对象`操作数据.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据库 | database
> # @File : 15_database.py
> # @Description : Python 进阶篇 - 数据库 | Advanced Python-Database
> 
> # 导入模块 | Import module
> import sqlite3 as sl
> import os as o
> 
> # 数据库 for SQLite | Database for SQLite
> 
> # 定义 函数 | Defining functions
> def database_for_sqlite_insert():
>     '''
>     连接到SQLite数据库, 数据库文件是test.db
>     如果文件不存在则自动在当前目录创建
>     '''
>     connection = sl.connect('test.db')
> 
>     # 创建 Cursor | Create Cursor
>     cursor = connection.cursor()
> 
>     # 创建 数据表 | Create data table
>     cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
> 
>     # 创建 插入语句 | Create insert statement
>     cursor.execute('insert into user (id, name) values (\'1\', \'system\')')
> 
>     # 通过rowcount获得插入的行数 | Get the number of inserted rows by rowcount
>     print('rowcount=', cursor.rowcount)
> 
>     # 关闭Cursor | Close Cursor
>     cursor.close()
> 
>     # 提交事务 | Commit transaction
>     connection.commit()
> 
>     # 关闭资源 | Close resource
>     connection.close()
> 
> 
> def database_for_sqlite_select():
>     '''
>     连接到SQLite数据库, 数据库文件是test.db
>     如果文件不存在则自动在当前目录创建
>     '''
> 
>     connection = sl.connect('test.db')
> 
>     # 创建 Cursor | Create Cursor
>     cursor = connection.cursor()
> 
>     # 执行查询语句 | Execute query
>     cursor.execute('select * from user where id=?', '1')
> 
>     # 获得查询结果集 | Get query result set
>     values = cursor.fetchall()
>     print('values=', values)
> 
>     # 关闭Cursor | Close Cursor
>     cursor.close()
> 
>     # 关闭资源 | Close resource
>     connection.close()
> 
> # 定义 类 | Definition class
> class Student:
>     # 定义 初始化 方法 | Define initialization method
>     def __init__(self):
>         db_file = o.path.join(o.path.dirname(__file__), 'student_test.db')
>         if o.path.isfile(db_file):
>             o.remove(db_file)
>         # 创建 连接 | Create connection
>         conn = sl.connect(db_file)
>         # 创建 Cursor | Create Cursor
>         cursor = conn.cursor()
>         cursor.execute('create table student(id varchar(20) primary key, name varchar(20), score int)')
>         cursor.execute(r"insert into student values ('A-001', 'Adam', 95)")
>         cursor.execute(r"insert into student values ('A-002', 'Bart', 62)")
>         cursor.execute(r"insert into student values ('A-003', 'Lisa', 78)")
>         cursor.close()
>         conn.commit()
>         conn.close()
> 
>     # 定义 方法 | 返回指定分数区间的姓名, 按分数从低到高排序
>     def get_score_in(self, low, high):
>         global cursor, connection
>         try:
>             connection = sl.connect('student_test.db')
>             cursor = connection.cursor()
>             cursor.execute('select name from student where score >=? and score <=? order by score', (low, high))
>             values = cursor.fetchall()
>             return list(map(lambda v: v[0], values))
>         except BaseException as e:
>             print('Connection Error!', e)
>         finally:
>             cursor.close()
>             connection.close()
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     database_for_sqlite_insert()
>     database_for_sqlite_select()
>         s = Student()
>     s.__init__()
>     print('score: 80~95=', s.get_score_in(80, 95))
>     print('score: 60~80=', s.get_score_in(60, 80))
>     print('score: 60~100=', s.get_score_in(60, 100))
> ```

#### 8.3.3 MySQL
> MySQL是Web世界中使用最广泛的数据库服务器, SQLite的特点是轻量级、可嵌入, 但不能承受高并发访问, 适合桌面和移动应用, 而MySQL是为服务器端设计的数据库能承受高并发访问, 同时占用的内存也远远大于SQLite, 此外MySQL内部有多种数据库引擎, 最常用的引擎是支持数据库事务的InnoDB.
> 
> **安装MySQL驱动**
> 由于MySQL服务器以独立的进程运行并通过网络对外服务, 所以需要支持Python的MySQL驱动来连接到MySQL服务器, MySQL官方提供了mysql-connector-python驱动, 但是安装的时候需要给pip命令加上参数`--allow-external`
> ```
> (venv) systemhub:python_server system$ pip install mysql-connector
> ```
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据库 | database
> # @File : 15_database.py
> # @Description : Python 进阶篇 - 数据库 | Advanced Python-Database
> 
> # 导入模块 | Import module
> import sqlite3 as sl
> import os as o
> # install mysql-connector-python:
> # pip3 install mysql-connector-python --allow-external mysql-connector-python
> import mysql.connector
> 
> # 数据库 for MySQL | Database for MySQL
> # 定义 函数 | Defining functions
> def database_for_mysql():
>     # change root password to yours:
>     conn = mysql.connector.connect(user='root', password='password', database='test')
> 
>     cursor = conn.cursor()
>     # 创建user表
>     cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
>     # 插入一行记录，注意MySQL的占位符是%s:
>     cursor.execute('insert into user (id, name) values (%s, %s)', ('1', 'system'))
>     print('rowcount =', cursor.rowcount)
>     # 提交事务 | Commit transaction
>     conn.commit()
>    # 关闭资源 | Close resource
>     cursor.close()
> 
>     # 运行查询
>     cursor = conn.cursor()
>     cursor.execute('select * from user where id = %s', ('1',))
>     values = cursor.fetchall()
>     print(values)
>     # 关闭Cursor和Connection:
>     cursor.close()
>     conn.close()
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     database_for_mysql()
> ```


#### 8.3.4 SQLAlchemy
> 数据库表是一个二维表, 包含多行多列, 把一个表的内容用Python的数据结构表示出来的话, 可以用一个list表示多行, list的每一个元素是tuple表示一行记录, 比如包含id和name的user表: 
> ```
> [
>     ('1', 'system001'),
>     ('2', 'system002'),
>     ('3', 'system003')
> ]
> ```
> Python的DB-API返回的数据结构就是像上面这样表示.
> 
> 但是用tuple表示一行很难看出表的结构, 如果把一个tuple用class实例来表示就可以更容易地看出表的结构来：
> 
> Object-Relational Mapping, 把关系数据库的表结构映射到对象上简称为(对象关系映射)`ORM`.
> 
> ``` py
> class User(object):
>     def __init__(self, id, name):
>         self.id = id
>         self.name = name
> 
> [
>     User('1', 'system001'),
>     User('2', 'system002'),
>     User('3', 'system003')
> ]
> ```
> 
> 在Python中最有名的ORM框架是SQLAlchemy, 下面看看SQLAlchemy用法:
> 
> **安装SQLAlchemy**
> ```
> pip install sqlalchemy
> ```
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据库 | database
> # @File : 15_database.py
> # @Description : Python 进阶篇 - 数据库 | Advanced Python-Database
> 
> # 导入模块 | Import module
> import sqlite3 as sl
> import os as o
> # install mysql-connector-python:
> # pip3 install mysql-connector-python --allow-external mysql-connector-python
> import mysql.connector
> from sqlalchemy import Column, String, create_engine
> from sqlalchemy.orm import sessionmaker
> from sqlalchemy.ext.declarative import declarative_base
> 
> # 数据库 for SQL Alchemy | Database for SQL Alchemy
> # 定义 函数 | Defining functions
> def database_for_sqlalchemy():
>     # 创建对象的基类:
>     Base = declarative_base()
> 
>     # 定义User对象:
>     class User(Base):
>         # 表的名字:
>         __tablename__ = 'user'
> 
>         # 表的结构:
>         id = Column(String(20), primary_key=True)
>         name = Column(String(20))
> 
>     # 初始化数据库连接:
>     engine = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')
>     # 创建DBSession类型:
>     DBSession = sessionmaker(bind=engine)
> 
>     # 创建session对象:
>     session = DBSession()
>     # 创建新User对象:
>     new_user = User(id='5', name='Bob')
>     # 添加到session:
>     session.add(new_user)
>     # 提交即保存到数据库:
>     session.commit()
>     # 关闭session:
>     session.close()
> 
>     # 创建Session:
>     session = DBSession()
>     # 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
>     user = session.query(User).filter(User.id == '5').one()
>     # 打印类型和对象的name属性:
>     print('type:', type(user))
>     print('name:', user.name)
>     # 关闭Session:
>     session.close()
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':    
>       database_for_sqlalchemy() 
> ```


### 8.4 Python 网络编程
#### 8.4.1 前言
> 自从互联网诞生以来, 现在基本上所有的程序都是网络程序, 很少有单机版的程序.
> 
> 由于你的电脑上可能不止浏览器, 还有QQ、Skype、Dropbox、邮件客户端等, 不同的程序连接的别的计算机也会不同, 所以, 更确切地说网络通信是两台计算机上的两个进程之间的通信, 比如浏览器进程和新浪服务器上的某个Web服务进程在通信, 而QQ进程是和腾讯的某个服务器上的某个进程在通信.
> 
> 网络编程对所有开发语言都是一样, Python也不例外,使用Python进行网络编程就是在Python程序本身这个进程内, 连接别的服务器进程的通信端口进行通信.
> 
> Python 提供了两个级别访问的网络服务:
> - 1.低级别的网络服务支持基本的Socket, 它提供了标准的 BSD Sockets API, 可以访问底层操作系统Socket接口的全部方法.
> - 2.高级别的网络服务模块 SocketServer, 它提供了服务器中心类, 可以简化网络服务器的开发.

#### 8.4.2 TCP/IP 简介
> 计算机为了联网就必须规定通信协议, 早期的计算机网络都是由各厂商自己规定一套协议, IBM、Apple和Microsoft都有各自的网络协议, 互不兼容, 这就好比一群人有的说英语, 有的说中文, 有的说德语, 说同一种语言的人可以交流, 不同的语言之间就不行了.
> 
> 为了把全世界的所有不同类型的计算机都连接起来就必须规定一套全球通用的协议, 为了实现互联网这个目标, 互联网协议簇（Internet Protocol Suite）就是通用协议标准, Internet是由inter和net两个单词组合起来的, 原意就是连接“网络”的网络有了Internet, 任何私有网络只要支持这个协议就可以联入互联网.
> 
> 因为互联网协议包含了上百种协议标准, 但是最重要的两个协议是TCP和IP协议, 所以把互联网的协议简称TCP/IP协议.
> 
> 通信的时候双方必须知道对方的标识, 好比发邮件必须知道对方的邮件地址, 互联网上每个计算机的唯一标识就是IP地址，类似`123.123.123.123`, 如果一台计算机同时接入到两个或更多的网络, 比如路由器它就会有两个或多个IP地址, 所以IP地址对应的实际上是计算机的网络接口通常是网卡.
> 
> IP协议负责把数据从一台计算机通过网络发送到另一台计算机, 数据被分割成一小块一小块, 然后通过IP包发送出去, 由于互联网链路复杂, 两台计算机之间经常有多条线路, 因此路由器就负责决定如何把一个IP包转发出去, IP包的特点是按块发送, 途径多个路由但不保证能到达也不保证顺序到达.
> 
> TCP协议则是建立在IP协议之上的, TCP协议负责在两台计算机之间建立可靠连接保证数据包按顺序到达, TCP协议会通过握手建立连接, 然后对每个IP包编号, 确保对方按顺序收到, 如果包丢掉了就自动重发.
> 
> 许多常用的更高级的协议都是建立在TCP协议基础上的, 比如用于浏览器的HTTP协议、发送邮件的SMTP协议等.
> 
> 一个TCP报文除了包含要传输的数据外, 还包含源IP地址和目标IP地址, 源端口和目标端口.
> 
> 一个进程也可能同时与多个计算机建立链接, 因此它会申请很多端口.
> 
> 了解了TCP/IP协议的基本概念, IP地址和端口的概念, 下面就可以开始进行网络编程.

#### 8.4.3 TCP 编程
> Socket是网络编程的一个抽象概念, 通常用一个Socket表示“打开了一个网络链接”, 而打开一个Socket需要知道目标计算机的IP地址和端口号再指定协议类型即可.
> 
> **1. 客户端**
> 大多数连接都是可靠的TCP连接, 创建TCP连接时主动发起连接的叫客户端, 被动响应连接的叫服务器.
> 
> **2. 服务器**
> 和客户端编程相比服务器编程就要复杂一些, 服务器进程首先要绑定一个端口并监听来自其他客户端的连接, 如果某个客户端连接过来了, 服务器就与该客户端建立Socket连接随后的通信就靠这个Socket连接了.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : TCP 网络编程 | TCP network programming
> # @File : tcp_socket.py
> # @Description :  Python 进阶篇 - 网络编程 | Advanced Python-Network Programming
> 
> # 导入模块 | Import module
> import socket as sk
> 
> 
> # 定义 函数 | Defining functions
> def socket_function():
>     # 创建 Socket | Create Socket
>     '''
>     参数说明 :
>                 `AF_INET6` 指定IPv6网络协议
>                 `SOCK_STREAM` 指定面向流TCP协议
>     '''
>     s = sk.socket(sk.AF_INET6, sk.SOCK_STREAM)
> 
>     # 创建 连接 | Create connection
>     '''
>     定义 服务器IP地址&端口号
>     '''
>     s.connect(('58.49.227.129', 80))
> 
>     # 发送 数据 | send data
>     '''
>     向服务端发送请求
>     '''
>     s.send(b'GET / HTTP/1.1\r\nHost: 58.49.227.129\r\nConnection: close\r\n\r\n')
> 
>     # 接收 数据 | Receive data
>     buffer = []
>     while True:
>         byte_size = s.recv(1024)
>         if byte_size:
>             buffer.append(byte_size)
>         else:
>             break
>     data = b' '.join(buffer)
> 
>     # 关闭资源 | Close resource
>     s.close()
> 
>     header, html = data.split(b'\r\n\r\n', 1)
>     print(header.decode('UTF-8'))
> 
>     # 数据写入文件
>     with open('test.html', 'wb') as f:
>         f.write(html)
>         
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     socket_function()         
> ```

#### 8.4.4 UDP 编程
> TCP是建立可靠连接并且通信双方都可以以流的形式发送数据, 相对TCP, UDP则是面向无连接的协议.
> 
> 使用UDP协议时不需要建立连接, 只需要知道对方的IP地址和端口号就可以直接发数据包, 但是能不能到达就不知道了.
> 
> 虽然用UDP传输数据不可靠, 但它的优点是和TCP比, 速度快, 对于不要求可靠到达的数据就可以使用UDP协议.
> 
> UDP的使用与TCP类似, 但是不需要建立连接, 此外服务器绑定UDP端口和TCP端口互不冲突, 也就是说UDP的9999端口与TCP的9999端口可以各自绑定.
> 
> **udp_socket_server**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : UDP 网络编程 | UDP network programming
> # @File : udp_socket_server.py
> # @Description : Python 进阶篇 - 网络编程 | Advanced Python-Network Programming
> 
> # 导入模块 | Import module
> import socket as sk
> 
> 
> # 定义 服务端 函数 | Defining Server functions
> def udp_server():
>     # 创建 Socket | Create Socket
>     '''
>     参数说明 :
>                 `AF_INET` 指定IPv4网络协议
>                 `SOCK_STREAM` 指定面向流TCP协议
>     '''
>     s = sk.socket(sk.AF_INET, sk.SOCK_DGRAM)
> 
>     # 绑定 端口 | Bind port
>     s.bind(('127.0.0.1', 9999))
> 
>     print('Bind UDP on 9999...')
> 
>     # 接收 数据 | Receive data
>     while True:
>         data, addr = s.recvfrom(1024)
>         print('Received From %s:%s.' % addr)
>         reply = 'Hello, %s!' % data.decode('UTF-8')
>         s.sendto(reply.encode('UTF-8'), addr)
> 
> 
> # 调用 函数 | call function
> udp_server()
> ```
> 
> **udp_socket_client**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : UDP 网络编程 | UDP network programming
> # @File : udp_socket_client.py
> # @Description : Python 进阶篇 - 网络编程 | Advanced Python-Network Programming
> 
> # 导入模块 | Import module
> import socket as sk
> 
> 
> # 定义 客户端 函数 | Defining Client functions
> def udp_client():
>     # 创建 Socket | Create Socket
>     '''
>     参数说明 :
>                 `AF_INET` 指定IPv4网络协议
>                 `SOCK_STREAM` 指定面向流TCP协议
>     '''
>     s = sk.socket(sk.AF_INET, sk.SOCK_DGRAM)
> 
>     lists = [b'Edward', b'System', b'Juliet', b'Romeo']
> 
>     for x in lists:
>         # 发送数据 | send data
>         s.sendto(x, ('127.0.0.1', 9999))
>         # 接收数据 | Receive data
>         print(s.recv(1024).decode('UTF-8'))
>     # 关闭资源 | Close resource
>     s.close()
> 
> 
> # 调用 函数 | call function
> udp_client()
> ```


### 8.5 Python SMTP
#### 8.5.1 前言
> SMTP (Simple Mail Transfer Protocol)即简单邮件传输协议, 它是一组用于由源地址到目的地址传送邮件的规则, 由它来控制信件的中转方式.
> 
> python的smtplib提供了一种很方便的途径发送电子邮件, 它对smtp协议进行了简单的封装.

#### 8.5.2 SMTP发送邮件
> SMTP是发送邮件的协议, Python内置对SMTP的支持, 可以发送纯文本邮件、HTML邮件以及带附件的邮件.
> 
> Python对SMTP支持有`smtplib`和`email`两个模块, `email`负责构造邮件, `smtplib`负责发送邮件.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 邮件 | mail
> # @File : 17_mail.py
> # @Description : Python 进阶篇 - 邮件 | Advanced Python - Mail
> 
> # 导入模块 | Import module
> from email import encoders as ed
> from email.header import Header as hd
> from email.mime.text import MIMEText as mt
> from email.utils import parseaddr as pa, formataddr as fa
> import smtplib as st
> 
> 
> # 定义 格式化地址 函数 | Definition format address function
> def _format_addr(s):
>     name, addr = pa(s)
>     return fa((hd(name, 'UTF-8').encode(), addr))
> 
> 
> # 定义 发送邮件 函数 | Define send mail function
> def send_function():
>     from_addr = input('From: \n')  # 输入Email地址 | Enter email address
>     password = input('Password: \n')  # 输入Email地址口令 | Enter email address and password
>     to_addr = input('To: \n')  # 输入收件人地址 | Enter recipient address
>     smtp_server = input('SMTP server: \n')  # 输入SMTP服务器地址 | Enter SMTP server address
> 
>     '''
>     构造MIMEText对象
>     参数说明: 
>                 `Hello, Send by Python...` 表示邮件正文
>                 `plain` 表示邮件类型为纯文本
>                 `UTF-8` 表示邮件编码
>     '''
>     message = mt('Hello, Send by Python...', 'plain', 'UTF-8')
>     message['From'] = _format_addr('Dev <%s>' % from_addr)
>     message['To'] = _format_addr('Administrator <%s>' % to_addr)
>     message['Subject'] = hd('Greetings from SMTP……', 'UTF-8').encode()
> 
>     server = st.SMTP(smtp_server, 25)  # 定义 SMTP协议默认端口 | Define the SMTP protocol default port
>     server.set_debuglevel(1)  # 打印SMTP服务器交互信息 | Print SMTP server interaction information
>     server.login(from_addr, password)  # 登录SMTP服务器 | Log in to the SMTP server
>     server.sendmail(from_addr, [to_addr], message.as_string())  # 发送邮件 | send email
>     server.quit()  # 退出SMTP服务器 | Exit SMTP server
> 
> 
> # 调用 函数 | call function
> send_function()
> ```

#### 8.5.3 POP3收取邮件
> 收取邮件就是编写一个MUA作为客户端, MDA把邮件获取到用户的电脑或者手机上, 收取邮件最常用的协议是POP协议, 目前版本号是3, 称之为POP3.
> 
> Python内置`poplib`模块, 实现了POP3协议, 可以直接用来收邮件.
> 
> 注意到POP3协议收取的不是一个已经可以阅读的邮件本身而是邮件的原始文本, 这和SMTP协议很像, SMTP发送的也是经过编码后的一大段文本.
> 
> 要把POP3收取的文本变成可以阅读的邮件, 还需要用email模块提供的各种类来解析原始文本变成可阅读的邮件对象, 所以收取邮件分两步:
> - 1.使用poplib把邮件的原始文本下载到本地.
> - 2.使用email解析原始文本，还原为邮件对象.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 邮件 | mail
> # @File : 17_mail.py
> # @Description : Python 进阶篇 - 邮件 | Advanced Python - Mail
> 
> # 导入模块 | Import module
> from email import encoders as ed
> from email.header import Header as hd
> from email.mime.text import MIMEText as mt
> from email.utils import parseaddr as pa, formataddr as fa
> from email.parser import Parser as ps
> from email.header import decode_header as dh
> import poplib as pl
> 
> # 定义 收取邮件 函数 | Define receive mail function
> def receive_mail():
>     # 输入邮件地址&口令&POP3服务器地址 | Enter email address & password & POP 3 server address
>     email = input('Email: ')
>     password = input('Password: ')
>     pop3_server = input('POP3 server: ')
>     # 连接到POP3服务器:
>     server = pl.POP3(pop3_server)
>     # 可以打开或关闭调试信息:
>     server.set_debuglevel(1)
>     # 可选:打印POP3服务器的欢迎文字:
>     print(server.getwelcome().decode('utf-8'))
>     # 身份认证:
>     server.user(email)
>     server.pass_(password)
>     # stat()返回邮件数量和占用空间:
>     print('Messages: %s. Size: %s' % server.stat())
>     # list()返回所有邮件的编号:
>     resp, mails, octets = server.list()
>     # 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]
>     print(mails)
>     # 获取最新一封邮件, 注意索引号从1开始:
>     index = len(mails)
>     resp, lines, octets = server.retr(index)
>     # lines存储了邮件的原始文本的每一行,
>     # 可以获得整个邮件的原始文本:
>     msg_content = b'\r\n'.join(lines).decode('UTF-8')
>     # 稍后解析出邮件:
>     msg = ps().parsestr(msg_content)
>     print_info(msg)
>     # 可以根据邮件索引号直接从服务器删除邮件:
>     # server.dele(index)
>     # 关闭连接:
>     server.quit()
> 
> 
> # 定义 查找字符集 函数 | Definition Find Character Set Function
> def guess_charset(msg):
>     charset = msg.get_charset()
>     if charset is None:
>         content_type = msg.get('Content-Type', '').lower()
>         pos = content_type.find('charset=')
>         if pos >= 0:
>             charset = content_type[pos + 8:].strip()
>     return charset
> 
> 
> # 定义 解码字符集 函数 | Definition decode character set function
> def decode_str(s):
>     value, charset = dh(s)[0]
>     if charset:
>         value = value.decode(charset)
>     return value
> 
> 
> # 定义 打印信息 函数 | Definition print information function
> def print_info(msg, indent=0):
>     if indent == 0:
>         for header in ['From', 'To', 'Subject']:
>             value = msg.get(header, '')
>             if value:
>                 if header == 'Subject':
>                     value = decode_str(value)
>                 else:
>                     hdr, addr = pa(value)
>                     name = decode_str(hdr)
>                     value = u'%s <%s>' % (name, addr)
>             print('%s%s: %s' % ('  ' * indent, header, value))
>     if (msg.is_multipart()):
>         parts = msg.get_payload()
>         for n, part in enumerate(parts):
>             print('%spart %s' % ('  ' * indent, n))
>             print('%s--------------------' % ('  ' * indent))
>             print_info(part, indent + 1)
>     else:
>         content_type = msg.get_content_type()
>         if content_type == 'text/plain' or content_type == 'text/html':
>             content = msg.get_payload(decode=True)
>             charset = guess_charset(msg)
>             if charset:
>                 content = content.decode(charset)
>             print('%sText: %s' % ('  ' * indent, content + '...'))
>         else:
>             print('%sAttachment: %s' % ('  ' * indent, content_type))
> 
> 
> # 调用 函数 | call function
> receive_mail()
> ```


## 🔒 尚未解锁 正在探索中... 尽情期待 Blog更新! 🔒

### 8.6 Python 多线程
### 8.7 Python XML 解析
### 8.8 Python GUI 编程(Tkinter)
### 8.9 Python JSON
### 8.10 Python 异步IO
### 8.11 Python 函数式编程
### 8.12 Python 高级特性
### 8.13 Python 模块
### 8.14 Python 常用内建模块 & 常用第三方模块




## 9. 修仙之道 技术架构迭代 登峰造极之势
![Alt text](https://raw.githubusercontent.com/geekparkhub/geekparkhub.github.io/master/technical_guide/assets/media/main/technical_framework.jpg)

-----

## 💡如何对该开源文档进行贡献💡

1. Blog内容大多是手敲,所以难免会有笔误,你可以帮我找错别字。
2. 很多知识点我可能没有涉及到,所以你可以对其他知识点进行补充。
3. 现有的知识点难免存在不完善或者错误,所以你可以对已有知识点的修改/补充。
4. 💡欢迎贡献`各领域开源野生Blog`&`笔记`&`文章`&`片段`&`分享`&`创想`&`OpenSource Project`&`Code`&`Code Review`
5. 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈 issues: [geekparkhub.github.io/issues](https://github.com/geekparkhub/geekparkhub.github.io/issues) 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈

### 希望每一篇文章都能够对读者们提供帮助与提升,这乃是每一位笔者的初衷                          


-----


## 💌感谢您的阅读 欢迎您的留言与建议💌

- FaceBook：[JEEP SevenEleven](https://www.facebook.com/profile.php?id=100018099483403)
- Twitter：[@JEEP7ll](https://twitter.com/JEEP7ll)
- Sina Weibo: [@JEEP-711](https://weibo.com/JEEP511)
- GeekParkHub GithubHome：<https://github.com/geekparkhub>
- GeekParkHub GiteeHome：<https://gitee.com/geekparkhub>
- Blog GardenHome：<http://www.cnblogs.com/JEEP711/>
- W3C/BlogHome：<https://www.w3cschool.cn/jeep711blog/>
- CSDN/BlogHome：<http://blog.csdn.net/jeep911>
- 51CTO/BlogHome：<http://jeep711.blog.51cto.com/>
- **`Official Public Email`**
- Group Email：<geekparkhub@outlook.com> —— <hackerparkhub@outlook.com> —— <hackerpark@hotmail.com>
- User Email：<jeep711.home.@gmail.com> —— <jeep-711@outlook.com>
- System Email：<systemhub-711@outlook.com>
- Service Email：<servicehub-711@outlook.com>



### 捐助 项目的发展离不开你的支持,请开发者喝杯☕Coffee☕吧!
![enter image description here](https://www.geekparkhub.com/docs/images/pay.jpg)

#### `致谢`：
**捐助时请备注 UserName**
| ID| UserName | Donation | Money | Consume |
|:-| :-------- | --------:| :--: |:--: |
|1 | Object | WeChatPay |  5RMB | 一杯可乐 | 
|2| 泰迪熊看月亮  | AliPay |  20RMB  | 一杯咖啡 | 
|3| 修仙道长  | WeChatPay |  10RMB | 两杯可乐 | 


## License 开源协议
[Apache License Version 2.0](https://github.com/geekparkhub/geekparkhub.github.io/blob/master/LICENSE)

---------


