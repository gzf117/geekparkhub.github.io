# 修性之道 Python Blog

@(2020-02-02)[ Docs Language:简体中文 & English|Programing Python|Website:[www.geekparkhub.com](https://www.geekparkhub.com/)|![OpenSource](https://img.shields.io/badge/Open%20Source-%E2%9D%A4-brightgreen.svg) | ![GitHub repo size in bytes](https://img.shields.io/github/repo-size/geekparkhub/geekparkhub.github.io.svg) | GeekDeveloper:[JEEP-711](https://github.com/jeep711)|Github:[github.com/geekparkhub](https://github.com/geekparkhub)|Gitee:[gitee.com/geekparkhub](https://gitee.com/geekparkhub) ]

## 🐍  Python Technology 修性之道 得之淡然 失之泰然 🐍

![Alt text](https://raw.githubusercontent.com/geekparkhub/geekparkhub.github.io/master/technical_guide/assets/media/python/opening/python_1.jpg)

- **极客实验室是极客国际公园旗下为未来而构建的极客社区;**
- **我们正在构建一个活跃的小众社区,汇聚众多优秀开发者与设计师;**
- **关注极具创新精神的前沿技术&分享交流&项目合作机会等互联网行业服务;**
- **Open开放 `·` Creation创想 `|` OpenSource开放成就梦想 GeekParkHub共建前所未见!**
- **Future Vision : Establishment of the Geek Foundation;**
- **GeekParkHub GithubHome:**<https://github.com/geekparkhub>
- **GeekParkHub GiteeHome:**<https://gitee.com/geekparkhub>
- **欢迎贡献`各领域开源野生Blog`&`笔记`&`文章`&`片段`&`分享`&`创想`&`OpenSource Project`&`Code`&`Code Review`**
- 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈 issues: [geekparkhub.github.io/issues](https://github.com/geekparkhub/geekparkhub.github.io/issues) 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈
- **`Official Public Email`**
- Group Email：<geekparkhub@outlook.com> —— <hackerparkhub@outlook.com> —— <hackerpark@hotmail.com>
- User Email：<jeep711.home.@gmail.com> —— <jeep-711@outlook.com>
- System Email：<systemhub-711@outlook.com>
- Service Email：<servicehub-711@outlook.com>


-------------------


[TOC]



## 🔥 0. 在学习Python之前你需要了解 🔥
> 在继续学习本路线之前,你应该了解一些基本计算机编程/操作系统命令行/环境变量/进制等等术语.
> 
> Python是一种广泛使用的高级解释型编程语言,并且支持多种编程范式, 包括面向对象、命令式、函数式和过程式编程.
> 
> 在Python技术界有个不成文的说法，那就是Life is short you need Python (人生苦短, 我用Python)
> 
> 此学习路线将基于Python3编程语言进行详细操作.
> 
> 如果你学习过```Java``` & ```Scala``` & ```GoLang``` & ```PHP``` & ```Ruby```等编程语言, 将有助于你更快了解掌握Python核心技术与思想.



## 💥 1. Python 简介 💥
> Python是一种广泛使用的解释型、高级编程、通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年, Python的设计哲学强调代码的可读性和简洁的语法，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库等.   —— [维基百科](https://zh.wikipedia.org/zh-hans/Python)



## 💥  2. Python 发展历史 💥
> Python 是由 Guido van Rossum 在八十年代末和九十年代初, 在荷兰国家数学和计算机科学研究所设计出来的.
> 
> Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等.
> 
>  像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License)协议.
>  
>  现在 Python 是由一个核心开发团队在维护, Guido van Rossum 仍然占据着至关重要的作用, 指导其进展.
>  
>  Python 2.7 被确定为最后一个 Python 2.x 版本, 它除了支持 Python 2.x 语法外，还支持部分Python 3.1 语法.



## 💥 3. Python 特点 💥
> 1.易于学习：Python有相对较少的关键字, 结构简单, 明确定义的语法, 学习起来更加简单.
> 
> 2.易于阅读：Python代码定义的更清晰.
> 
> 3.易于维护：Python的成功在于它的源代码是相当容易维护.
> 
> 4.一个广泛的标准库：Python的最大的优势之一是丰富的库, 跨平台的，在UNIX，Windows和Macintosh兼容很好.
> 
> 5.互动模式：互动模式的支持, 可以从终端输入执行代码并获得结果的语言, 互动的测试和调试代码片断.
> 
> 6.可移植：基于其开放源代码的特性, Python已经被移植（也就是使其工作）到许多平台.
> 
> 7.可扩展：如果你需要一段运行很快的关键代码, 或者是想要编写一些不愿开放的算法, 你可以使用C或C++完成那部分程序, 然后从你的Python程序中调用.
> 
> 8.数据库：Python提供所有主要的商业数据库的接口.
> 
> 9.GUI编程：Python支持GUI可以创建和移植到许多系统调用.
> 
> 10.可嵌入: 你可以将Python嵌入到C/C++程序, 让你的程序的用户获得"脚本化"的能力.



## 💥 4. Python 应用范围 💥
> 网络应用程序 / GUI开发 / 操作系统 / 科学计算 / 自动化运维 / 大数据 / 云计算 / 人工智能等等


## 💥 5. Python 环境搭建 💥
> 因为Python是跨平台, 它可以运行在Windows、Mac和各种Linux/Unix系统上, 在Windows上写Python程序,放到Linux上也是能够运行.
> 
> 目前Python有两个版本, 一个是2.x版, 一个是3.x版, 这两个版本是不兼容, 由于3.x版越来越普及, 本次将以最新Python 3.8.1版本为基础, 请确保你的电脑上安装的Python版本是最新的3.8.x版本


### 5.1 Python Download
> [Python 官网 : www.python.org](https://www.python.org/) | [Python 文档 : www.python.org/doc](https://www.python.org/doc/)


### 5.2 Python For Linux
> 在Python官网下载Python 3.8.1源码安装包,  [点击下载 Python 3.8.1 For Gzipped source tarball](https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz), 下载以```.tgz```安装包.
> 
> 1.解压安装包,并重命名
> ``` bash
> [root@systemhub511 ~]# cd /opt/software/
> [root@systemhub511 software]# tar -zxvf Python-3.8.1.tgz -C /opt/module/
> [root@systemhub511 software]# cd /opt/module/
> [root@systemhub511 module]# mv Python-3.8.1 python
> [root@systemhub511 module]# cd python/
> [root@systemhub511 python]# pwd
> /opt/module/python
> [root@systemhub511 python]# 
> ``` 
> 
> 2.设置环境变量 | ```sudo vim /etc/profile```
> ```
> [root@systemhub511 ~]# vim /etc/profile
> ```
> 3.定义环境变量,将配置信息写入至profile文件中
> ```
> ## SET_PYTHON_HOME
> export PYTHON_HOME=/opt/module/python
> export PATH=$PATH:$PYTHON_HOME/bin
> ``` 
> 4.写入完毕后, 按ESC键, 输入`:wq!`保存并退出.
> 
> 5.刷新配置文件 | ```source /etc/profile```
> ```
> [root@systemhub511 ~]# source /etc/profile
> ```
> 
> 6.运行Python
> 
> ``` python
> [root@systemhub511 ~]# python3
> Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)
> [Clang 6.0 (clang-600.0.57)] on darwin
> Type "help", "copyright", "credits" or "license" for more information.
> >>> print ("Hello, world!")
> Hello, world!
> >>> 
> ```

### 5.3 Python For Mac OS
> 如果你正在使用Mac, 系统是OS X>=10.9, 系统则自带的Python版本是2.7, 要安装最新的Python 3.8.1, 有两个方法：
> 
> 方法一：在Python官网下载Python 3.8.1安装程序,  [点击下载 Python 3.8.1 For macOS 64-bit installer](https://www.python.org/ftp/python/3.8.1/python-3.8.1-macosx10.9.pkg), 下载后双击运行并安装.
> 
> 方法二：如果安装了[Homebrew](https://brew.sh/)，直接通过命令```brew install python3```安装即可.
> 
> 按照上述方法完成安装, (可以通过命令行窗口进入python并开在交互式解释器中开始编写Python代码), 运行Python3
> ``` python
> systemhub:~ system$ python3
> Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)
> [Clang 6.0 (clang-600.0.57)] on darwin
> Type "help", "copyright", "credits" or "license" for more information.
> >>> print ("Hello, world!")
> Hello, world!
> >>> 
```

### 5.4 Python For Windows
> 首先根据你的Windows版本(64位或32位), 在Python官网下载Python 3.8.1安装64位程序,  [点击下载 Python 3.8.1 For Windows x86-64 executable installer](https://www.python.org/ftp/python/3.8.1/python-3.8.1-amd64.exe), 下载后, 特别要注意勾上`Add Python 3.8 to PATH`，然后点“Install Now”即可完成安装.
> 
> ![enter image description here](https://www.liaoxuefeng.com/files/attachments/1048401552601344/l)
> 
> 在Windows上运行Python时, 请先启动命令行, 然后运行python


### 5.4 Download Python IDE For PyCharm
> 集成开发环境 (IDE：Integrated Development Environment) : Python IDE For PyCharm
> 
> PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统.
> 
> PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制.
> 
> [PyCharm Download : www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)
> 
> ![enter image description here](https://www.jetbrains.com/pycharm/img/screenshots/complexLook@2x.jpg)



## 💥 6. Python 基本语法 注意事项 💥
> 1.在Python中严格区分字母大小写.
> 
> 2.Python中每一行就是一条语句, 每条语句以换行结束.
> 
> 3.Python中每一行语句不要过长 (规范中建议每行不要超过80个字符).
> 
> 4.一条语句可以分多行编写, 多行编写时语句后以```\```反斜杠结尾.
> 
> 5.Python是缩进严格的语言, 所以在Python中不要随便写缩进.
> 
> 6.在Python中使用`#`表示注释,`#`后的内容都属于注释, 注释的内容将会被解释器所忽略.
> 
> `Python 基础篇 - 基本语法`
> ``` py
> # -*- coding:utf-8 -*-
> #
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 基本语法 | Basic grammar
> # @File : 01_BasicGrammar.py
> # @Description : Python 基础篇 - 基本语法 | Python Basics-Basic Syntax
> 
> # 01 即表示注释 | Means comment
> 
> # 02 print 打印语句 Hello, World! | print statement Hello, World!
> print('Hello, World!')
> 
> # 03 当前`\`表示换行 | Current `\` means line break
> print('当前\
> 表示换行')
> ```


## 💥 7. Python 基础篇 💥
### 7.1 Python 常量 & 变量 & 标识符 & 命名规范
#### 7.1.1 `常量`
> 所谓常量就是不能变的变量, 比如常用的数学常数π就是一个常量.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 常量 & 变量 | Constants & variables
> # @File : 02_constant_variable.py
> # @Description : Python 基础篇 - 常量 & 变量 | Python Basics-Constants & Variables
> 
> # 定义常量 | Defining constants
> print(16)
> 
> # 常量演示 | Constant demo
> print('Name is Jack')
> ```
    

#### 7.1.2 `变量`
> 变量不仅可以是数字，还可以是任意数据类型, 变量在程序中就是用一个变量名表示, 变量名必须是`大小写英文`、`数字`和`_`下划线的组合, 且不能用数字开头.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 常量 & 变量 | Constants & variables
> # @File : 02_constant_variable.py
> # @Description : Python 基础篇 - 常量 & 变量 | Python Basics-Constants & Variables
> 
> # 定义变量 | Defining variables
> name = 'Jack'
> print(name)
> 
> # 变量演示 | Variables demo
> number = 16
> print(number * number)
> ```


#### 7.1.3 `标识符 & 命名规范`
> 在Python中所有可以自主命名的内容(变量名、函数名、类名)都属于标识符.
> `标识符规范` : 可以含有`字母`、`数字`、`_`、但是不能使用数字开头且不能使用Python中的`关键字`和`保留字`.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 标识符 & 命名规范 | Identifiers & naming conventions
> # @File : 03_Identifier_naming_convention.py
> # @Description : Python 基础篇 - 标识符 & 命名规范 | Python Basics-Identifiers & Naming Conventions
> 
> # 定义 标识符 | Definition identifier
> 
> # 定义变量 | Defining variables
> person_name = 'Jerry'
> person_sex = 'man'
> person_age = 20
> 
> 
> # 定义函数 | Defining functions
> def persons_info(name, sex, age):
>     print("PersonName: " + name, ", PersonSex: " + sex, ", PersonAge:", age)
>     return
> 
> 
> # 调用函数 | call function
> persons_info(person_name, person_sex, person_age)
> ```
> 
> `命名规范`：在Python中遵循两种命名规范 : `下划线命名法`/ `帕斯卡命名法`
> 
> `下划线命名法` : 所有字母小写, 单词之间以_下划线分割.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 标识符 & 命名规范 | Identifiers & naming conventions
> # @File : 03_Identifier_naming_convention.py
> # @Description : Python 基础篇 - 标识符 & 命名规范 | Python Basics-Identifiers & Naming Conventions
> 
> # 定义 命名规范 | Definition Naming Convention
> # 定义 下划线命名法 | Defining Underscore nomenclature
> def addition_calculation(num1, num2):
>     print("Result =", num1 + num2)
>     return
> 
> 
> # 调用函数 | call function
> addition_calculation(100, 100)
> ```
> `帕斯卡命名法` ：首字母大写, 每个单词开头字母大写, 其余字母小写.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 标识符 & 命名规范 | Identifiers & naming conventions
> # @File : 03_Identifier_naming_convention.py
> # @Description : Python 基础篇 - 标识符 & 命名规范 | Python Basics-Identifiers & Naming Conventions
> 
> # 定义 命名规范 | Definition Naming Convention
> # 定义 帕斯卡命名法 | Definition Pascal nomenclature
> def MultiplicationCalculation(num1, num2):
>     print("Result =", num1 * num2)
>     return
> 
> 
> # 调用函数 | call function
> MultiplicationCalculation(100, 100)
> ```


### 7.2 Python 数据类型
> 计算机顾名思义就是可以做数学计算的机器, 因此计算机程序理所当然地可以处理各种数值。但是计算机能处理的远不止数值, 还可以处理文本、图形、音频、视频、网页等各种各样的数据, 不同的数据需要定义不同的数据类型。
> 
> 在Python中能够直接处理的数据类型有以下几种 : 
#### 7.2.1 `整数`
> Python可以处理任意大小的整数, 当然包括负整数, 在程序中的表示方法和数学上的写法一模一样.
> 
> 计算机由于使用二进制, 所以有时候用十六进制表示整数比较方便, 十六进制用`0x`前缀和0-9，a-f表示, 例如: `0xff00`, `0xa5b4c3d2`等等.
> 
> ```
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 整数 | Definition integer
> object_widths = 18
> # 如果数字的长度过大, 可以使用下划线作为分隔符 | If the number is too long, you can use an underscore as a separator
> object_lengths = 18_15_16
> print(object_widths * object_lengths)
> ```

#### 7.2.2 `浮点数`
> 浮点数也就是小, 之所以称为浮点数, 是因为按照科学记数法表示时, 一个浮点数的小数点位置是可变的.
> 
> 整数和浮点数在计算机内部存储的方式是不同的, 整数运算永远是精确的, 而浮点数运算则可能会有四舍五入的误差.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 浮点数 | Definition Floating point
> assets = 5242414.455
> incomes = 500.36
> print(assets + incomes)
> ``` 


#### 7.2.3 `字符串` & `格式化`
> 字符串是以单引号`'`, 双引号`"`, 三重引号`'''`括起来的任意文本.
> 
> 在Python中采用的格式化方式和C语言是一致的, 用`%`占位符实现, 常见的占位符有：
> 
> `%d`表示用整数替换占位符 / `%f`表示用浮点数替换占位符
> 
> `%s`表示用字符串替换占位符 / `%x`表示用十六进制整数替换占位符
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 字符串 | Definition String
> # 定义 (单引号)修饰字符串 | Define (single quote) decorated strings
> saying = 'Le vent se lève, il faut tenter de vivre!\n'
> 
> # 定义 (双引号)修饰字符串 | Define (double quotes) decorated strings
> quotes = "A man who is artistic for art often gets the most pleasure from the least important and mundane image!\n"
> 
> # 定义 (单引号嵌套双引号)修饰字符串 | Define (single-quoted nested double-quoted) decorated strings
> talks = 'Arthur · Conan · Doyle: "Hard work creates talent!"\n'
> 
> # 定义 (三重引号)修饰长字符串 | Definition (triple quotes) to decorate long strings
> fragment = '''We must go deep into life, 
> Only then can you get novel effects and extraordinary cooperation, 
> And this in itself is more irritating than any imagination!'''
> 
> print(saying, quotes, talks, fragment)
> print("------------------------------------------------------\n")
> 
> # 定义 格式化 字符串 | Definition Format string
> # 使用加号拼接字符串 | Use plus sign to concatenate strings
> words = 'py' + 'thon'
> nums = 666
> print('words = ' + words)  # Output result: words = python
> # 多个参数 | Multiple parameters
> print('result = ', words, nums)  # Output result: result = 456
> print("------------------------------------------------------\n")
> 
> # 在字符串中指定占位符 | Specifying placeholders in strings
> word1 = 'odd_number= 135%s' % '7911'  # Output result: odd_number= 1357911
> word2 = 'even_number= 24%s810%s' % ('6', '12')  # Output result: even_number= 24681012
> word3 = 'assets= %.2f' % 555.456  # Output result: assets= 555.46
> word4 = 'assets=  %d' % 555.95  # Output result: assets=  555
> 
> # 通过`f`来创建格式化字符串 | Create a formatted string with `f`
> result = f'result= {word1} {word2}'  # Output result: result= odd_number= 1357911 even_number= 24681012
> print(word1, word2, word3, word4, result)
> print("------------------------------------------------------\n")
> 
> # 格式化 字符串综合练习 | Format string synthesis exercise
> word = 'py' + 'thon'
> print('人生苦短 ' + '快选 ' + word)
> print('人生苦短', '快选', word)
> print('人生苦短 快选 %s' % word)
> print(f'人生苦短 快选 {word}')
> print("------------------------------------------------------\n")
> 
> # 字符串 复制 (将字符串和数字相乘) | String copy (multiply strings and numbers)
> info = 'Learning!\t'
> info = info * 20
> print(info)
> print("------------------------------------------------------\n")
> ``` 


#### 7.2.4 `转义字符`
> 转义字符`\`可以转义很多字符, 比如`\n`表示换行, `\t`表示制表符, 字符`\`本身也要转义, 所以`\\`表示的字符就是`\`.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 转义字符 | Definition escape character
> talk = 'Arthur · Conan · Doyle:\t "Hard work creates talent!\\"\n'
> print(talk)
> print("------------------------------------------------------\n")
> ``` 

#### 7.2.5 `布尔值`
> 布尔值和布尔代数的表示完全一致, 一个布尔值只有`True`、`False`两种值, 要么是True, 要么是False.
> 
> 在Python中可以直接用`True`、`False`表示布尔值 (请注意大小写).
> 
> 布尔值可以用`and`、`or`和`not`运算,
> `and`运算是与运算, 只有所有条件都为`True`, `and`运算结果才是`True`.
> `or`运算是或运算, 只要其中有一个条件为`True`, `or`运算结果就是`True`.
> `not`运算是非运算, 它是一个单目运算符, 把`True`变成`False`, `False`变成`True`.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 布尔值 | Definition Boolean value
> print('True=', True)  # Output result: True
> print('False=', False)  # Output result: False
> print('3 > 2=', 3 > 2)  # Output result: True
> print('3 < 2=', 3 < 2)  # Output result: False
> 
> print('True and True=', True and True)  # Output result: True
> print('True and False=', True and False)  # Output result: False
> print('3 < 2 and 3 < 2=', 3 < 2 and 3 < 2)  # Output result: False
> 
> print('True or True=', True or True)  # Output result: True
> print('True or False=', True or False)  # Output result: True
> print('3 < 2 or 3 < 2=', 3 < 2 or 3 < 2)  # Output result: False
> 
> print('not True', not True)  # Output result: False
> print('not False', not False)  # Output result: True
> print('not 3 > 2', not 3 > 2)  # Output result: False
> 
> if 20 >= 18:
>     print('大于等于')
> else:
>     print('小于等于')
> 
> print("------------------------------------------------------\n")
> ``` 

#### 7.2.6 `空值`
> 空值是Python里一个特殊的值, 用`None`表示, `None`不能理解为`0`, 因为`0`是有意义的, 而`None`是一个特殊的空值.
> 
> 此外Python还提供了列表、字典等多种数据类型, 还允许创建自定义数据类型, 后面会继续讲到.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 定义 空值 | Definition Null value
> data = None
> print(data)
> print("------------------------------------------------------\n")
> ``` 

#### 7.2.7 `类型检查`
> 通过`type()`类型检查, 可以检查只能变量值类型, 该函数会将检查的结果作为返回值返回, 也可以通过变量来接收函数的返回值.
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据类型 | type of data
> # @File : 04_type_data.py
> # @Description : Python 基础篇 -  数据类型 | Python Fundamentals-Data Types
> 
> # 类型检查 | Type check
> values1 = 123456  # Output result: <class 'int'>
> values2 = '123456'  # Output result: <class 'str'>
> values3 = None  # Output result: <class 'NoneType'>
> values4 = True  # Output result: <class 'bool'>
> values5 = 555.456  # Output result: <class 'float'>
> print(type(values1), type(values2), type(values3), type(values4), type(values5))
> ``` 




### 7.3 Python 对象
> Python是一门面向对象的编程语言, 所以一切皆对象!
> 
> 程序运行当中所有数据都是存储到内存当中然后再运行.
> 
> 对象就是内存中专门用来存储指定数据的一块区域.

#### 7.3.1 对象的结构
> 每个对象中都要保存三种数据`id` / `type` / `value`
> 
> `id (标识)`:  id用来标识对象的唯一性, 每一个对象都有唯一的id, 对象一旦创建则它的id永远不能再改变.
> 
> `type (类型)`: 类型用来标识当前对象所属的类型, 类型决定了对象有哪些功能, 通过type()函数来查看对象的类型.
> 
> ` value (值)`: 值就是对象中存储的具体的数据, 对象分成两大类: `可变对象` /  `不可变对象`.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 对象结构 | Object structure
> # @File : 05_object_structure.py
> # @Description : Python 基础篇 -  对象结构 | Python Basics-Object Structure
> 
> # 对象结构 | Object structure
> object_structure = '13579'
> print('id=', id(object_structure))
> print('type=', type(object_structure))
> print('value=', object_structure)
> ```

### 7.4 Python 变量和对象
> 对象并没有直接存储到变量中, 在Python中变量更像是给对象起了一个别名.
> 
> 变量中存储的不是对象的值, 而是对象的id(内存地址).
> 
> 当使用变量时, 实际上就是在通过对象id在查找对象.
> 
> 变量中保存的对象, 只有在为变量重新赋值时才会改变.
> 
> 变量和变量之间是相互独立的，修改一个变量不会影响另一个变量.


### 7.5 Python 类型转换
> 所谓的类型转换, 将一个类型的对象转换为其他对象.
> 
> 类型转换不是改变对象本身的类型, 而是根据当前对象的值创建一个新对象.
> 
> 类型转换分为四个函数:  `int()`/ `float()` / `str()` / `bool()`
> 
> `int()`可以用来将其他的对象转换为整型.
> 
> `float()`和`int()`基本一致, 不同的是它会将对象转换为浮点数.
> 
> `str()`可以将对象转换为字符串.
> 
> `bool()`可以将对象转换为布尔值, 任何对象都可以转换为布尔值.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 类型转换 | Type conversion
> # @File : 06_type_conversion.py
> # @Description : Python 基础篇 - 类型转换 | Python Basics-Type Conversion
> 
> # 类型转换 | Type conversion
> data = '13579'
> data = int(data)
> data = float(data)
> data = str(data)
> data = bool(data)
> 
> print('id=', id(data))
> print('type=', type(data))
> print('value=', data)
> ```

### 7.6 Python 运算符(操作符)
> 运算符可以对一个值或多个值进行运算或各种操作.
> 
> 运算符的分类: ```算术运算符``` / ```赋值运算符``` / ```关系运算符``` / ```逻辑运算符``` / ```条件运算符```.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 运算符 | Operator
> # @File : 07_operator.py
> # @Description : Python 基础篇 - 运算符 | Python Fundamentals-Operators
> 
> # 运算符 | Operator
> 
> # 算术运算符 | Arithmetic operator
> # (`+` 加法运算符) | (`-` 减法运算符) | (`*` 乘法运算符) | (`**` 幂运算) | (`/` 除法运算符) | (`//` 整除运算符) | (`%` 取余运算符)
> nums = ((12 + 12 - 10) * 12) // 2
> print('result=', nums)
> 
> # 赋值运算符 | Assignment operator
> # (`=` 将等号右侧值赋给等号左侧变量) | (`+=` 等价于 `x = x + 1`) | (`-=` 等价于 `x = x - 1`) | (`*=` 等价于 `x = x * 1`)
> # (`**=` 等价于 `x = x ** 1`) | (`/=` 等价于 `x = x / 1`) | (`//=` 等价于 `x = x // 1`) | (`%=` 等价于 `x = x % 1`)
> nums1 = 1
> nums1 += 100
> nums1 -= 1
> nums1 *= 1
> nums1 **= 2
> nums1 /= 10
> nums1 //= 16
> nums1 %= 12
> print('result=', nums1)
> 
> # 关系运算符 | Relational operator
> # (`>` 大于运算符) | (`>=` 大于等于运算符) | (`<` 小于运算符) | (`<=` 小于运算符)
> # (`==` 等于运算符) | (`!=` 不等于运算符) | (`is` 比较两个对象是否是同一对象) | (`is not` 比较两个对象是否不是同一对象)
> nums2 = 10 > 20
> nums2 = 10 >= 20
> nums2 = 10 < 20
> nums2 = 10 <= 20
> nums2 = '10' == '20'
> nums2 = '10' != '20'
> print('result=', nums2)
> 
> # 逻辑运算符 | Logical Operators
> # (`not` 逻辑非) | (`and` 逻辑与) | (`or` 逻辑或) |
> nums3 = True
> # not可以对符号右侧的值进行非运算, 对于布尔值非运算会对其进行取反操作, True变False, False变True, 对于非布尔值非运算会先将其转换为布尔值然后再取反
> nums3 = not nums3
> # and可以对符号两侧的值进行与运算, 只有在符号两侧的值都为True时才会返回True, 只要有一个False就返回False
> nums3 = True and True
> nums3 = True and False
> # or可以对符号两侧的值进行或运算, 或运算两个值中只要有一个True就会返回True
> nums3 = True or True
> nums3 = True or False
> print(nums3)
> 
> # 非布尔值的与或运算
> # 与运算, 如果第一个值是False则直接返回第一个值, 否则返回第二个值
> nums4 = 1 and 2
> nums4 = 1 and 0
> nums4 = 0 and 1
> nums4 = 0 and None
> print(nums4)
> 
> # 或运算, 如果第一个值是True则直接返回第一个值, 否则返回第二个值
> nums5 = 1 or 2
> nums5 = 1 or 0
> nums5 = 0 or 1
> nums5 = 0 or None
> print(nums5)
> 
> # 条件运算符 | Conditional operator
> # 语法: 语句一 if 条件表达式 else 语句二
> # 执行流程:  条件运算符在执行时会先对条件表达式进行求值判断, 如果判断结果为True则执行语句一并返回执行结果, 如果判断结果为False则执行语句二并返回执行结果
> if 20 > 18:
>     print('大于等于')
> else:
>     print('小于等于')
> 
> nums6 = 50
> nums7 = 60
> nums8 = 10
> mins = nums6 if (nums6 < nums7 and nums6 < nums8) else (nums7 if nums7 < nums8 else nums8)
> print('min=', mins)
> ```


#### 7.6.1 Python 运算符优先级
> 从最高到最低优先级的所有运算符
| 运算符      |     描述 |
| :--------: | :--------:|
| `**`    |   指数(最高优先级) |
| `~ + -`    |   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |
| `* / % //`    |   乘，除，取模和取整除 |
| `+ -`    |   加法减法 |
| `>> <<`    |   右移，左移运算符 |
| `&`    |   位 'AND' |
| `^`    |   位运算符 |
| `<= < > >=`    |   比较运算符 |
| `<> == !=`    |   等于运算符 |
| `= %= /= //= -= += *= **=`    |   赋值运算符 |
| `is is not`    |   	身份运算符 |
| `in not in`    |   成员运算符 |
| `not and or`    |   逻辑运算符 |



### 7.7 Python 流程控制语句
> Python代码在执行时是按照自上向下顺序执行.
> 
> 通过流程控制语句, 可以改变程序的执行顺序, 也可以让指定的程序反复执行多次.
> 
> 流程控制语句分成两大类：`条件判断语句` / `循环语句`


#### 7.7.1 条件判断语句
> ``` python 
> 语法：if 条件表达式 : 
>             代码块
> ```
> 
> 执行的流程: if语句在执行时会先对条件表达式进行求值判断.
> 
>  如果为True则执行if后的语句, 如果为False则不执行.
>  
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 流程控制 | Process control
> # @File : 08_process_control.py
> # @Description : Python 基础篇 - 流程控制 | Python Basics - Process control
> 
> # 流程控制 | Process control
> 
> # 定义 条件判断语句 | Definition Conditional Judgment
> if True:
>     print("Output_1")
>     print("Output_2")
>     print("Output_3")
> 
> 
> # 定义 身份验证函数 | Define authentication function
> def verification(user_name_input, user_password_input, user_token_input):
>     # print('\nPlease enter UserName....')
>     if user_name_input == 'system' or user_name_input == 'System':
>         print('‖-------------------------------------------------‖')
>         print('\n‖ Username Verification Successful !', user_name_input, '..... ‖\n')
>         print('‖-------------------------------------------------‖\n')
>         # print('\nPlease enter Password....\n')
>         if user_password_input == 'xxx':
>             print('‖-------------------------------------------------‖')
>             print('\n‖ Password Verification Successful', user_name_input, '..... ‖\n')
>             print('‖-------------------------------------------------‖')
>             # print('\nPlease enter Token....\n')
>             if user_token_input == '000000':
>                 print('‖-------------------------------------------------‖')
>                 print('\n‖ Token Verification Successful, Welcome', user_name_input, '! ‖\n')
>                 print('‖-------------------------------------------------‖')
>             else:
>                 print('\n', user_token_input, 'Token Error!')
>         else:
>             print('\n', user_password_input, 'Password Error!')
>     else:
>         print('\n', user_name_input, 'UserName Error!')
> 
> 
> # 定义 参数 | Definition parameter
> name = input('\nPlease enter UserName....\n')
> password = input('\nPlease enter Password....\n')
> token = input('\nPlease enter Token....\n')
> 
> # 调用 身份验证函数 | Transfer authentication function
> verification(name, password, token)
> ```

#### 7.7.2 循环语句
> 循环语句可以使指定的代码块重复指定的次数.
> 
> 循环类型分为三种: `while循环` /  `for循环` / `循环嵌套`.
> 
> 在Python 中没有`do..while`循环.

##### 7.7.2.1 while循环
> while循环 语法：
> 
> ``` python
> while 判断条件(condition)：
>     执行语句(statements)……
> ```
##### 7.7.2.2 for循环
> for循环 语法：
> 
> ``` python
> for iterating_var in sequence:
>    statements(s)
> ```

##### 7.7.2.3 循环嵌套
> Python while 循环嵌套语法：
> ``` python
> while expression:
>   while expression:
>      statement(s)
>   statement(s)
> ```
> 
> Python for 循环嵌套语法
> ``` python
> for iterating_var in sequence:
>    for iterating_var in sequence:
>       statements(s)
>    statements(s)
> ```

##### 7.7.2.4 循环控制语句
> 循环控制语句可以更改语句执行的顺序, Python支持以下循环控制语句:
| 控制语句      |     描述 |
| :-------- | --------:|
| `break 语句`    |   在语句块执行过程中终止循环, 并且跳出整个循环. |
| `continue 语句`    |   在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环. |
| `pass 语句`    |   pass是空语句，是为了保持程序结构的完整性. |

> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 流程控制 | Process control
> # @File : 08_process_control.py
> # @Description : Python 基础篇 - 流程控制 | Python Basics - Process control
> 
> # 流程控制 | Process control
> 
> # 定义 循环语句 | Definition loop statement
> # while循环 | while loop
> x = 0
> while x < 10:
>     print(x, 'Life is short, choose python quickly！')
>     x += 1
> else:
>     print('End\n')
> 
> # for循环 | for loop
> fruits = ['banana', 'apple', 'mango']
> for fruit in fruits:  # 第二个实例
>     print('当前水果 :', fruit)
> print('Good bye!\n')
> 
> # 循环嵌套 | Loop nesting
> i = 0
> while i < 9:
>     i += 1
>     j = 0
>     while j < i:
>         j += 1
>         print(f"{j} * {i} = {i * j}\t", end=' ')
>     print()
> ```


### 7.8 Python 数据结构 集合
> 序列是Python中最基本的数据结构, 序列中的每个元素都分配一个数字 - 它的位置或索引, 第一个索引是0, 第二个索引是1,依此类推, 列表的索引也可以是负数,如果索引是负数, 则从后向前获取元素, -1表示倒数第一个, -2表示倒数第二个以此类推.
> 
> Python有6个序列的内置类型, 但最常见的是列表和元组.
> 
> 序列都可以进行的操作包括索引, 切片, 加, 乘, 检查成员.

#### 7.8.1 列表 (list)
> 列表是最常用的Python数据类型, 它可以作为一个方括号内的逗号分隔值出现.
> 
> 列表中可以保存多个有序的数据, 列表是用来存储对象的对象.
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 列表 | Definition list
> list1 = [1, 2, 3, 4, 5]
> 
> # 获取列表元素长度 | Get list element length
> print('lens=', len(list1))
> 
> # 访问列表中的值 | Access value in list
> print(list1[1])
> 
> # 更新列表 | update list
> list1.append(6)
> 
> # 向列表指定位置插入元素 | Insert an element at a specified position in the list
> list1.insert(3, 7)
> 
> # 使用新的序列扩展当前序列 | Extend current sequence with new sequence
> list1.extend([8, 9])
> 
> # 定义 迭代列表元素 | Definition iteration
> for data in list1:
>     print('data=', data)
> 
> # 删除列表元素 | Remove list element
> del list1[2]
> 
> # 根据索引删除指定元素并返回被删除元素的值 | Deletes the specified element based on the index and returns the value of the deleted element
> delete_value = list1.pop(3)
> print('delete_value=', delete_value)
> 
> # 根据指定元素删除元素值 | Delete element value based on specified element
> list1.remove(5)
> 
> # 将列表元素反转 | Reverse list element
> list1.reverse()
> 
> # 对列表元素进行排序,默认为升序排序 | Sort list elements, default is ascending
> list1.sort()
> list1.sort(reverse=True)
> 
> # 清空列表 | clear the list
> list1.clear()
> 
> print('list1=', list1)
> ```

##### 7.8.1.1 `列表 切片`
> 切片指从现有列表中获取一个子列表.
> 
>  切片语法1：`list[起始:结束]`
>  通过切片获取元素时会包括起始位置的元素, 不会包括结束位置的元素.
>  
>  切片语法2: `list[起始:结束:步长]`
>  步长表示每次获取元素的间隔，默认值是1, 步长不能是0但是可以是负数.
>  
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 列表 | Definition list
> list1 = [1, 2, 3, 4, 5]
> # 定义 列表切片 | Definition list slice
> # 如果省略结束位置则会一直截取到最后 | If the end position is omitted, it will be intercepted to the end.
> print('list1[1:]: ', list1[1:])
> # 如果省略起始位置则会从第一个元素开始截取 | If the starting position is omitted, it will be truncated from the first element
> print('list1[:3]: ', list1[:3])
> # 如果起始位置和结束位置全部省略则相当于创建一个列表的副本
> print('list1[:]: ', list1[:])
> # 通过切片获取元素时会包括起始位置的元素,不会包括结束位置的元素
> print('list1[1:5]: ', list1[1:5])
> # 定义 步长 | Definition Stride
> print('list1[1:4:1]: ', list1[1:4:1])
> print('list1[::1]: ', list1[::-1])
> ```

##### 7.8.1.2 `列表 脚本操作符`
> 列表对 `+` 和 `*` 的操作符与字符串相似, `+` 号用于组合列表, `*` 号用于重复列表.
| Python 表达式      |     	结果 |   描述   |
| :--------: | :--------:| :------: |
| `len([1, 2, 3])`    |   3 |  长度  |
| `[1, 2, 3] + [4, 5, 6]`    |   [1, 2, 3, 4, 5, 6] |  组合  |
| `['Hi!'] * 4`    |   ['Hi!', 'Hi!', 'Hi!', 'Hi!'] |  重复  |
| `3 in [1, 2, 3]` and `3 not in [1, 2, 3]`    |   True / False |  元素是否存在于列表中  |
| `for x in [1, 2, 3]: print x,`    |   1 2 3 |  迭代  |
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 列表 | Definition list
> list2 = [1, 2, 3, 4, 5, 6]
> list3 = ['C', 'C++', 'C#', 'Html', 'Java', 'PHP', 'Python', 'Scala', 'GoLang', 'R', 'Ruby', 'SQL']
> 
> # 定义 元素是否存在于列表中 | Defines whether the element exists in the list
> print('Python' in list3)
> print('Python' not in list3)
> 
> # 定义 迭代 | Definition iteration
> for data in list3:
>     print('data=', data)
> 
> # 定义 组合列表 | Definition Combination list
> list2 = [1, 2, 3, 4, 5, 6] + [7, 8, 9, 10, 11]
> 
> # 定义 重复列表 | Definition repeat list
> list3 = list3 * 4
> 
> # 获取列表长度 | Get list length
> print('list2 length=', len(list2))
> print('list3 length=', len(list3))
> ```


##### 7.8.1.3 `列表 内置函数 & 方法`
> 方法和函数基本上是一样, 只不过方法必须通过`object.方法()`的形式调用.
> 
> Python包含以下函数:
| 序号      |     函数 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `cmp(list1, list2)` |  比较两个列表的元素  |
| 2    |   `len(list)` |  列表元素个数  |
| 3    |   `max(list)` |  返回列表元素最大值  |
| 4    |   `min(list)` |  返回列表元素最小值  |
| 5    |   `list(seq)` |  将元组转换为列表  |

> Python包含以下方法:
| 序号      |     方法 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `lists.append(obj)` |  在列表末尾添加新的对象  |
| 2    |   `lists.count(obj)` |  统计某个元素在列表中出现的次数  |
| 3    |   `lists.extend(seq)` |  在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）  |
| 4    |   `lists.index(obj)` |  从列表中找出某个值第一个匹配项的索引位置  |
| 5    |   `lists.insert(index, obj)` |  将对象插入列表  |
| 6    |   `lists.pop([index=-1])` |  移除列表中的一个元素（默认最后一个元素），并且返回该元素的值  |
| 7    |   `lists.remove(obj)` |  移除列表中某个值的第一个匹配项  |
| 8    |   `lists.reverse()` |  反向列表中元素  |
| 9    |   `lists.sort(cmp=None, key=None, reverse=False)` |  对原列表进行排序  |


#### 7.8.2 序列 (seq)
> 序列是Python中最基本的一种数据结构, 数据结构指计算机中数据存储的方式.
> 
> 序列用于保存一组有序的数据, 所有的数据在序列当中都有一个唯一的位置(索引).并且序列中的数据会按照添加的顺序来分配索引.
> 
> 序列的分类 : 
> 
> `可变序列`[序列中的元素可以改变] : `列表(list)`
> 
> `不可变序列`[序列中的元素不能改变]: `字符串(str)` `元组(tuple)`


#### 7.8.3 range
>  range()是一个函数, 可以用来生成一个自然数的序列.
>  
>  range语法: 该函数需要三个参数  1.`起始位置(可以省略,默认是0)` | 2.`结束位置` | 3.`步长(可以省略,默认是1)`
>  
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义ragne() 生成自然数的序列函数 | Definition ragne() Sequence > function to generate natural numbers
> r1 = range(5)
> r2 = range(0, 10, 2)
> 
> print('r1=', r1, list(r1))
> print('r2=', r2, list(r2))
> 
> for x in range(60):
>     print('r3 =', x)
> ```

#### 7.8.4 元祖 (tuple)
> Python的元组与列表类似, 不同之处在于元组的元素不能修改, 即含义为元组是一个不可变的序列.
> 
> 元组使用`()`小括号, 列表使用`[]`方括号.
> 
> 元组创建很简单, 只需要在括号中添加元素, 并使用逗号隔开即可.
> 
> ```元组运算符```: 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组.
| Python 表达式      |     	结果 |   描述   |
| :--------: | :--------:| :------: |
| `len([1, 2, 3])`    |   3 |  长度  |
| `[1, 2, 3] + [4, 5, 6]`    |   [1, 2, 3, 4, 5, 6] |  组合  |
| `['Hi!'] * 4`    |   ['Hi!', 'Hi!', 'Hi!', 'Hi!'] |  重复  |
| `3 in [1, 2, 3]` and `3 not in [1, 2, 3]`    |   True / False |  元素是否存在于列表中  |
| `for x in [1, 2, 3]: print x,`    |   1 2 3 |  迭代  |

> ```元组索引截取```: 因为元组也是一个序列, 所以可以访问元组中的指定位置的元素, 也可以截取索引中的一段元素.
| Python 表达式      |     结果 |   描述   |
| :--------: | :--------:| :------: |
| `L[2]`    |   	'SPAM!' |  读取第三个元素  |
| `L[-2]`    |   	'Spam' |  反向读取，读取倒数第二个元素  |
| `L[1:]`    |   ('Spam', 'SPAM!') |  截取元素  |

> ```元组内置函数```: 
| 序号      |     函数 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `cmp(list1, list2)` |  比较两个列表的元素  |
| 2    |   `len(list)` |  列表元素个数  |
| 3    |   `max(list)` |  返回列表元素最大值  |
| 4    |   `min(list)` |  返回列表元素最小值  |
| 5    |   `tuple(seq)` |  将列表转换为元组  |

> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 元祖 | Definition Tuple
> # 创建元祖 | Create Tuple
> tuples1 = (1, 2, 3, 4, 5, 6, 7, 8)
> # 创建 无关闭分隔符 元祖 | Created without closing separator
> tuples2 = 1, 2, 3, 4, 5, 6, 7, 8
> 
> # 定义 元祖解包 将元祖中每一个元素赋值给每一个变量
> a, b, c, d, e, f, g, h = tuples2
> a, b, *c = tuples1
> print('a=', a)
> print('b=', b)
> print('c=', c)
> print('d=', d)
> print('e=', e)
> print('f=', f)
> print('g=', g)
> print('h=', h)
> 
> # 修改元组 | Modify tuple
> tuples3 = 9, 10, 11
> tuples4 = tuples2 + tuples3
> print('tuples4=', tuples4)
> 
> # 删除元组 | Delete tuple
> del tuples4
> 
> # 访问元组 | Access tuple
> print('tuples1[0]=', tuples1[0])
> print('tuples2[0:5]=', tuples2[0:5])
> print('tuples2=', tuples2)
> ```


#### 7.8.5 字典 (dict)
> 字典属于一种新的数据结构称为映射mapping, 字典是另一种可变容器模型且可存储任意类型对象.
> 
> 字典的每个键值`key=>value`对用冒号`:`分割, 每个键值对之间用逗号`,`分割, 整个字典包括在花括号`{}`中.

##### 7.8.5.1 `字典 内置函数 & 方法`
> Python中字典包含了以下内置函数: 
| 序号      |     函数名 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `cmp(dict1, dict2)` |  比较两个字典元素  |
| 2    |   `len(dict)` |  计算字典元素个数，即键的总数  |
| 3    |   `str(dict)` |  输出字典可打印的字符串表示  |
| 4    |   `type(variable)` |  返回输入的变量类型，如果变量是字典就返回字典类型  |

> Python中字典包含了以下内置方法: 
| 序号      |     方法名 |   描述   |
| :--------: | :--------:| :------: |
| 1    |   `dict.clear()` |  删除字典内所有元素  |
| 2    |   `dict.copy()` |  返回一个字典的浅复制  |
| 3    |   `dict.fromkeys(seq[, val])` |  创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值  |
| 4    |   `dict.get(key, default=None)` |  返回指定键的值，如果值不在字典中返回default值  |
| 5    |   `dict.has_key(key)` |  如果键在字典dict里返回true，否则返回false  |
| 6    |   `dict.items()` |  以列表返回可遍历的(键, 值) 元组数组  |
| 7    |   `dict.keys()` |  以列表返回一个字典所有的键  |
| 8    |   `dict.setdefault(key, default=None)` |  和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default  |
| 9    |   `dict.update(dict2)` |  把字典dict2的键/值对更新到dict里  |
| 10    |   `dict.values()` |  以列表返回字典中的所有值  |
| 11    |   `pop(key[,default])` |  删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值  |
| 12    |   popitem() |  返回并删除字典中的最后一对键和值  |

> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 字典 | Definition dictionary
> # 创建 字典 | Create dictionary
> d1 = {'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E', 'f': 'F', 'g': 'G', 'h': 'H'}
> d2 = dict([('a', 'A'), ('b', 'B'), ('c', 'C'), ('d', 'D'), ('e', 'E'), ('f', 'F'), ('g', 'G'), ('h', 'H')])
> d3 = {'j': 'J', 'k': 'K', 'l': 'L'}
> # 获取字典中键值对个数 | Get the number of key-value pairs in the dictionary
> print('d1_len=', len(d1))
> 
> # 访问字典中的值 | Accessing values ​​in a dictionary
> print("d1['b']=", d1['b'])
> 
> # 通过方法访问字典中的值 | Accessing values ​​in a dictionary via methods
> print("d1.get('b')=", d1.get('b'))
> print("d1.get('j')=", d1.get('j', 'defaults'))
> 
> # 修改字典 | Modify dictionary
> d1['h'] = 'h'
> d1.setdefault('g', 'G')
> d1.setdefault('i', 'I')
> d1.update(d3)
> print('d1=', d1)
> 
> # 删除字典元素 | Delete dictionary element
> del d1['a']
> d1.popitem()
> d1.pop('f')
> print("d1.pop('z')", d1.pop('z', 'defaults'))
> print('d1=', d1)
> d2.clear()
> print('d2=', d2)
> 
> # 字典浅复制 | Dictionary shallow copy
> d4 = {'m': 'M', 'n': 'N', 'o': 'O', 'p': 'P', 'q': 'Q'}
> # 复制后的对象和原对象是完全独立的, 两个对象之间的变化不会影响
> d5 = d4.copy()
> print('d4=', d4, 'd4_id=', id(d4))
> print('d5=', d5, 'd5_id=', id(d5))
> 
> # 遍历 字典 | Traversal dictionary
> # 调用keys()方法, 该方法将返回一个序列, 该序列中保存字典中所有的键
> for k1 in d4.keys():
>     print('key=', k1, 'value=', d4[k1])
> 
> # 调用values()方法, 该方法将返回一个序列, 该序列中保存字典中所有的值
> for v1 in d4.values():
>     print('v1=', v1)
> 
> # 调用items()方法, 该方法会返回一个(字典中所有项)的序列, 序列中包含双值子序列
> for k2, v2 in d4.items():
>     print('res=', k2, '=>', v2)
> ```

#### 7.8.6 集合 (set)
> 集合和列表非常相似, 集合不同点在于: 
> 
> `1.集合中只能存储不可变对象` / `2.集合中存储的对象是无序(不是按照元素的插入顺序保存)` / `3.集合中不能出现重复的元素`
> 
> ``` python
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据结构集合 | Data structure collection
> # @File : 09_data_structure_collection.py
> # @Description : Python 基础篇 - 流程控制 | 数据结构集合 | Python Basics-Flow Control | Data Structure Collection
> 
> # 定义 集合 | Definition collection
> # 创建 集合 | Create collection
> s1 = set()  # 定义 空set集合 | Definition empty set collection
> s2 = {'a', 'c', 'd', 'r', 'g', 'p'}
> s3 = set([1, 2, 5, 6, 8])  # 调用set()方法将列表转换为集合
> s4 = set([(1, 2, 3, 4), (6, 8, 7, 10)])  # 调用set()方法将元祖转换为集合
> s5 = set({'a': 'A', 'b': 'B', 'c': 'C'})  # 调用set()方法将字典转换为集合, 但包含字典中的键
> s6 = set('Python')  # 调用set()方法将字符串转换为集合
> 
> print('s1=', s1, '\t s2=', s2)
> print('s3=', s3, '\t s4=', s4)
> print('s5=', s5, '\t s6=', s6)
> 
> # 获取集合元素个数 | Get the number of collection elements
> print('len(s5)=', len(s5))
> 
> # 检查集合中的指定元素 | Check specified element in collection
> print('d' in s5)
> 
> # 向集合中添加元素 | Add elements to the collection
> s2.add('k')
> s2.update(s4)
> s2.update(s5)
> s2.update(s6)
> print('s2=', s2)
> 
> # 删除集合 | Remove collections and elements
> # 随机删除集合元素 | Remove collection elements randomly
> s5.pop()
> print('s5=', s5)
> 
> # 指定删除集合元素 | Specifies to delete collection elements
> # s5.remove('a')
> print('s5=', s5)
> 
> # 清空集合所有元素 | Clear all elements of the collection
> s6.clear()
> print('s6=', s6)
> 
> # 集合 浅复制 | Collection shallow copy
> s7 = set([1, 2, 5, 6, 8])
> # 复制后的对象和原对象是完全独立的, 两个对象之间的变化不会影响
> s8 = s7.copy()
> print('s7=', s7, 's7_id=', id(s7))
> print('s8=', s8, 's8_id=', id(s8))
> 
> # 集合 运算 | Set operation
> s9 = {1, 2, 3, 4, 5}
> s10 = {1, 2, 3, 4, 5, 6, 7}
> 
> # `&` 交集运算 | `&` Intersection operation
> res1 = s9 & s10
> print('Intersection_Operation=', res1)  # Output result: Intersection_Operation= {3, 4, 5}
> 
> # `|` 并集运算 | `|` Union Set Operation
> res2 = s9 | s10
> print('Union_Set_Operation=', res2)  # Output result: Union_Set_Operation= {1, 2, 3, 4, 5, 6, 7}
> 
> # `-` 差集运算 | `-` Difference Set Operation
> res3 = s9 - s10
> print('Difference_Set_Operation=', res3)  # Output result: Difference_Set_Operation= {1, 2}
> 
> # `^` 异或集运算 | `^` XOR set operation
> res4 = s9 ^ s10
> print('XOR_Set_Operation=', res4)  # Output result: XOR_Set_Operation= {1, 2, 6, 7}
> 
> # `<=` 检查集合是否为另一个集合的子集 | `<=` Checks if a collection is a subset of another collection
> # 如果a集合中的元素全部在b集合中出现, 则a集合称之为b集合的子集, b集合即使a集合的超集
> collection_subset = s9 <= s10
> print('Collection_Subset=', collection_subset)  # Output result: Collection_Subset= True
> 
> # `<` 检查集合是否为另一个集合的真子集 | `<` Checks if a set is a true subset of another set
> # 如果超集b中含有子集a中的所有元素, 并且b中包含a中没有的元素则称之b为真超集, a是b的真子集
> res5 = {1, 2, 3} < {1, 2, 3, 4, 5}
> print('res5=', res5)  # res5= True
> 
> # `>=` 检查集合是否为另一个集合的超集 | `> =` Checks if a collection is a superset of another collection
> res6 = s9 >= s10
> print('res6=', res6)  # res6= False
> 
> # `>` 检查集合是否为另一个集合的真超集 | `>` Check if a collection is a true superset of another collection
> res7 = s9 > s10
> print('res7=', res7)  # res7= False
> ```

### 7.9 Python 函数
#### 7.9.1 函数 简介
> 函数是组织好的, 可重复使用的, 用来实现单一或相关联功能的代码段.
> 
> 函数能提高应用的模块性和代码的重复利用率, 已经知道Python提供了许多内建函数, 比如print(), 但你也可以自己创建函数, 这被叫做用户自定义函数.
> 
> **1.定义一个函数**
> 
> 你可以定义一个由自己想要功能的函数, 以下是简单的规则：
> 
> 函数代码块以`def`关键词开头, 后接函数标识符名称和圆括号`()`.
> 
> 任何传入参数和自变量必须放在圆括号中间, 圆括号之间可以用于定义参数.
> 
> 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明.
> 
> 函数内容以冒号起始, 并且缩进.
> 
> `return [表达式]` 结束函数, 选择性地返回一个值给调用方, 不带表达式的return相当于返回None.
> 
> **2.定义 函数 语法**
> 默认情况下, 参数值和参数名称是按函数声明中定义的顺序匹配起来的.
> ``` py
> def functionname( parameters ):
>    "函数_文档字符串"
>    function_suite
>    return [expression]
> ```
> **3.函数定义与调用**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> 
> # 定义函数 | Defining functions
> def functions():
>     print('\nI am a function !\n')
> 
> 
> # 调用函数 | call function
> functions()
> ```

#### 7.9.2 函数 参数 & 参数传递方式
> 在定义函数时可以在函数名后的()中定义数量不等的形参, 多个形参之间使用英文状态下的逗号`,`隔开.
> 
> `形参 (形式参数)` : 定义形参就相当于在函数内部声明了变量, 但是并不赋值.
> 
> `实参 (实际参数)`: 如果函数定义时指定了形参, 那么在调用函数时也必须传递实参, 实参将会赋值给对应的形参, 简单来，有几个形参就得传几个实参.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions1(num1, num2, num3=30):
>     print('res=', num1 * num2 * num3)
> 
> 
> # 调用函数 | call function
> functions1(10, 20)
> ```
> 
> **1.实参的传递方式**
> 
> `位置参数`: 位置参数就是将对应位置的实参复制给对应位置的形参, 第一个实参赋值给第一个形参, 第二个实参赋值给第二个形参以此类推. 例如: `functions1(10, 20)`
> 
> `关键字参数` : 可以不按照形参定义的顺序去传递, 而直接根据参数名去传递参数, 位置参数和关键字参数可以混合使用, 混合使用关键字和位置参数时，必须将位置参数写到前面. 例如: `functions1(10, 20, num3=30)`
> 
> **2.实参类型**
> 
>  函数在调用时解析器不会检查实参的类型, 实参可以传递任意类型的对象.
>  
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions2(num):
>     # 在函数中对形参进行重新赋值, 不会影响其他的变量
>     # a = 20
>     # num是一个列表尝试修改列表中的元素
>     # 如果形参执行的是一个对象，可以通过形参去修改对象时, 会影响到所有指向该对象的变量
>     num[0] = 30
>     print('num =', num, id(num))
> 
> values = 10
> values = [1, 2, 3]
> 
> # 调用函数 | call function
> functions2(values)
> functions2(values.copy())
> functions2(values[:])
> ```
> 
> **3.装包：不定长参数**
> 在定义函数时候,可以在形参前添加`*`星号, 这种定义的函数中的形参将会获取所有的实参, 它将所有的实参保存到元祖中.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> # `*num1` 将接受所为位置参数并且会将实参统一保存元祖中
> def functions3(*nums1):
>     print('nums1=', nums1, 'type=', type(nums1))
> 
> 
> # 调用函数 | call function
> functions3()
> functions3(1, 3, 5, 7, 9)
> 
> 
> # 定义函数 | Defining functions
> def functions4(*nums):
>     res = 0  # 定义初始化变量, 保存结果集
>     for data in nums:
>         res += data
>     print('res=', res)
> 
> 
> # 调用函数 | call function
> functions4(6)
> functions4(6, 6)
> functions4(6, 6, 6)
> functions4(6, 6, 6, 6)
> functions4(6, 6, 6, 6, 6)
> 
> 
> # 定义函数 | Defining functions
> # `**` 形参可以接收其他关键字参数, 它将这些参数保存在字典中
> # 字典中keys就是参数的名字, 字典中values就是参数的值
> def functions5(**nums):
>     print('**nums=', nums, 'type=', type(nums))
> 
> 
> # 调用函数 | call function
> functions5()
> ```
> 
> **4.参数解包**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions6(nums1, nums2, nums3):
>     print('sum=', nums1 + nums2 + nums3)
> 
> 
> # 定义 元祖 | Definition Tuple
> tuples = (10, 10, 10)
> # 调用函数 | call function
> # 传递参数时,可以在序列类型参数前添加`*`星号,这样称之为参数解包,会自动将序列中的元素依次作为参数传递
> functions6(*tuples)
> 
> 
> # 定义函数 | Defining functions
> def functions7(nums1, nums2, nums3):
>     print('nums1=', nums1, 'nums2=', nums2, 'nums3=', nums3)
> 
> 
> # 定义字典 | Definition Dictionary
> dictionary = {'nums1': '1', 'nums2': '2', 'nums3': '3'}
> # 调用函数 | call function
> # 通过`**`对字典进行解包操作
> functions7(**dictionary)
> ```


#### 7.9.3 返回值
> 返回值就是函数执行以后返回的结果.
> 
> 可以通过`return`关键字来指定函数的返回值.
> 
> 可以之间使用函数返回值,也可以通过变量来接收函数返回值.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 定义函数 | Defining functions
> def functions8():
>     return 100
> 
> 
> # 调用函数 | call function
> r = functions8()
> print('r=', r)
> 
> 
> # 定义函数 | Defining functions
> def functions9(*nums):
>     res = 0  # 定义初始化变量, 保存结果集
>     for data in nums:
>         res += data
>         return res
> 
> 
> # 调用函数 | call function
> r1 = functions9(10)
> print('r1=', r1 + 10)
> ```

#### 7.9.4 文档字符串 
> `help()`是python中的内置函数, 通过此函数可以查询python中的函数使用方法, 也称之为帮助文档.
> 
> 使用语法：`help(函数对象)`
> 
> 在自定义函数时, 可以在该函数内部定义文档字符串,等价于自定义函数说明.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 调用help函数
> help(print)  # 查询print函数使用方法
> help(dict)  # 查询dict函数使用方法
> help(map)  # 查询map函数使用方法
> 
> 
> def functions10(value1: int, value2: bool, value3: str = 'string') -> int:
>     '''
>     自定义函数 实例
> 
>     自定义函数 作用：
> 
>     自定义函数 参数：
>         `value1` 作用 / 类型 / 默认值 .....
>         `value2` 作用 / 类型 / 默认值 .....
>         `value3` 作用 / 类型 / 默认值 .....
>     '''
>     print('functions10')
> 
> 
> help(functions10)  # 查询自定义函数使用方法
> ```


#### 7.9.5 作用域 & 命名空间
> **1.作用域**：作用域是指变量生效的区域.
> 在python中作用域分为两种：`全局作用域` / `函数作用域`.
> 
> `全局作用域`：
> - 全局作用域在程序执行时创建, 在程序执行结束时销毁.
> - 所有函数意外的区域全都是全局作用域.
> - 在全局作用域中定义变量，都属于全局变量, 全局变量可以在程序任意位置被访问.
> 
> 
> `函数作用域`：
> - 函数作用域在函数调用时创建, 在调用结束后销毁.
> - 函数每一次调用时就会产生一个新的函数作用域.
> - 在函数作用域中定义变量都是局部变量, 只能在函数内部访问.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 作用域 | Scope
> # 定义变量 用于全局作用域 | Define variables for global scope
> variables = 10
> 
> 
> # 定义函数 | Defining functions
> def functions11():
>     '''
>     定义变量 用于局部作用域 | Define variables for local scope
>     `data2`变量定义在函数内部,所以它的作用域就是在函数内部,函数外部无法访问
>     :return:
>     '''
>     data2 = 10
>     global data1  # 声明`data1`在函数内部变量为全局变量
>     data1 = 10
> 
>     print('函数内部声明全局变量=', data1)
>     print('函数内部=', data2)
> 
> 
> print('函数外部=', variables)
> functions11()
> ```
> 
> **2.命名空间**：是指变量存储的位置, 每一个变量都需要存储到指定的命名空间当中.
> - 每一个作用域都会有自身对应的命名空间.
> - 全局命名空间用来保存全局变量, 函数命名空间用来保存函数中的变量.
> - 命名空间实际上就是字典, 是专门用来保存变量的字典.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 命名空间 | Namespaces
> '''
> `locals()`函数用来获取当前作用域的命名空间, 返回值类型是字典类型
> 如果在全局作用域中调用此函数则是获取全局命名空间
> 如果在函数作用域中调用次函数则是获取函数命名空间
> '''
> namespaces = locals()
> print('Namespaces=', namespaces, '\ntype=', type(namespaces))
> 
> 
> # 定义函数 | Defining functions
> def functions12():
>     '''
>     `globals()`函数可以用来在任意位置获取全局命名空间
>     '''
>     namespaces1 = globals()
>     print('Namespaces=', namespaces1, '\ntype=', type(namespaces1))
> 
> 
> # 调用函数 | call function
> functions12()
> ```


#### 7.9.6 递归
> 简单的说递归函数就是在函数中自己调用自己.
> 
> 递归是解决问题的一种方式, 整体思想是将一个大的问题分解为若干个小问题,直到问题无法分解时,在去解决问题.
> 
> 递归式函数分为两个条件：
> - 1.`基线条件`：问题可以分解为最小问题, 当满足基线条件时,递归就不再执行.
> - 2.`递归条件`：将问题继续分解条件.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 递归 | Recursive
> # 无穷递归: 如果此函数被调用时,容易导致程序内存溢出,效果类似于死循环
> def functions13():
>     functions13()
> 
> 
> # 定义 递归函数 | Defining Recursive functions
> # 求任意数字的阶乘 | Find the factorial of any number
> def functions14(num: int) -> int:
>     # 定义 基线条件: 判断num是否等于1, 如果等于1则不再进行递归调用
>     if num == 1:
>         return 1
>     else:
>         # 定义 递归条件：如果num=10则返回num*自身函数(num-1)的阶乘 => 10 * 9!
>         return num * functions14(num - 1)
> 
> 
> # 求任意数字的幂次方 | Find the power of any number
> def functions15(num1, num2):
>     # 定义 基线条件: 求1幂运算
>     if num2 == 1:
>         return num1
>     else:
>         # 定义 递归条件
>         return num1 * functions15(num1, num2 - 1)
> 
> 
> # 定义 检查回文 函数 | Definition check palindrome function
> def check_palindrome(string):
>     # 定义 基线条件
>     if len(string) < 2:
>         return True
>     elif string[0] != string[-1]:
>         return False
>     # 定义 递归条件
>     return check_palindrome(string[1: 1])
> 
> 
> # 调用函数 | call function
> print('functions14=', functions14(10))
> print('functions15=', functions15(8, 6))
> print('check_palindrome=', check_palindrome('abccba'))
> print('check_palindrome=', check_palindrome('abc'))
> print('check_palindrome=', check_palindrome('123'))
> print('check_palindrome=', check_palindrome('123321'))
> ```


#### 7.9.7 高阶函数
> 高阶函数英文叫`Higher-order function`.
> 
> 高阶函数至少符合两个特点: 接受一个或多个函数作为参数或将函数作为返回值返回的函数就称之为高阶函数.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 高阶函数 | higherOrderFunctions
> list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
> 
> 
> # 定义 检查偶数数函数 | Definition check even function
> def even_function(num):
>     if num % 2 == 0:
>         return True
>     return False
> 
> 
> # 定义 检查奇数函数 | Definition check odd function
> def odd_function(num):
>     if num % 3 == 0:
>         return True
>     return False
> 
> 
> # 定义 检查 列表中大于6的数值函数
> def more_than_the(num):
>     if num > 6:
>         return True
>     return False
> 
> 
> # 定义函数 | Defining functions
> def higher_order_function(functions, data):
>     new_list = []  # 定义 空集合, 用于储存奇数集合
>     for x in data:
>         if functions(x):
>             new_list.append(x)
>     return new_list
> 
> 
> # 调用函数 | call function
> print('higher_order_function=', higher_order_function(even_function, list_1))
> print('higher_order_function=', list(filter(odd_function, list_1)))
> print('higher_order_function=', list(filter(more_than_the, list_1)))
> ```


##### 7.9.7.1 匿名函数
> 匿名函数`lambda`函数表达式(语法糖).
> 
> `lambda`函数表达式专门用来创建一些简单函数, 它是函数创建的又一种方式.
> 
> 匿名函数一般都是作为参数使用, 其他地方一般不会使用.
> 
> 匿名函数语法: `lambda` 参数列表: 返回值
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 匿名函数 | Anonymous function
> anonymous_function01 = (lambda a, b: a * b)
> anonymous_function02 = (lambda a, b: a + b)(30, 30)
> anonymous_function03 = (lambda x: x % 2 == 0)
> anonymous_function04 = (lambda x: x % 2 != 0)
> anonymous_function05 = (lambda x: x > 5)
> 
> print('anonymous_function01=', anonymous_function01)
> print('anonymous_function02=', anonymous_function02)
> print('anonymous_function03=', list(filter(anonymous_function03, list_1)))
> print('anonymous_function04=', list(filter(anonymous_function04, list_1)))
> print('anonymous_function05=', list(filter(anonymous_function05, list_1)))
> ```


##### 7.9.7.2 map()函数
> map()函数可以对可迭代对象中所有元素做指定的操作, 然后将其添加到一个新的对象中返回.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # map函数 | map function
> maps1 = map(lambda x: x + 1, list_1)
> maps2 = map(lambda x: x ** 2, list_1)
> print('maps1=', list(maps1))
> print('maps2=', list(maps2))
> ```

##### 7.9.7.3 sort()方法
> 该方法用来对列表中的元素进行排序, 默认是直接比较列表中的元素的大小.
> 
> 在sort()可以接收一个关键字参数,  key需要一个函数作为参数, 当设置了函数作为参数.
> 
> 每次都会以列表中的一个元素作为参数来调用函数, 并且使用函数的返回值来比较元素的大小
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # sort方法 | sort method
> list_2 = ['b', 'a', 'd', 'c']
> list_3 = ['bb', 'aaa', 'dddd', 'ccccc']
> list_2.sort()
> # list_3.sort(key=len)
> 
> print('sort=', list_2)
> print('sort=', list_3)
> ```

##### 7.9.7.4 sorted()函数
> 此函数和sort()的用法基本一致, 但是sorted()可以对任意的序列进行排序, 并且使用sorted()排序不会影响原来的对象, 而是返回一个新对象.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # sorted函数 | sorted function
> list_4 = [3, '1', 5, '9', 2, '4', 7, 6]
> print('Before sorting: ', list_4)
> print('Sorted: ', sorted(list_4, key=int))
> print('After sorting: ', list_4)
> 
> list_5 = 'iighrghcjshfjkewhfiwlkgoaggdljhsjdewkfk'
> print('Before sorting: ', list_5)
> print('Sorted: ', sorted(list_5, key=str))
> print('After sorting: ', list_5)
> ```


##### 7.9.7.5 闭包
> 将函数作为返回值返回也是一种高阶函数, 称为叫做闭包.
> 
> 通过闭包可以创建一些只有当前函数能访问的变量.
> 
> 可以将一些私有的数据藏到的闭包中.
> 
> 形成闭包的要件： 1.函数嵌套 / 2.将内部函数作为返回值返回 / 3.内部函数必须要使用到外部函数的变量
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 闭包 | Closure
> # 定义函数 | Defining functions
> def functions16():
>     def inner():
>         print('inner !')
> 
>     # 将内部函数作为返回值 | Using internal functions as return values
>     return inner
> 
> 
> # 调用函数 | call function
> print('functions16=', functions16())
> '''
> r16是一个函数, 是调用functions16()后返回的函数
> 此函数是在functions16()内部定义, 并不是全局函数
> 所以此函数总是能访问到functions16()函数内的变量
> '''
> r16 = functions16()
> r16()
> 
> 
> # 定义函数 | Defining functions
> def functions17():
>     # 定义 内部空集合 | Definition Internal empty collection
>     nums = []
> 
>     # 定义 内部函数 | Definition internal function
>     def functions18(num):
>         # 添加集合元素 | Adding collection elements
>         nums.append(num)
>         # 计算返回平均值 | Calculate return average
>         return sum(nums) / len(nums)
> 
>     # 将内部函数作为返回值返回 | Return internal function as return value
>     return functions18
> 
> 
> # 调用函数 | call function
> # 在外部无法访问内部空集合, 只有在内部可以访问, 即表示变量的私有属性
> functions19 = functions17()
> print('functions19=', functions19(30))
> print('functions19=', functions19(3020))
> print('functions19=', functions19(5020))
> ```


##### 7.9.7.6 装饰器
> 装饰器既是在不修改原函数的情况下来对函数进行扩展.
> 
> 只需要根据现有的函数来创建一个新的函数.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 函数 | function
> # @File : 10_function.py
> # @Description : Python 基础篇 - 函数 | Python Basics-Functions
> 
> # 装饰器 | Decorator
> # 定义函数 | Defining functions
> '''
> 当前方式, 已经可以在不修改源代码的情况下对函数进行扩展
> 但是当前方式要求在每扩展一个函数就要手动创建一个新的函数实在是太麻烦
> 为了解决这个问题, 则创建一个函数, 让这个函数可以自动的帮助生产函数
> '''
> 
> def functions20(num1, num2):
>     print('res=', num1 * num2)
> 
> 
> # 定义函数 | Defining functions
> def functions21(num1, num2):
>     print('Start Calculating...')
>     functions20(num1, num2)
>     print('End Calculation...')
> 
> 
> # 调用函数 | call function
> functions21(5, 6)
> 
> # 定义函数 | Defining functions
> '''
> 此函数用来对其他函数进行扩展, 使其他函数可以在执行前后打印日志信息
> 函数参数：`fun` 需要扩展的函数对象
> '''
> 
> 
> def extension_function(fun):
>     '''
>     定义 装饰器函数 | Define decorator function
> 
>     `decorator_function()`函数就称之为装饰器
>     通过装饰器可以在不修改原来函数的情况下来对函数进行扩展
>     在开发中都是通过装饰器来扩展函数的功能
>     在定义函数时可以通过`@`装饰器来使用指定的装饰器来装饰当前的函数
>     可以同时为一个函数指定多个装饰器, 这样函数将会按照从内向外的顺序被装饰
> 
>     非必填参数 args
>     非必填参数 keywords
>     :param fun:
>     :return:
>     '''
> 
>     def decorator_function(*args, **keywords):
>         print('Begin execution')
>         # 调用被扩展函数 | Call the extended function
>         result = fun(*args, **keywords)
>         print('End execution')
>         # 返回函数执行结果 | Returns the result of function execution
>         return result
> 
>     # 返回新函数 | Return new function
>     return decorator_function
> 
> 
> funs = extension_function(functions20)
> r18 = funs(10, 20)
> 
> # 定义 扩展函数 | Definition extension function
> '''
>     在定义函数时可以通过`@`装饰器来使用指定的装饰器来装饰当前的函数
>     可以同时为一个函数指定多个装饰器, 这样函数将会按照从内向外的顺序被装饰
> '''
> 
> 
> # 引入 自定义装饰器 | Introducing custom decorators
> @extension_function
> def hello():
>     print('Hello World ~')
> 
> 
> # 调用函数 | call function
> hello()
> ```


### 7.10 Python 面向对象
> **1. 什么是对象**
> - 对象是内存中专门用来存储数据的一块区域.
> - 对象中可以存放各种数据(比如集合、数据类型、代码)等等.
> 
> **2. 对象由三部分组成**
> - [1] 对象的标识 (id)
> - [2] 对象的类型 (type)
> - [3] 对象的值 (value)
> 
> **3. 面向对象 (OOP)**
> - Python是一门面向对象的编程语言.
> - 所谓的面向对象的语言, 简单理解就是语言中的所有操作都是通过对象来进行的.
> 
> **4. 面向过程编程语言** 
> - 简单理解就是语言中的所有操作都是通过对象来进行的.
> - 面向过程的编程语言: 面向过程指将程序的逻辑分解为一个一个的步骤,通过对每个步骤的抽象来完成程序.
> - 面向过程的编程思想: 将一个功能分解为一个一个小的步骤, 通过完成一个一个的小的步骤来完成一个程序, 这种编程方式符合我们人类的思维, 编写起来相对比较简单, 但是以这种方式编码的往往只适用于一个功能, 如果要在实现其他功能, 即使功能相差极小, 也往往要重新编写代码, 所以它可复用性比较低, 并且难于维护.
> 
> **5. 面向对象编程语言**
> - 面向对象的编程语言关注的是对象而不关注过程.
> - 对于面向对象的语言来说, 一切都是对象.
> - 面向对象的编程思想: 将所有的功能统一保存到对应的对象中,  要使用某个功能直接找到对应的对象即可, 这种方式的编码比较容易阅读, 并且比较易于维护, 容易复用.
> 
> **6. 面向对象 三大特征**
> - 封装: 确保对象中数据安性
> - 继承: 保证对象的可扩展性
> - 多态: 保证程序灵活性


####  7.10.1 类 class
> **1. 类的简介**
> 目前所学习的对象都是Python内置的对象.
> 
> 但是内置对象并不能满足所有的需求, 所以在开发中经常需要自定义一些对象.
> 
> 类就是一个用来创建对象的对象, 对象是类的实例, 如果多个对象是通过一个类创建的, 则称这些对象是一类对象.
> 
> **2. 定义 类**
> 定义 类的语法:
> ```
> class 类名([父类]):
>     代码块
> ```
> 类和对象都是对现实生活中的事物或程序中的内容的抽象.
> 
> 实际上所有的事物都由两部分构成: 1.数据 (属性) / 2.行为 (方法)
> 
> 在类的代码块中可以定义变量和函数.
> 
> 变量会成为该类实例的公共属性, 所有的该类实例都可以通过`对象.属性名`形式访问.
> 
> 函数会成为该类实例的公共方法, 所有该类实例都可以通过`对象.方法名()`形式调用方法.
> 
> ⚠️  注意 ⚠️ : 方法调用时, 第一个参数由解析器自动传递, 所以定义方法时至少要定义一个形参.
> 
> 类中定义的属性和方法都是公共的, 任何该类实例都可以访问.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 定义 实例 | Definition instance
> # 创建int实例 | Create an int instance
> nums = int(100)
> print('nums=', nums, type(nums))
> 
> 
> # 定义 类 | Definition class
> class CoreClass:
>     pass
> 
> 
> # 创建对象实例 | Create Object instance
> cc = CoreClass()
> cc1 = CoreClass()
> cc2 = CoreClass()
> cc3 = CoreClass()
> print('cc=', cc, type(cc))
> 
> # 检查对象实例 | Check object instance
> res1 = isinstance(cc, CoreClass)
> res2 = isinstance(cc1, CoreClass)
> res3 = isinstance(cc2, CoreClass)
> res4 = isinstance(cc2, int)
> print('res1=', res1)
> print('res2=', res2)
> print('res3=', res3)
> print('res4=', res4)
> 
> # 定义 类 | Definition class
> class Product():
>     # 定义 属性 | Definition attribute
>     product_name = 'Mobile phone'
>     product_size = '26 * 30'
>     product_weight = 20
>     product_colour = 'black'
> 
>     # 定义 方法 | Definition method
>     def product_info(self):
>         print('product_info')
> 
> 
> # 创建实例 | Create instance
> p1 = Product()
> p2 = Product()
> 
> # 调用 属性 | Call attribute
> r1 = p1.product_name
> r2 = p2.product_colour
> print('product_name=', r1)
> print('product_colour=', r2)
> 
> # 调用 方法 | Call method
> p1.product_info()
> p2.product_info()
> ```
> 
> **3. 属性 & 方法**
> 当调用一个对象的属性时, 解析器会先在当前对象中寻找是否含有该属性, 如果有则直接返回当前的对象的属性值, 如果没有则去当前对象的类对象中去寻找, 如果有则返回类对象的属性值, 如果类对象中依然没有则报错.
> 
> 类对象和实例对象中都可以保存属性&方法.
> 
> 如果这个属性&方法是所有的实例共享, 则应该将其保存到类对象中.
> 如果这个属性&方法是某个实例独有, 则应该保存到实例对象中.
> 
> 一般情况下, 属性保存到实例对象中, 而方法需要保存到类对象中.
> 方法每次被调用时解析器都会自动传递第一个实参, 第一个参数就是调用方法的对象本身, 一般都会将这个参数命名为`self`
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 定义 类 | Definition class
> class Product:
>     # 定义 属性 | Definition attribute
>     product_name = 'Mobile phone'
>     product_size = '26 * 30'
>     product_weight = 20
>     product_colour = 'black'
> 
>     # 定义 方法 | Definition method
>     def product_info(self):
>         print('product_info=', self.product_name, self.product_size, self.product_weight, self.product_colour)
> 
> 
> # 创建实例 | Create instance
> p1 = Product()
> p2 = Product()
> 
> # 调用 属性 | Call attribute
> r1 = p1.product_name = 'Apple Mobile phone'
> r2 = p2.product_colour = 'Gradient color'
> print('product_name=', r1)
> print('product_colour=', r2)
> 
> # 调用 方法 | Call method
> p1.product_info()
> p2.product_info()
> ```
> 
> **5. 对象的初始化**
> 在类中可以定义一些特殊方法, 以`__`下划线开头, 以`__`下划线结尾的方法称之为特殊方法.
> 
> 特殊方法由Python解析器自动调用, 不需要开发者自己调用, 特殊方法将会在特殊的时刻自动调用.
> 
> **5.1. 创建对象的流程**
> ```
> obj = Object()的运行流程
> 1. 创建变量
> 2. 在内存中创建新对象
> 3. __init__(self)方法执行
> 4. 将对象id赋值给变量
> ```
> init会在对象创建以后立刻执行, init可以用来向新创建的对象中初始化属性, 调用类创建对象时, 类后面的所有参数都会依次传递到init()中.
> 
>`类的基本结构`
> ```
> class 类名([父类]) :
> 
>     公共属性... 
>     
>     # 对象初始化方法
>     def __init__(self, ...):
>         ...
> 
>     # 其他方法    
>     def method_1(self, ...):
>         ...
> 
>     def method_2(self, ...):
>         ...
> 
>     ...   
> ```
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 对象 初始化 | Object initialization
> # 定义 类 | Definition class
> class Commodity:
>     # 定义初始化方法 | Define the initialization method
>     def __init__(self, commodity_brand, commodity_model, commodity_colour, commodity_operating_system, commodity_ram,commodity_of_sale, commodity_price):
>         self.commodity_brand = commodity_brand
>         self.commodity_model = commodity_model
>         self.commodity_colour = commodity_colour
>         self.commodity_operating_system = commodity_operating_system
>         self.commodity_ram = commodity_ram
>         self.commodity_of_sale = commodity_of_sale
>         self.commodity_price = commodity_price
> 
>     # 定义 自定义 方法 | Define custom method
>     def commodity_info(self):
>         print('Commodity Info:', self.commodity_brand,
>               self.commodity_model, self.commodity_colour, self.commodity_operating_system, self.commodity_ram,
>               self.commodity_of_sale, self.commodity_price)
> 
> 
> # 创建实例 | Create instance
> commodity_1 = Commodity('Apple', 'iphone X', 'White', 'Ios', '256GB', 'Global', '4500RMB')
> commodity_2 = Commodity('Samsung', 'S3', 'Blue', 'Android', '16GB', 'Global', '900RMB')
> commodity_3 = Commodity('Huawei', 'P30', 'Black', 'Android', '256GB', 'Global', '5600RMB')
> 
> # 调用 方法 | Call method
> commodity_1.commodity_info()
> commodity_2.commodity_info()
> commodity_3.commodity_info()
> ```

####  7.10.2 封装
> 封装是面向对象的三大特性之一, 封装指的是隐藏对象中一些不希望被外部所访问到的私有属性或方法.
> 
> 使用封装确实增加了类的定义的复杂程度, 但是它也确保了数据的安全性.
> 
> 将对象的属性名修改为隐藏属性名, 目的是让调用者无法随意修改对象中的属性, 增加getter&setter方法, 很好的控制的属性是否是只读性.
> 
> 定义私有属性需要提供`getter`&`setter`方法使外部可以访问到属性.
> 
> getter 获取对象中的指定属性 (get_属性名)
> 
> setter 用来设置对象的指定属性 (set_属性名)
> 
> 如果希望属性是只读则可以直接去掉setter方法, 如果希望属性不能被外部访问则可以直接去掉getter方法.
> 
> 提供`getter`&`setter`方法的作用: 
> 
> 使用setter方法设置属性, 可以增加数据的验证, 确保数据的值是正确性.
> 
> 使用getter方法获取属性, 使用setter方法设置属性, 可以在读取属性和修改属性的同时做一些其他的处理, getter方法还可以表示一些计算的属性.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 面向对象 (封装) | Object-oriented (encapsulation)
> # 定义 类 | Definition class
> class Animals:
> 
>     # 定义 初始化方法 | Definition initialization method
>     def __int__(self, animal_name, animal_type, animal_age, animal_diet):
>         self.hidden_animal_name = animal_name
>         self.hidden_animal_type = animal_type
>         self.hidden_animal_age = animal_age
>         self.hidden_animal_diet = animal_diet
> 
>     # 自定义方法 | Custom method
>     def info(self):
>         print('info=', self.hidden_animal_name, self.hidden_animal_type, self.hidden_animal_age,  self.hidden_animal_diet)
> 
>    '''
>     定义 getter&setter方法 | Define getter & setter method
>     get_xxx()方法 用来获取对象属性
>     set_xxx()方法 用来修改对象属性
>     '''
> 
>     def get_animal_name(self):
>         return self.hidden_animal_name
> 
>     def set_animal_name(self, animal_name):
>         self.hidden_animal_name = animal_name
> 
>     def get_animal_type(self):
>         return self.hidden_animal_type
> 
>     def set_animal_type(self, animal_type):
>         self.hidden_animal_type = animal_type
> 
>     def get_animal_age(self):
>         return self.hidden_animal_age
> 
>     def set_animal_age(self, animal_age):
>         if animal_age > 0:
>             self.hidden_animal_age = animal_age
> 
>     def get_animal_diet(self):
>         return self.hidden_animal_diet
> 
>     def set_animal_diet(self, animal_diet):
>         self.hidden_animal_diet = animal_diet
> 
> 
> # 创建实例 | Create instance
> animals_1 = Animals()
> 
> # 为实例赋值 | Assigning values ​​to instances
> animals_1.set_animal_name('Cat')
> animals_1.set_animal_type('Feline')
> animals_1.set_animal_age(10)
> animals_1.set_animal_diet('Fish')
> 
> # 调用 方法 | Call method
> animals_1.info()
> ```
> 
> 可以为对象的属性使用双下划线开头，`__xxx`
> 
> 双下划线开头的属性是对象的隐藏属性, 隐藏属性只能在类的内部访问, 无法通过对象访问, 以`__`开头的属性是隐藏属性, 无法通过对象访问.
> 
> 使用`__`开头的属性, 实际上依然可以在外部访问, 一般会将一些私有属性(不希望被外部访问的属性)以`_`单下划线开头.
> 
> 一般情况下使用`_`单下划开头的属性都是私有属性, 没有特殊需要应避免修改私有属性.
> 
> **1. property装饰器**
> - property装饰器用来将get方法转换为对象的属性.
> - 添加为property装饰器后可以像调用属性一样使用get方法.
> - 使用property装饰的方法, 必须和属性名保持一致性.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # Property 装饰器 | property decorator
> # 定义 类 | Definition class
> class Zoo():
>     # 定义 初始化方法 | Definition initialization method
>     def __int__(self, animal_name, animal_type, animal_age, animal_diet):
>         self._animal_name = animal_name
>         self._animal_type = animal_type
>         self._animal_age = animal_age
>         self._animal_diet = animal_diet
> 
>     # 自定义方法 | Custom method
>     def info(self):
>         print('info=', self._animal_name, self._animal_type, self._animal_age, self._animal_diet)
> 
>     # 定义 getter&setter方法 | Define getter & setter method
>     @property
>     def animal_name(self):
>         return self._animal_name
> 
>     @property
>     def animal_type(self):
>         return self._animal_type
> 
>     @property
>     def animal_age(self):
>         return self._animal_age
> 
>     @property
>     def animal_diet(self):
>         return self._animal_diet
> 
>     @animal_name.setter
>     def animal_name(self, animal_name):
>         self._animal_name = animal_name
> 
>     @animal_type.setter
>     def animal_type(self, animal_type):
>         self._animal_type = animal_type
> 
>     @animal_age.setter
>     def animal_age(self, animal_age):
>         self._animal_age = animal_age
> 
>     @animal_diet.setter
>     def animal_diet(self, animal_diet):
>         self._animal_diet = animal_diet
> 
> 
> # 创建实例 | Create instance
> z = Zoo()
> 
> # 为实例赋值 | Assigning values ​​to instances
> z.animal_name = 'lion'
> z.animal_type = 'Feline'
> z.animal_age = 12
> z.animal_diet = 'Meat'
> 
> # 调用 方法 | Call method
> z.info()
> 
> # 调用 属性 | # 调用 属性
> print('animal_name=', z.animal_name)
> print('animal_type=', z.animal_type)
> print('animal_age=', z.animal_age)
> print('animal_diet=', z.animal_diet)
> ```



####  7.10.3 继承
> 继承是面向对象三大特性之一, 通过继承可以使一个类获取到其他类中的属性和方法.
> 
> 在定义类时可以在类名后的括号中指定当前类的父类(超类、基类、super), 子类(衍生类)可以直接继承父类中的所有的属性和方法.
> 
> 通过继承可以直接让子类获取到父类的方法或属性, 避免编写重复性的代码, 可通过继承来对一个类进行扩展, 并且也符合OCP原则.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 继承 | inherit
> # 定义 父类 | Definition father class
> class Cars:
>     # 定义 汽车信息 方法 | Definition car information method
>     def car_info(self):
>         print('Car info')
> 
> 
> # 定义子类  继承父类 | Defining subclasses inheriting parent classes
> class BMW(Cars):
>     def bmv_info(self):
>         print('BMW info')
> 
> 
> # 创建实例 | Create instance
> bmw = BMW()
> 
> # 子类实例 调用方法 | Subclass instance call method
> bmw.car_info()
> bmw.bmv_info()
> 
> # 检查对象实例 | Check object instance
> instance_res1 = isinstance(bmw, Animals)
> instance_res2 = isinstance(bmw, Cars)
> instance_res3 = isinstance(bmw, BMW)
> 
> print('instance_res1=', instance_res1)
> print('instance_res2=', instance_res2)
> print('instance_res3=', instance_res3)
> 
> # issubclass() 检查一个类是否是另一个类的子类
> issubclass_res1 = issubclass(BMW, Animals)
> issubclass_res2 = issubclass(Cars, BMW)
> issubclass_res3 = issubclass(BMW, Cars)
> issubclass_res4 = issubclass(Cars, object)
> issubclass_res5 = issubclass(BMW, object)
> 
> print('issubclass_res1=', issubclass_res1)
> print('issubclass_res2=', issubclass_res2)
> print('issubclass_res3=', issubclass_res3)
> print('issubclass_res4=', issubclass_res4)
> print('issubclass_res5=', issubclass_res5)
> ```
> 
> **1. 方法重写**
> - 如果在子类中如果有和父类同名的方法, 则通过子类实例去调用方法时, 会调用子类的方法而不是父类的方法, 这个特点就称之为方法的重写(覆盖 Override).
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 继承 | inherit
> # 定义 父类 | Definition father class
> class Cars:
>     # 定义 汽车信息 方法 | Definition car information method
>     def car_info(self):
>         print('Car info')
> 
> 
> # 定义子类  继承父类 | Defining subclasses inheriting parent classes
> class BMW(Cars):
>     def bmv_info(self):
>         print('BMW info')
> 
>     # 方法重写 | Method rewrite
>     def car_info(self):
>         print('Car info = BMW')
> 
> 
> # 创建实例 | Create instance
> bmw = BMW()
> 
> # 子类实例 调用方法 | Subclass instance call method
> bmw.car_info()
> bmw.bmv_info()
> ```
> 
> - 调用方法优先级: 当调用一个对象的方法时, 会优先去当前对象中寻找是否具有该方法, 如果有则直接调用, 如果没有, 则去当前对象的父类中寻找, 如果父类中有则直接调用父类中的方法, 如果没有, 则去父类的父类中寻找, 以此类推直到找到object, 如果依然没有找到则出现异常.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 调用 方法优先级 | Call method priority
> # 定义 父类 A | Definition father class A
> class A(object):
>     def cores(self):
>         print('AAA')
> 
> 
> # 定义 子类 B 继承 父类 A | Definition subclass B inherits parent class A
> class B(A):
>     def cores(self):
>         print('BBB')
> 
> 
> # 定义 子类 C 继承 B | Definition subclass C inherits B
> class C(B):
>     def cores(self):
>         print('CCC')
> 
> 
> # 创建实例 | Create instance
> c = C()
> 
> # 调用方法 | Calling method
> c.cores()  # OutPut CCC
> ```
> 
> **2. super()**
> - 希望可以直接调用父类的`__init__`来初始化父类中定义的属性.
> - `super()`可以用来获取当前类的父类, 并且通过super()返回对象调用父类方法时, 不需要传递self.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # super()
> # 定义 父类 | Definition father class
> class Car:
>     # 定义 初始化方法 | Definition initialization method
>     def __int__(self, car_name):
>         self._car_name = car_name
> 
>     # 定义 getter&setter方法 | Define getter & setter method
>     @property
>     def car_name(self):
>         return self._car_name
> 
>     @car_name.setter
>     def car_name(self, car_name):
>         self._car_name = car_name
> 
>     # 定义 汽车信息 方法 | Definition car information method
>     def car_info(self):
>         print('Car info')
> 
> 
> # 定义子类  继承父类 | Defining subclasses inheriting parent classes
> # 父类中的所有方法都会被子类继承, 包括特殊方法, 但也可以重写特殊方法
> class Bmw(Car):
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self, car_name, car_colour):
>         self._car_colour = car_colour
>         # 调用 父类方法 | Call parent method
>         super().__int__(car_name)
> 
>     # 定义 getter&setter方法 | Define getter & setter method
>     @property
>     def car_colour(self):
>         return self._car_colour
> 
>     @car_colour.setter
>     def car_colour(self, car_colour):
>         self._car_colour = car_colour
> 
>     def bmv_info(self):
>         print('BMW info=', self._car_name, self._car_colour)
> 
>     # 方法重写 | Method rewrite
>     def car_info(self):
>         print('Car info = BMW')
> 
> 
> # 创建实例 | Create instance
> bmw = Bmw('bmw M6', 'blue')
> 
> # 子类实例 调用方法 | Subclass instance call method
> bmw.car_info()
> bmw.bmv_info()
> ```
> 
> **3. 多重继承**
> 在Python中是支持多重继承, 也就是可以为一个类同时指定多个父类.
> 
> 可以在类名的()括号后边添加多个类来实现多重继承.
> 
> 多重继承会使子类同时拥有多个父类, 并且会获取到所有父类中的方法.
> 
> 在开发中没有特殊的情况, 应该尽量避免使用多重继承, 因为多重继承会让代码过于复杂.
> 
> 如果多个父类中有同名的方法, 则会现在第一个父类中寻找, 然后找第二个, 然后找第三个, 前边父类的方法会覆盖后边父类的方法.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 多重继承 | Multiple inheritance
> # 定义 父类 D | Definition father class D
> class D(object):
>     def cores(self):
>         print('DDD')
> 
> 
> # 定义 子类E | Definition subclass E 
> class E(object):
>     def cores(self):
>         print('EEE')
> 
> 
> # 定义 子类 F 多重继承 D E | Definition Subclass F Multiple inheritance D E
> class F(D, E):
>     def cores(self):
>         print('FFF')
> 
> # 获取当前类的所有父类 | Get all parent classes of the current class
> print('F.__bases__ =', F.__bases__)
> 
> # 创建实例 | Create instance
> f = F()
> 
> # 调用方法 | Calling method
> f.cores()  # OutPut FFF
> ```


####  7.10.4 多态
> 多态是面向对象的三大特征之一, 多态可以理解为对象的多种形态, 一个对象可以以不同的形态呈现.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 面向对象 (多态) | Object-oriented (polymorphic)
> # 定义 类 | Definition class
> class G:
>     def __init(self, infos):
>         self._infos = infos
> 
>     @property
>     def infos(self):
>         return self._infos
> 
>     @infos.setter
>     def infos(self, infos):
>         self._infos = infos
> 
> 
> # 定义 类 | Definition class
> class H:
>     def __init(self, infos):
>         self._infos = infos
> 
>     @property
>     def infos(self):
>         return self._infos
> 
>     @infos.setter
>     def infos(self, infos):
>         self._infos = infos
> 
> 
> # 定义 类 | Definition class
> class J:
>     pass
> 
> 
> # 创建实例 | Create instance
> g = G()
> h = H()
> 
> # 为实例赋值 | Assigning values ​​to instances
> h.infos = 'H'
> g.infos = 'G'
> 
> 
> # 定义 全局函数 | Definition global function
> def info(obj):
>     # 定义 类型检查 | Definition type checking
>     '''
>     该函数只有obj是G类型的对象时才可以正常使用
>     其他类型的对象都无法使用该函数, 这个函数就违反了多态,
>     违反了多态的函数, 只适用于一种类型的对象, 无法处理其他类型对象, 这样导致函数的适应性非常差
>     注意: isinstance()此函数在开发中一般是不会使用
>     :param obj:
>     :return:
>     '''
>     if isinstance(obj, G):
>         print('infos =', obj.infos)
>     else:
>         print("no info!")
> 
> 
> # 调用函数 | call function
> info(g)
>```


####  7.10.5 类中的属性 & 方法
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 类中的属性 & 方法 | Properties & methods in the class
> # 定义 类 | Definition class
> # 类中可以包含: 类属性 / 实例属性 / 类方法 / 实例方法 / 静态方法
> class K(object):
>     # 定义 属性 | Definition attribute
>     '''
>     可以直接在类中定义的属性就称之为类属性
>     类属性可以通过类或实例进行访问
>     但是类属性只能通过类对象进行修改, 无法通过实例对象进行修改
>     '''
>     res_sum = 0
> 
>     # 定义 初始化方法 | Definition initialization method
>     '''
>     通过实例对象添加的属性属于实例属性
>     实例属性只能通过实例对象进行访问和修改, 类对象无法进行访问修改
>     '''
> 
>     def __init__(self):
>         self.infos = 'Info'
> 
>    # 定义 实例方法 | Defining instance methods
>     '''
>     在类中定义以`seIf`为第一个参数的方法称之为实例方法
>     实例方法在调用时Python解析器会将调用对象作为`seIf`传入
>     实例方法可以通过实例和类进行调用
>     当通过实例调用时, 会自动将当前调用对象作为`seIf`传入
>     当通过对象调用时, 不会自动传入`seIf`, 必须需要开发者手动传递`seIf`
>     '''
> 
>     def core_info(self):
>         print('core_info=', self)
> 
>     # 定义 类方法 | Definition class method
>     '''
>     在类内部使用`@classmethod`关键字来修饰类方法
>     类方法中第一个参数为`cls`, `cls`参数也会被自动传递, `cls`就是当前类的对象
>     类方法和实例方法的区别在于: 实例方法第一个参数为`seIf`, 而类方法第一个参数为`cls`
>     类方法可以通过类进行调用, 也可以通过实例进行调用
>     '''
> 
>     @classmethod
>     def core_cls(cls):
>         print('core_cls=', cls, cls.res_sum)
> 
>     # 定义 静态方法 | Definition static method
>     '''
>     在类中使用`@staticmethod`关键字来修饰静态方法
>     静态方法不需要指定任何的默认参数, 静态方法可以通过类和实例进行调用
>     静态方法基本上是和当前类无关的方法, 它只是存储当前类中的函数, 该方法一般在开发中作为工具方法使用
>     '''
> 
>     @staticmethod
>     def core_staticmethod():
>         print('core_staticmethod')
> 
> 
> # 创建实例 | Create instance
> k = K()
> 
> k.res_sum = 1000
> K.res_sum = 10000
> 
> print('k', k.res_sum)
> print('K', K.res_sum)
> 
> k.core_info()
> K.core_info(k)
> 
> k.core_staticmethod()
> K.core_staticmethod()
> ```


####  7.10.6 垃圾回收
> 程序运行过程中产生的垃圾会影响到程序运行性能, 所以这些垃圾必须被及时清理.
> 
> 在程序中没有被引用的对象就称之为垃圾,当垃圾对象过多以后会影响到程序运行性能.
> 
> 所以必须进行及时的垃圾回收, 所谓的垃圾回收就是将垃圾对象从内存中删除.
> 
>Python提供了自动的垃圾回收机制, 无需手动删除, 它会自动将没有被引用的对象删除.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 垃圾回收 | Garbage collection
> # 定义 类 | Definition class
> class U:
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self):
>         self.info = 'U class'
> 
>     # 定义 del特殊方法, 在对象被垃圾回收前调用该方法
>     def __del__(self):
>         print('Delete U class', self)
> 
> 
> # 创建实例 | Create instance
> u = U()
> 
> '''
> 垃圾回收 测试 | 将u实例定义为空, 此时只要没有任何变量对U对象进行引用, 则该实例在> 内存中就变成了垃圾, Python将自动进行垃圾回收
> '''
> a = None
> ```


####  7.10.7 特殊方法
> 特殊方法也称为魔术方法, 特殊方法都是使用`__`双下划线开头和结尾.
> 
> 特殊方法一般不需要开发者手动调用, 需要在一些特殊情况下自动执行.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 特殊方法 | Special method
> # 定义 类 | Definition class
> class Shape:
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self, name, lengths):
>         self.name = name
>         self.lengths = lengths
> 
>     '''
>     `__str__()` 该特殊方法会在尝试将对象转换为字符串时调用
>     该作用是可以用来指定对象转换为字符串的结果
>     '''
> 
>     def __str__(self):
>         return 'Shape [Name= %s , Lengths= %d]' % (self.name, self.lengths)
> 
>     '''
>     `__repr__()` 该特殊方法会在对当前对象使用`repr()`函数时调用
>     该作用是指定对象在`交互模式`中直接输出返回结果
>     '''
> 
>     def __repr__(self):
>         return 'This is the graphics class!'
> 
>     '''
>     其他特殊方法介绍 | Introduction of other special methods
>     
>     `object.__lt__(self, other)` 小于 < 
>     该特殊方法在对象进行小于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     `object.__le__(self, other)` 小于等于 <=
>     该特殊方法在对象进行小于等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     `object.__eq__(self, other)` 等于 ==
>     该特殊方法在对象进行等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     `object.__ne__(self, other)` 不等于 !=
>     该特殊方法在对象进行不等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     
>     `object.__gt__(self, other)` 大于 >
>     该特殊方法在对象进行大于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     
>     
>     `object.__ge__(self, other)` 大于等于 >=
>     该特殊方法在对象进行大于等于比较时调用, 该方法返回值将作为比较结果进行返回, 
>     该方法需要携带两个参数, `self`参数则表示当前对象, `other`参数则表示和当前对象比较的对象
>     '''
> 
>     def __lt__(self, other):
>         return self.lengths < other.lengths
> 
>     def __le__(self, other):
>         return self.lengths <= other.lengths
> 
>     def __eq__(self, other):
>         return self.lengths == other.lengths
> 
>     def __ne__(self, other):
>         return self.lengths != other.lengths
> 
>     def __gt__(self, other):
>         return self.lengths > other.lengths
> 
>     def __ge__(self, other):
>         return self.lengths >= other.lengths
>     # 可通过bool来指定对象转换为布尔值
>     def __bool__(self):
>         return self.lengths > 150
>         
> # 创建实例 | Create instance
> s1 = Shape('Round', 158)
> s2 = Shape('Rectangle', 412)
> 
> # 当打印对象时实际上打印的是对象的中特殊方法> `__str__()`的返回值
> print('s1=', s1)  # s1= <__main__.Shape object at 0x10b524a60>
> print('s2=', s2)  # s2= <__main__.Shape object at 0x10b524ac0>
> 
> # 小于比较 | Less than comparison
> print('s1 < s2 =', s1 < s2)  # s1 < s2 = True
> print('s2 < s1 =', s2 < s1)  # s2 < s1 = False
> 
> # 小于等于比较 | Less than or equal comparison
> print('s1 <= s2 =', s1 <= s2)  # s1 <= s2 = True
> print('s2 <= s1 =', s2 <= s1)  # s2 <= s1 = False
> 
> # 等于比较 | Equal comparison
> print('s1 == s2 =', s1 == s2)  # s1 == s2 = False
> print('s2 == s1 =', s2 == s1)  # s1 == s2 = False
> 
> # 不等于比较 | Not equal to compare
> print('s1 != s2 =', s1 != s2)  # s1 != s2 = True
> print('s2 != s1 =', s2 != s1)  # s2 != s1 = True
> 
> # 大于比较 | Greater than comparison
> print('s1 > s2 =', s1 > s2)  # s1 > s2= False
> print('s2 > s1 =', s2 > s1)  # s2 > s1= True
> 
> # 大于等于比较 | Greater than or equal
> print('s1 >= s2 =', s1 >= s2)  # s1 >= s2 = False
> print('s2 >= s1 =', s2 >= s1)  # s2 >= s1 = True
> 
> 
> ```


####  7.10.8 模块
> 模块化指将一个完整的程序分解为若干个小的模块.
> 
> 采用模块化将程序分别编写到多个文件中.
> 
> 采用模块化优势：1.方便开发 / 2.方便维护 / 3.模块复用 / 4.解耦合
> 
> 在Python中以`.py`文件就是一个模块, 创建模块实际上就是创建一个python文件.
> 
> 注意：模块名要符号标识符规范.
> 
> **引入外部模块 语法如下:**
> 
> `import 模块名称` 或者 `import 模块名称 as 模块别名`
> 
> 可以引入同一个模块多次, 但是模块实例只会创建一个等同于单实例.
> 
> `import`可以在程序的任意位置调用, 但是一般情况下`import`语句都会统一写在程序的开头或最上方.
> 
> 在每一个模块内部都有`__name__`属性, 通过该属性可以获取模块名称.
> 
> `__name__`属性值为`__main__`的模块是主模块, 一个程序中只会有一个主模块.
> 
> 主模块就是直接通过python执行的模块.
> 
> **引入模块部分内容, 语法如下:**
> 
> `from 模块名称 import 变量1, 变量2....`
> 
> 引入到模块中所有内容, 因会容易出现代码冲突, 一般不会使用.
> 
> 在模块中以单下划线开头的变量只能在模块内部访问, 在通过`import *`引入时，不会引入_开头的变量.
> 
> `from 模块名称 import * `
> 
> **引入变量使用别名, 语法如下:**
> 
> `from 模块名称 import 变量 as 别名`
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # 模块 | Module
> # 导入外部模块 (测试模块) | Import external module (test module)
> 
> import module.test_module
> import module.test_module as ts
> 
> print('test_module=', module.test_module)
> print('test_module __name__ =', module.test_module.__name__)
> print('ts=', ts)
> print('ts __name__ =', ts.__name__)
> print(__name__)
> 
> # 导入外部模块 | Import external module
> import module.core_module as cm
> 
> # 调用变量 | Call variable
> print(cm.nums1, cm.nums2)
> 
> # 创建实例 | Create instance
> cm.CoreModule('CoreModule')
> 
> # 调用函数 | call function
> cm.core_module_function()
> 
> # 引入模块部分内容 | Introducing module content
> from module.core_module import CoreModule, core_module_function
> 
> # 创建实例 | Create instance
> cm1 = CoreModule('CoreModule-1')
> 
> # 调用函数 | call function
> core_module_function()
> 
> # 引入变量使用别名 | Introduce variables using aliases
> from module.core_module import core_module_function as cmf
> 
> # 调用函数 | call function
> cmf()
> ```

####  7.10.9 包
> 包也是一个模块, 当模块中代码过多时或者模块需要被分解为多个模块时, 这时就需要使用到包.
> 
> 普通模块只是一个py文件, 而包是一个文件夹.
> 
> 包中必须要一个 `__init__.py` 文件, 该文件中可以包含有包中的主要内容.
> 
> `__pycache__` 是模块缓存文件
> 
> py代码在执行前需要被解析器先转换为机器码然后再执行, 所以在使用模块(包)时, 也需要将模块的代码先转换为机器码然后再交由计算机执行.
> 
> 而为了提高程序运行的性能, python会在编译过一次以后将代码保存到一个缓存文件中.
> 
> 在下次加载这个模块(包)时就可以不再重新编译而是直接加载缓存中编译好的代码即可.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 包 | Package
> # @File : __init__.py.py
> # @Description : Python 基础篇 - 包 | Python Basics-Packages
> 
> # 导入子模块 | Import submodule
> from module.simple_calculation.addition_calculation import addition_calculation_function as acf
> from module.simple_calculation.subtraction_calculation import subtraction_calculation_function as scf
> from module.simple_calculation.multiplication import multiplication_function as mf
> from module.simple_calculation.division_calculation import division_calculation_function as dcf
> 
> # 调用 简易加法函数 | Call simple addition function
> acf(10, 20)
> 
> # 调用 简易减法函数 | Call simple subtraction function
> scf(60, 10)
> 
> # 调用 简易乘法函数 | Call simple multiplication function
> mf(10, 10)
> 
> # 调用 简易除法函数 | Call simple division function
> dcf(81, 9)
> ```



####  7.10.10 Python 标准库
> 为了实现开箱即用的思想, Python中为开发者提供一个模块的标准库.
> 
> [Python Module Index | Python 标准库 docs.python.org/3.8/py-modindex](https://docs.python.org/3.8/py-modindex.html)
> 
> 在该标准库中有诸多很强大的模块供开发者直接使用.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 面向对象 | Object-oriented
> # @File : 11_object_oriented.py
> # @Description : Python 基础篇 - 面向对象 | Python Basics-Object Oriented
> 
> # Python 标准库 | Python Standard Library
> # Global Module Index https://docs.python.org/3.8/py-modindex.html
> # 引入模块 | Introduce module
> '''
> `sys`模块提供一些变量和函数, 使开发者可以获取到Python解析器信息或者通过函数来操作Python解析器
> '''
> import sys
> 
> '''
> `pprint`模块提供了`pprint()`, 该方法可以用来对打印的数据做简单的格式化处理
> '''
> import pprint
> 
> # `sys.argv` 获取执行代码时命令行中所包含的参数
> # 该属性类型为列表, 列表中保存当前命令所有参数
> print(sys.argv)
> 
> # `sys.modules` 获取当前程序中引入的所有模块
> # modules类型为字典, 字典key为模块名称, 字典value为模块对象
> pprint.pprint(sys.modules)
> 
> # `sys.path` 列表中保存的是模块搜索路径
> pprint.pprint(sys.path)
> 
> # `sys.platform` 表示当前Python运行的操作平台
> print(sys.platform)
> 
> # `sys.exit()` 该函数用来退出程序
> # sys.exit('Program Exception, End!')
> 
> # `os模块` 可以让开发者对操作系统进行访问
> import os
> 
> # `os.environ` 通过该属性可以获取系统环境变量
> pprint.pprint(os.environ)
> 
> # `os.system()` 该函数可以在操作系统中执行命令行指令
> 
> # macOS & Linux 操作系统 命令行指令 | macOS & Linux operating system command line instructions
> os.system('ls -al')
> 
> # Windows 操作系统 命令行指令 | Windows operating system command line instructions
> os.system('dir')
> ```


### 7.11 Python 异常处理 & 文件

#### 7.11.1 异常
> 程序在运行过程当中不可避免的会出现一些错误, 这些错误在程序中称其为异常.
> 
> 程序运行过程中, 一旦出现异常将会导致程序立即终止, 异常后的代码将全部无法执行.

##### 7.11.1.1 处理异常
> 程序运行时出现异常目的并不是让程序直接终止, Python是希望在出现异常时开发者可以编写代码来对异常进行处理.
> 
> 处理异常语法: 
> 
> 说明: 可以将可能出现异常的代码放入到try语句, 这样如果代码没有错误则会正常执行,如果出现错误则会执行expect子句中的代码, 这样就可以通过代码来处理异常避免因为一个异常导致整个程序的终止.
> 
> ```
> try:
>         可能出现错误的代码块
>     except 异常类型 as 异常名:
>         处理异常 代码块
>     except 异常类型 as 异常名:
>         处理异常 代码块
>     except 异常类型 as 异常名:
>         处理异常 代码块
>     else：
>         无异常执行的代码块   
>     finally:
>        最终执行代码块
> ```

##### 7.11.1.2 抛出异常
> 当在函数中出现异常时如果在函数中对异常进行处理则异常不会再继续传播,如果函数中没有对异常进行处理则异常会继续向函数调用处传播, 如果函数调用处处理了异常则不再传播, 如果没有处理则继续向调用处传播, 直到传递到全局作用域, 如果依然没有处理则程序终止并且显示异常信息.
> 
> 在Python为开发者提供了多个异常对象: [Built-in Exceptions](https://docs.python.org/3.8/library/exceptions.html)
> 
> 当程序运行过程中出现异常以后, 所有的异常信息会被保存至专门的异常对象中, 而异常传播时, 实际上就是异常对象抛给了调用处.


##### 7.11.1.3 异常对象
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异常处理和文件操作 | Exception Handling and File Operations
> # @File : 12_exception_handling_and_file_operations.py
> # @Description : Python 基础篇 - 异常处理和文件操作 | Python Basics-Exception Handling and File Operations
> 
> print('Before the exception')
> try:
>     print(10 / 0)
> # Exception是所有异常类的父类, 所以如果except后跟的是Exception则会捕获到所有的异常
> except Exception as e:
>     print('Exception Info', e)
> finally:
>     print('无论是否出现异常, 最终该语句都会执行')
> print('After the exception')
> ```

##### 7.11.1.4 自定义异常对象
> 使用`raise`语句来抛出异常, `raise`语句后需要跟一个异常类或异常实例.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异常处理和文件操作 | Exception Handling and File Operations
> # @File : 12_exception_handling_and_file_operations.py
> # @Description : Python 基础篇 - 异常处理和文件操作 | Python Basics-Exception Handling and File Operations
> 
> # 定义 类 | Definition class
> class ExceptionClass(Exception):
> 
>     # 定义 加法函数 | Definition Addition function
>     def additions(self, num1, num2):
>         if num1 < 0 or num2 < 0:
>             raise ExceptionClass('Custom exception information')
>         res1 = num1 + num2
>         return res1
> 
> 
> if __name__ == '__main__':
>     # 创建实例 | Create instance
>     ec = ExceptionClass()
> 
>     # 调用函数 | call function
>     res2 = ec.additions(1, -1)
>     print(res2)
> ```

#### 7.11.2 文件I/O
> 通过Python程序来对计算机中各种文件进行增删改查操作.
> 
> [Built-in Functions](https://docs.python.org/3.8/library/functions.html) / [Global Module Index](https://docs.python.org/3.8/py-modindex.html)
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异常处理和文件操作 | Exception Handling and File Operations
> # @File : 12_exception_handling_and_file_operations.py
> # @Description : Python 基础篇 - 异常处理和文件操作 | Python Basics-Exception Handling and File Operations
> 
> # 文件 I/O | File I/O
> # 打开文件流 | Open file stream
> FILE_PATH = '../resources/row_file/part_metadata_user.txt'
> FILE_PATHS = '../resources/row_file/demo.jpg'
> # row_data = open(FILE_PATH, encoding='UTF-8')
> 
> # 读取文件流 | Read file stream
> # contents = row_data.read()
> # print('contents=', contents)
> 
> # 关闭文件流 | Close file stream
> # row_data.close()
> 
> # 使用 `with ... as ...` 语法 读取文件
> try:
>     with open(FILE_PATH, encoding='UTF-8') as row_data:
>         contents = row_data.read()
>         print('contents=', contents)
> except Exception as error:
>     print('Error info:', error)
> 
> # 自定义读取文件大小 | Custom read file size
> try:
>     with open(FILE_PATH, encoding='UTF-8') as row_data:
>         row_content = ''
>         SIZE = 328
>         while True:
>             content = row_data.read(SIZE)
>             if not content:
>                 print('Read finished\n')
>                 break
>             row_content += content
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('row_content=', row_content)
> 
> # 读取文件行内容 | Read file line content
> try:
>     with open(FILE_PATH, encoding='UTF-8') as row_data:
>         readline_content = row_data.readline()
>         readlines_content = row_data.readlines()
>         for x in row_data:
>             print('content=', x)
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('readline_content=', readline_content)
>     print('readlines_content=', readlines_content[1])
> 
> # 写入文件 | Write to file
> '''
> 'r'     open for reading (default)
> 'w'    open for writing, truncating the file first
> 'x'     open for exclusive creation, failing if the file already exists
> 'a'     open for writing, appending to the end of the file if it exists
> 'b'     binary mode
> 't'     text mode (default)
> '+'     open for updating (reading and writing)
> 
> 写入文件 参数 `r` : 表示当前文件为只读模式
> 写入文件 参数 `+` : 操作符添加功能
> 写入文件 参数 `w` : 表示写入内容时, 将覆盖当前所有文件内容, 如文件不存在, 则> 将创建文件并写入内容至文件中
> 写入文件 参数 `a` : 表示写入内容时, 将追加到当前文件中, 如文件不存在, 则将创> 建文件并写入内容至文件中
> '''
> try:
>     with open(FILE_PATH, 'a') as row_data:
>         # row_data.write('Write to file')
>         print(row_data)
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('row_data=', row_data)
> 
> # 读取 二进制文件 | Read binary file
> '''
> 'b'     binary mode
> 't'     text mode (default)
> '''
> try:
>     with open(FILE_PATHS, 'rb') as row_datas:
>         # byte_size = 100
>         # r = row_datas.read(byte_size)
>         # print('Binary File=', r)
>         # 写入 二进制文件 | Write binary file
>         NEW_FILE_PATH = '../resources/row_file/binary_data.jpg'
>         with open(NEW_FILE_PATH, 'wb') as new_binary_data:
>             byte_size = 1024 * 100
>             new_data = ''
>             while True:
>                 row_res = row_datas.read(byte_size)
>                 if not row_res:
>                     print('Read finished\n')
>                     break
>                 new_binary_data.write(row_res)
>                 new_data += new_binary_data
> except Exception as error:
>     print('Error info:', error)
> finally:
>     print('new_data=', new_data)
> 
> # 修改 & 查询 读取位置 | Modify & Inquire Read Location
> try:
>     with open(FILE_PATH, 'rb') as row_data:
>         SIZE = 328
>         '''
>         seek方法 参数说明
>         参数 一: 切换读取位置
>         参数 二: 计算位置方式 默认值0 从首部计算, 1 从当前位置计算 , 2 从末尾位置开始计算
>         '''
>         seek_data = row_data.seek(328)
>         tell_data = row_data.tell()
>         print('Read position -->', tell_data)
>         print(row_data.read(SIZE))
> except Exception as error:
>     print('Error info:', error)
> 
> # 文件其他操作 | File other operations
> # `os模块` 可以让开发者对操作系统进行访问
> import os
> from pprint import pprint
> 
> # 创建目录 | Create a directory
> mk = os.mkdir('../resources/row_file/test_dir')
> 
> # 删除目录 | Delete directory
> # rm = os.rmdir('../resources/row_file/test_dir')
> 
> # 查看当前或指定文件列表 | View a list of current or specified files
> dir = os.listdir('.')
> pprint(dir)
> 
> # 切换目录 | Change directory
> cd_dir = os.chdir('..')
> pprint(cd_dir)
> 
> # 查看当前文件目录 | View the current file directory
> pwd = os.getcwd()
> pprint(pwd)
> 
> # 文件重命名和移动文件 | File renaming And moving files
> # os.rename('xxx', 'yyy')
> 
> # 删除文件 | Delete Files
> os.remove(NEW_FILE_PATH)
> ```

## 💥 8. Python 高级篇💥
### 8.1 Python 正则表达式
> 正则表达式是一个特殊的字符序列, 它能帮助开发者方便检查一个字符串是否与某种模式匹配.
> 
> `re模块`使Python语言拥有全部的正则表达式功能.
> 
> `compile函数`根据一个模式字符串和可选的标志参数生成一个正则表达式对象, 该对象拥有一系列方法用于正则表达式匹配和替换.
> 
> `re模块`也提供了与这些方法功能完全一致的函数, 这些函数使用一个模式字符串做为它们的第一个参数.
> 
> **1. match function**
> 
> `re.match`尝试从字符串的起始位置匹配一个模式, 如果不是起始位置匹配成功的话, match()就返回none.
> 
> 函数语法: `re.match(pattern, string, flags=0)`
> 
> 函数参数说明 : 
> 
> | 参数      |     描述 |
> | :--------: | :--------:|
> | `pattern`    |   匹配的正则表达式 |
> | `string`    |   要匹配的字符串 |
> | `flags`    |   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 |
> 
> 匹配成功re.match方法返回一个匹配的对象, 否则返回None
> 
> 还可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式.
> 
> | 匹配对象方法      |     描述 |
> | :--------: | :--------:|
> | `group(num=0)`    |   匹配的整个表达式的字符串, group()可以一次输入多个组号, 在这种情况下它将返回一个包含那些组所对应值的元组 |
> | `groups()`    |   返回一个包含所有小组字符串的元组, 从1到 所含的小组号 |
> 
>**2. search method**
>
> `re.search`扫描整个字符串并返回第一个成功的匹配.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 正则表达式 | Regular expression
> # @File : 13_regular_expression.py
> # @Description : Python 进阶篇 - 正则表达式 | Python Advanced articles - Regular Expressions
> 
> # 导入模块 | Import module
> import re
> 
> # match函数 | match function
> '''
> `match`尝试从字符串的起始位置匹配一个模式
> 如果不是起始位置匹配成功的话, match()就返回None
> 函数 语法: `re.match(pattern, string, flags=0)`
> '''
> 
> 
> # 定义 函数 | Definition function
> def fun1():
>     # 在起始位置匹配 | Match at starting position
>     r1 = re.match('www', 'www.geekparkhub.com').span()
>     print(r1)
>     # 不在起始位置匹配 | Do not match at the beginning
>     r2 = re.match('com', 'www.geekparkhub.com')
>     print(r2)
> 
> 
> # 定义常量 | Defining constants
> data1 = 'Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.'
> 
> 
> # 定义 函数 | Definition function
> def fun2(values):
>     r3 = re.match(r'(.*?) .*? Open (.*) .*', values, re.M | re.I)
>     if r3:
>         print('r3.group()=', r3.group())
>         print('r3.group(1)=', r3.group(1))
>         print('r3.group(2)=', r3.group(2))
>     else:
>         print('Match failed!')
> 
> 
> # search 方法 | search method
> '''
> `re.search` 扫描整个字符串并返回第一个成功的匹配
> 函数语法: `re.search(pattern, string, flags=0)`
> '''
> 
> 
> # 定义 函数 | Definition function
> def fun3():
>     # 在起始位置匹配 | Match at starting position
>     r1 = re.search('www', 'www.geekparkhub.com').span()
>     print(r1)
>     # 不在起始位置匹配 | Do not match at the beginning
>     r2 = re.search('com', 'www.geekparkhub.com').span()
>     print(r2)
> 
> 
> # 定义 函数 | Definition function
> def fun4(values):
>     r4 = re.search(r'(.*?) .*? Open (.*) .*', values, re.M | re.I)
>     if r4:
>         print('r4.group()=', r4.group())
>         print('r4.group(1)=', r4.group(1))
>         print('r4.group(2)=', r4.group(2))
>     else:
>         print('Match failed!')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     fun1()
>     fun2(data1)
>     fun3()
>     fun4(data1)
> ```
> 
> **re.match与re.search的区别**
> re.match只匹配字符串的开始, 如果字符串开始不符合正则表达式, 则匹配失败, 函数返回None, 而re.search匹配整个字符串直到找到一个匹配.
> 
> **3. 检索和替换**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 正则表达式 | Regular expression
> # @File : 13_regular_expression.py
> # @Description : Python 进阶篇 - 正则表达式 | Python Advanced articles - Regular Expressions
> 
> # 导入模块 | Import module
> import re
> 
> # 检索和替换 | Retrieve and replace
> '''
> sub用于替换字符串中的匹配项
> 语法: `re.sub(pattern, repl, string, count=0, flags=0)`
> 参数: pattern : 正则中的模式字符串
>         repl : 替换的字符串, 也可为一个函数
>         string : 要被查找替换的原始字符串
>         count : 模式匹配后替换的最大次数, 默认 0 表示替换所有的匹配
> '''
> # 定义常量 | Defining constants
> data2 = '123-456-789 # 替换字符串中的匹配项'
> 
> 
> # 定义 函数 | Definition function
> def fun5(values):
>     # 删除`Python注释`字符串
>     r5 = re.sub(r'#.*$', "", values)
>     # 删除`-`字符串
>     r6 = re.sub(r'\D', "", values)
>     print('r5=', r5)
>     print('r6=', r6)
> 
> 
> '''
> repl 函数
> 将字符串中的匹配的数字乘11
> '''
> # 定义常量 | Defining constants
> data3 = 'P45G3GKFC755'
> 
> 
> # 定义 函数 | Definition function
> def fun6(matched):
>    r7 = int(matched.group('value'))
>     return str(r7 * 11)
> 
> 
> r8 = re.sub('(?P<value>\d+)', fun6, data3)
> print('r8=', r8)
> 
> # compile 函数 | compile function
> '''
> `compile`函数用于编译正则表达式, 生成一个正则表达式(Pattern)对象供> `match()`&`search()`这两个函数使用
> 函数语法: `re.compile(pattern[, flags])`
> 参数说明: `pattern` 一个字符串形式的正则表达式
>               `flags`可选项, 表示匹配模式, 比如忽略大小写, 多行模式等, 具体参数为：
>                     1. `re.I 忽略大小写` 2. `re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境`
>                     3. `re.M 多行模式` 4. `re.S 即为 . 并且包括换行符在内的任意字符 (. 不包括换行符)`
>                     5. `re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库`
>                     6. `re.X 为了增加可读性, 忽略空格和 # 后面的注释`
> '''
> # 定义常量 | Defining constants
> data4 = 'one12twothree34four'
> data5 = 'Hello Python'
> 
> 
> # 定义 函数 | Definition function
> def fun7(values):
>     r9 = re.compile(r'\d+')  # 用于匹配至少一个数字
>     r10 = r9.match(values, 3, 10)  # 从'1'的位置开始匹配
>     r11 = r10.group(0)
>     r12 = r10.start(0)
>     r13 = r10.end(0)
>     r14 = r10.span(0)
>     print('r10=', r10)
>     print('group=', r11)
>     print('start=', r12)
>     print('end=', r13)
>     print('span=', r14)
> 
> 
> # 定义 函数 | Definition function
> def fun8(values):
>     r15 = re.compile(r'([a-z]+) ([a-z]+)', re.I)  # `re.I`表示忽略大小写
>     r16 = r15.match(values)
>     r17 = r16.group(0)  # 返回匹配成功的整个子串
>     r18 = r16.group(1)  # 返回第一个分组匹配成功的子串
>     r19 = r16.group(2)  # 返回第二个分组匹配成功的子串
>     r20 = r16.span(1)  # 返回第一个分组匹配成功的子串的索引
>     r21 = r16.span(2)  # 返回第二个分组匹配成功的子串
>     r22 = r16.groups(1)  # 等价于 r16.group(1), r16.group(2), ...)
>     print('r16=', r16)
>     print('r17=', r17)
>     print('r18=', r18)
>     print('r19=', r19)
>     print('r20=', r20)
>     print('r20=', r20)
>     print('r21=', r21)
>     print('r22=', r22)
> 
> 
> # findall & finditer & split
> '''
> `findall` 在字符串中找到正则表达式所匹配的所有子串并返回一个列表, 如果没有找到匹配的则返回空列表
> 注意: `match` & `search` 是匹配一次, 而`findall`匹配所有
> 语法: `findall(string[, pos[, endpos]])`
> 参数说明: 
>             `string` 待匹配的字符串
>             `pos` 可选参数, 指定字符串的起始位置, 默认为0
>             `endpos` 可选参数指定字符串的结束位置, 默认为字符串的长度
>             
>=================================================================================
> 
> `finditer` 和 `findall` 类似, 在字符串中找到正则表达式所匹配的所有子串并把它们作为一个迭代器返回.
> 语法: `re.finditer(pattern, string, flags=0)`
> 参数说明: 
>             `pattern` 匹配的正则表达式
>             `string` 要匹配的字符串
>             `flags` 标志位用于控制正则表达式的匹配方式, 如是否区分大小写, 多行匹配等等
>             
> =================================================================================
> 
> `split` 方法按照能够匹配的子串将字符串分割后返回列表
> 语法: `re.split(pattern, string[, maxsplit=0, flags=0])`
> 参数说明: 
>             `pattern` 匹配的正则表达式
>             `string` 要匹配的字符串
>             `maxsplit` 分隔次数, `maxsplit=1`分隔一次, 默认为0, 不限制次数
>             `flags` 标志位用于控制正则表达式的匹配方式, 如是否区分大小写, 多行匹配等等
> '''
> # 查找字符串中所有数字
> # 定义常量 | Defining constants
> data6 = 'd4qw564df56qw456qw4f56q465df4qwef'
> 
> 
> # 定义 函数 | Definition function
> def fun9(values):
>     r23 = re.compile(r'\d+')  # 检索数字
>     r24 = r23.findall(values, 0, 33)
>     print('r24=', r24)
>     r25 = re.finditer(r'\d+', values)
>     for x in r25:
>         print('r25=', x.group())
> 
> 
> # 定义常量 | Defining constants
> data7 = 'Java, C, GoLang, Python'
> 
> 
> # 定义 函数 | Definition function
> def fun10(values):
>     r26 = re.split('(\W+)', values, 1)
>     print('r26=', r26)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     fun4(data1)
>     fun5(data2)
>     fun7(data4)
>     fun8(data5)
>     fun9(data6)
>     fun10(data7)
> ```
> **4. 正则表达式修饰符 - 可选标志**
> 
> 正则表达式可以包含一些可选标志修饰符来控制匹配的模式, 修饰符被指定为一个可选的标志, 多个标志可以通过按位 OR(|) 它们来指定, 如 re.I | re.M 被设置成 I 和 M 标志.
> 
> | 修饰符      |     	描述 |
> | :--------: | :--------:|
> | `re.I`    |   使匹配对大小写不敏感 |
> | `re.L`    |   做本地化识别 (locale-aware)匹配 |
> | `re.M`    |   多行匹配, 影响 ^ 和 $ |
> | `re.S`    |   使 . 匹配包括换行在内的所有字符 |
> | `re.U`    |   根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. |
> | `re.X`    |   该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 |
> 
> **4. 正则表达式模式**
> - 模式字符串使用特殊的语法来表示一个正则表达式：
> - 字母和数字表示他们自身, 一个正则表达式模式中的字母和数字匹配同样的字符串.
> - 多数字母和数字前加一个反斜杠时会拥有不同的含义.
> - 标点符号只有被转义时才匹配自身, 否则它们表示特殊的含义.
> - 反斜杠本身需要使用反斜杠转义.
> - 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 '\\t')匹配相应的特殊字符.
> - 下表列出了正则表达式模式语法中的特殊元素, 如果使用模式的同时提供了可选的标志参数, 某些模式元素的含义会改变.
> - 贪婪匹配:   默认向更多次数匹配  (底层用的是回溯算法)
> - 非贪婪匹配: 默认向更少次数匹配 (量词的后面加?号), (1)量词( * ? + {} )加上问号？表示非贪婪 惰性匹配, (2)例:.*?w 表示匹配任意长度任意字符遇到一个w就立即停止.
> 
> | 模式      |     	描述 |
> | :--------: | :--------:|
> | `^`    |   匹配字符串的开头 |
> | `$`    |   匹配字符串的末尾 |
> | `.`    |   匹配任意字符, 除了换行符, 当`re.DOTALL`标记被指定时, 则可以匹配包括换行符的任意字符 |
> | `[...]`    |   用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k' |
> | `[^...]`    |   不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符 |
> | `re*`    |  匹配0个或多个的表达式 |
> | `re+`    |   匹配1个或多个的表达式 |
> | `re?`    |   匹配0个或1个由前面的正则表达式定义的片段, 非贪婪方式 |
> | `re{ n}`    |   精确匹配n个前面表达式, 例如o{2}不能匹配"Bob"中的"o", 但是能匹配"food"中的两个o |
> | `re{ n,}`    |   匹配 n 个前面表达式, 例如o{2,}不能匹配"Bob"中的"o", 但能匹配 ="foooood"中的所有o, "o{1,}"等价于 "o+", "o{0,}"则等价于"o*" |
> | `re{ n, m}`    |   匹配 n 到 m 次由前面的正则表达式定义的片段, 贪婪方式 |
> | `a 或运算符 b`    |   	匹配a或b |
> | `(re)`    |   对正则表达式分组并记住匹配的文本 |
> | `(?imx)`    |   正则表达式包含三种可选标志：i, m, 或 x, 只影响括号中的区域 |
> | `(?-imx)`   |   正则表达式关闭 i, m, 或 x 可选标志, 只影响括号中的区域 |
> | `(?: re)`   |   类似 (...), 但是不表示一个组 |
> | `(?imx: re)`   |   在括号中使用i, m, 或 x 可选标志 |
> | `(?-imx: re)`   |   在括号中不使用i, m, 或 x 可选标志 |
> | `(?#...)`   |   注释 |
> | `(?= re)`   |   前向肯定界定符, 如果所含正则表达式以 ... 表示, 在当前位置成功匹配时成功否则失败, 但一旦所含表达式已经尝试, 匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边 |
> | `(?! re)`   |   前向否定界定符, 与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 |
> | `(?> re)`   |   匹配的独立模式, 省去回溯 |
> | `\w`   |   匹配字母数字及下划线 |
> | `\W`   |   匹配非字母数字及下划线 |
> | `\s`   |  匹配任意空白字符, 等价于 [\t\n\r\f] |
> | `\S`   |   匹配任意非空字符 |
> | `\d`   |   匹配任意数字, 等价于 [0-9] |
> | `\D`   |   匹配任意非数字 |
> | `\A`   |   匹配字符串开始 |
> | `\Z`   |  匹配字符串结束, 如果是存在换行, 只匹配到换行前的结束字符串 |
> | `\z`   |   匹配字符串结束 |
> | `\G`   |   匹配最后匹配完成的位置 |
> | `\b`   |   匹配一个单词边界, 也就是指单词和空格间的位置, 例如 'er\b' 可以匹配"never" 中的 'er', 但不能匹配 "verb" 中的 'er' |
> | `\B`   |   匹配非单词边界, 'er\B' 能匹配 "verb" 中的 'er', 但不能匹配 "never" 中的 'er' |
> | `\n, \t, 等`   |   匹配一个换行符, 匹配一个制表符等等 |
> | `\1...\9`   |   匹配第n个分组的内容 |
> | `\10`   |   匹配第n个分组的内容, 如果它经匹配, 否则指的是八进制字符码的表达式 |
> 
> **5. 正则表达式实例**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 正则表达式 | Regular expression
> # @File : 13_regular_expression.py
> # @Description : Python 进阶篇 - 正则表达式 | Python Advanced articles - Regular Expressions
> 
> # 正则表达式实例 | Regular expression example
> # 匹配 字符类 | Match character class
> '''
> 匹配 "Python" 或 "python" | Matches "Python" or "python"
> '''
> # 定义常量 | Defining constants
> data9 = 'Python'
> r29 = re.match(r'[Pp]', data9, re.M | re.I).group()
> print('r29=', r29)
> 
> '''
> 匹配 "ruby" 或 "rube" | Matches "ruby" or "rube"
> '''
> # 定义常量 | Defining constants
> data10 = 'rube'
> r30 = re.match(r'rub[ye]', data10, re.M | re.I).group()
> print('r30=', r30)
> 
> '''
> 匹配中括号内的任意一个字母 | Matches any letter in brackets
> '''
> # 定义常量 | Defining constants
> data11 = 'dswdwdwletters'
> r31 = re.search(r'[letter]', data11, re.M | re.I).group()
> print('r31=', r31)
> 
> '''
> 匹配任何数字, 类似 [0123456789] | Matches any number, like [0123456789]
> '''
> # 定义常量 | Defining constants
> data12 = '56468547564897748'
> r32 = re.search(r'[0-9]', data12, re.M | re.I).group()
> print('r32=', r32)
> 
> '''
> 匹配任何小写字母 | Matches any lowercase letter
> '''
> # 定义常量 | Defining constants
> data13 = 'Python'
> r33 = re.search(r'([a-z])', data13, re.M).group()
> print('r33=', r33)
> 
> '''
> 匹配任何大写字母 | Match any capital letter
> '''
> # 定义常量 | Defining constants
> data14 = 'Ai'
> r34 = re.search(r'([A-Z])', data14, re.M).group()
> print('r34=', r34)
> 
> '''
> 匹配任何字母及数字 | Match any letter and number
> '''
> # 定义常量 | Defining constants
> data15 = 'fe45dwq4'
> r35 = re.search(r'([a-zA-Z0-9])', data15, re.M | re.I).group()
> print('r35=', r35)
> 
> '''
> 除了index字母以外的所有字符 | All characters except the index letter
> '''
> # 定义常量 | Defining constants
> data16 = '4564d4d4wq847d4dqfefindex'
> r36 = re.finditer(r'[^index]', data16)
> for x in r36:
>     print('r36=', x.group())
> 
> '''
> 匹配除了数字外的字符 | Matches characters other than numbers
> '''
> # 定义常量 | Defining constants
> data17 = 'sfe4d55w74f4ef45wf4f45w6f4ew5f5w'
> r37 = re.findall(r'[^0-9]', data17)
> for x in r37:
>     print('r37=', x)
> 
> # 匹配 特殊字符类 | Match special character class
> '''
> 匹配除 "\n" 之外的任何单个字符, 要匹配包括 '\n'在内的任何字符, 请使用类似 '[.\n]' 模式
> '''
> # 定义常量 | Defining constants
> data18 = 'Hello\nWorld!'
> r38 = re.search(r'[^.\n]', data18, re.M | re.I).group()
> print('r38=', r38)
> 
> '''
> 匹配一个数字字符, 等价于 [0-9] | Matches a numeric character, equivalent to [0-9]
> '''
> # 定义常量 | Defining constants
> data19 = '78448522144455487'
> r39 = re.match(r'\d', data19).group()
> print('r39=', r39)
> 
> '''
> 匹配一个非数字字符。等价于 [^0-9] " | Matches a non-numeric character. Equivalent to [^ 0-9]
> '''
> # 定义常量 | Defining constants
> data20 = 'das78df448few5f2214wefe4455487fewfewf'
> r40 = re.match(r'\D', data20).group()
> print('r40=', r40)
> 
> '''
> 匹配任何空白字符, 包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]
> '''
> # 定义常量 | Defining constants
> data21 = 'vefewr\fefew\nkkkfj\rdwdw\t4474\vsqsq'
> r41 = re.search(r'\s', data21, re.U | re.I).group()
> print('r41=', r41)
> 
> '''
> 匹配任何非空白字符, 等价于 [^ \f\n\r\t\v] | Matches any non-whitespace character, equivalent to [^ \ f \ n \ r \ t \ v]
> '''
> # 定义常量 | Defining constants
> data22 = 'vefewr\fefew\nkkkfj\rdwdw\t4474\vsqsq'
> r42 = re.search(r'\S', data22, re.M | re.I).group()
> print('r42=', r42)
> 
> '''
> 匹配包括下划线的任何单词字符, 等价于'[A-Za-z0-9_]' | Matches any word character including underscore, equivalent to '[A-Za-z0-9_]'
'''
> # 定义常量 | Defining constants
> data23 = 'qsq454_qsq44dqw475d'
> r43 = re.search(r'\w', data23, re.M | re.I).group()
> print('r43=', r43)
> 
> '''
> 匹配任何非单词字符, 等价于 '[^A-Za-z0-9_]' | Matches any non-word character, equivalent to '[^ A-Za-z0-9_]'
> '''
> # 定义常量 | Defining constants
> data24 = 'qsq45_4qsq\t44dqw4_75d'
> r44 = re.search(r'[\W]', data24, re.M | re.I).group()
> print('r44=', r44)
> ```



### 8.2 Python Web开发
#### 8.2.1 前言
> 
> 最早的软件都是运行在大型机上的软件使用者通过“哑终端”登陆到大型机上去运行软件, 后来随着PC机的兴起, 软件开始主要运行在桌面上, 而数据库这样的软件运行在服务器端, 这种`Client / Server`模式简称`CS架构`.
> 
> 随着互联网的兴起, 人们发现CS架构不适合Web, 最大的原因是Web应用程序的修改和升级非常迅速, 而CS架构需要每个客户端逐个升级桌面App, 因此`Browser / Server`模式开始流行, 简称`BS架构`.
> 
> 在BS架构下客户端只需要浏览器, 应用程序的逻辑和数据都存储在服务器端, 浏览器只需要请求服务器获取Web页面, 并把Web页面展示给用户即可.
> 
> 当然Web页面也具有极强的交互性, 由于Web页面是用HTML编写, 而HTML具备超强的表现力, 并且服务器端升级后, 客户端无需任何部署就可以使用到新的版本, 因此BS架构迅速流行起来.
> 
> 如今除了重量级的软件如Office、Photoshop等, 大部分软件都以Web形式提供。比如新浪提供的新闻、博客、微博等服务均是Web应用.
> 
> **1. Web开发 发展演变**
> - 1.`静态WebPage`: 由文本编辑器直接编辑并生成静态的HTML页面, 如果要修改Web页面内容, 就需要再次编辑HTML源文件, 早期的互联网Web就是静态页面.
> - 2.`CGI编程`: 由于静态Web页面无法与用户交互, 比如用户填写了一个注册表单, 静态Web页面就无法处理, 要处理用户发送的动态数据, 出现了Common Gateway Interface, 简称CGI, 用C/C++编写.
> - 3.`ASP/JSP/PHP`: 由于Web应用特点是修改频繁, 用C/C++这样的低级语言非常不适合Web开发, 而脚本语言由于开发效率高, 与HTML结合紧密, 因此迅速取代了CGI模式, ASP是微软推出的用VBScript脚本编程的Web开发技术, 而JSP用Java来编写脚本, PHP本身则是开源的脚本语言.
> - 4.`MVC`: 为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题, Web应用也引入了`Model-View-Controller`的模式来简化Web开发, ASP发展为ASP.Net, JSP和PHP也有一大堆MVC框架.
> 
> 目前Web开发技术仍在快速发展中, 异步开发、新的MVVM前端技术层出不穷.
> 
> Python的诞生历史比Web还要早, 由于Python是一种解释型的脚本语言, 开发效率高, 所以非常适合用来做Web开发.
> 
> Python有上百种Web开发框架, 有很多成熟的模板技术, 选择Python开发Web应用, 不但开发效率高而且运行速度快.

#### 8.2.2 HTTP协议 简介
> 在Web应用中服务器把网页传给浏览器, 实际上就是把网页的HTML代码发送给浏览器, 让浏览器显示出来, 而浏览器和服务器之间的传输协议是HTTP, 所以HTML是一种用来定义网页的文本, 学会HTML就可以编写网页, HTTP是在网络上传输HTML的协议, 用于浏览器和服务器的通信.
> 
> 在地址栏输入`www.sina.com.cn`时浏览器将显示新浪首页, 就可以看到浏览器发给新浪服务器的请求：
> 
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/950413532592512)
> 
> `GET / HTTP/1.1` 含义
> `GET`表示一个读取请求, 将从服务器获得网页数据, `/`表示URL的路径, URL总是以`/`开头, `/`就表示首页, 最后的`HTTP/1.1`指示采用的HTTP协议版本是1.1, 目前HTTP协议的版本就是1.1, 但是大部分服务器也支持1.0版本, 主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接以加快传输速度.
> 
> `Host: www.sina.com.cn`含义
> 表示请求的域名是`www.sina.com.cn`, 如果一台服务器有多个网站, 服务器就需要通过Host来区分浏览器请求的是哪个网站.
> 
> HTTP响应分为Header和Body两部分(Body是可选项), 在Network中看到的Header最重要的几行如下:
> 
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/950413553562752)
> 
> `200 OK`含义
> `200`表示一个成功的响应, 后面的OK是说明, 失败的响应有404 Not Found：网页不存在, 500 Internal Server Error：服务器内部出错等等.
> 
> `Content-Type: text/html`含义
> `Content-Type`指示响应的内容, 这里是text/html表示HTML网页, 请注意浏览器就是依靠Content-Type来判断响应的内容是网页还是图片, 是视频还是音乐, 浏览器并不靠URL来判断响应的内容, 所以即使URL是`http://example.com/abc.jpg`, 它也不一定就是图片.
> 
> **HTTP请求**
> - 1.浏览器首先向服务器发送HTTP请求, 请求包括方法：GET还是POST, GET仅请求资源, POST会附带用户数据, 路径：/full/url/path, 域名：由Host头指定：Host: www.xxx.com, 以及其他相关的Header, 如果是POST，那么请求还包括一个Body, 包含用户数据.
> - 2.服务器向浏览器返回HTTP响应, 响应包括, 响应代码：200表示成功, 3xx表示重定向, 4xx表示客户端发送的请求有错误, 5xx表示服务器端处理时发生了错误, 响应类型：由Content-Type指定, 例如：`Content-Type: text/html;charset=utf-8`表示响应类型是HTML文本, 且编码是UTF-8, `Content-Type: image/jpeg`表示响应类型是JPEG格式的图片, 以及其他相关的Header, 通常服务器的HTTP响应会携带内容, 也就是有一个Body, 包含响应的内容, 网页的HTML源码就在Body中.
> - 3.如果浏览器还需要继续向服务器请求其他资源比如图片就再次发出HTTP请求, 重复步骤1、2, Web采用的HTTP协议采用了非常简单的请求-响应模式, 从而大大简化了开发, 当在编写一个页面时只需要在HTTP响应中把HTML发送出去, 不需要考虑如何附带图片、视频等, 浏览器如果需要请求图片和视频, 它会发送另一个HTTP请求, 因此一个HTTP请求只处理一个资源.
> 
> **HTTP格式**
> 每个HTTP请求和响应都遵循相同的格式, 一个HTTP包含Header和Body两部分, 其中Body是可选.
> HTTP协议是一种文本协议, 所以它的格式也非常简单, HTTP GET请求的格式:
> ```
> GET /path HTTP/1.1
> Header1: Value1
> Header2: Value2
> Header3: Value3
> ```
> 每个Header一行一个, 换行符是`\r\n`.
> 
> - HTTP POST请求的格式:
>  
> ```
> POST /path HTTP/1.1
> Header1: Value1
> Header2: Value2
> Header3: Value3
>  
> body data goes here...
> ```
> 当遇到连续两个`\r\n`时, Header部分结束, 后面的数据全部是Body.
> 
> - HTTP响应的格式:
> 
> ```
> 200 OK
> Header1: Value1
> Header2: Value2
> Header3: Value3
> 
> body data goes here...
> ```
> 
> HTTP响应如果包含body也是通过`\r\n\r\n`来分隔的, 请再次注意Body的数据类型由Content-Type头来确定, 如果是网页, Body就是文本, 如果是图片, Body就是图片的二进制数据.
> 
> 当存在Content-Encoding时, Body数据是被压缩的, 最常见的压缩方式是gzip, 所以看到Content-Encoding: gzip时, 需要将Body数据先解压缩才能得到真正的数据, 压缩的目的在于减少Body的大小加快网络传输.

#### 8.2.3 HTML 简介
> 网页中不但包含文字, 还有图片、视频、Flash小游戏, 有复杂的排版、动画效果, 所以HTML定义了一套语法规则, 来告诉浏览器如何把一个丰富多彩的页面显示出来.
> 
> 可以用文本编辑器编写HTML, 然后保存为hello.html, 双击或者把文件拖到浏览器中, 就可以看到效果:
> 
> ``` html
> <html>
> <head>
>   <title>Hello</title>
> </head>
> <body>
>   <h1>Hello, world!</h1>
> </body>
> </html>
> ```
> 
> HTML文档就是一系列的Tag组成, 最外层的Tag是`<html>`, 规范的HTML也包含`<head>...</head>`和`<body>...</body>`(注意不要和HTTP的Header、Body搞混了), 由于HTML是富文档模型, 所以还有一系列的Tag用来表示链接、图片、表格、表单等等.
> 
> **CSS 简介**
> 
> CSS是Cascading Style Sheets(层叠样式表)的简称, CSS用来控制HTML里所有元素如何展现, 比如给标题元素`<h1>`加一个样式, 变成48号字体, 灰色, 带阴影等.
> 
> ``` html
> <html>
> <head>
>   <title>Hello</title>
>   <style>
>     h1 {
>       color: #333333;
>       font-size: 48px;
>       text-shadow: 3px 3px 3px #666666;
>     }
>   </style>
> </head>
> <body>
>   <h1>Hello, world!</h1>
> </body>
> </html>
> ```
> 
> **JavaScript 简介**
> 
> JavaScript虽然名称有个Java, 但它和Java真的一点关系没有, JavaScript是为了让HTML具有交互性而作为脚本语言添加的, JavaScript既可以内嵌到HTML中, 也可以从外部链接到HTML中, 如果希望当用户点击标题时把标题变成红色, 就必须通过JavaScript来实现.
> ``` html
> <html>
> <head>
>   <title>Hello</title>
>   <style>
>     h1 {
>       color: #333333;
>       font-size: 48px;
>       text-shadow: 3px 3px 3px #666666;
>     }
>   </style>
>   <script>
>     function change() {
>       document.getElementsByTagName('h1')[0].style.color = '#ff0000';
>     }
>   </script>
> </head>
> <body>
>   <h1 onclick="change()">Hello, world!</h1>
> </body>
> </html>
> ```
> 
> 如果要学习Web开发, 首先要对HTML、CSS和JavaScript作一定的了解, HTML定义了页面的内容, CSS来控制页面元素的样式, 而JavaScript负责页面的交互逻辑.
> 
> 讲解HTML、CSS和JavaScript就可以写3本书, 对于优秀的Web开发人员来说, 精通HTML、CSS和JavaScript是必须的，这里推荐一个在线学习网站w3schools：http://www.w3school.com.cn/
> 
> 当使用Python或者其他语言开发Web应用时, 就是要在服务器端动态创建出HTML, 这样浏览器就会向不同的用户显示出不同的Web页面.


#### 8.2.4 WSGI 接口
> 了解了HTTP协议和HTML文档, 其实就明白了一个Web应用的本质就是:
> - 1 .浏览器发送一个HTTP请求.
> - 2.服务器收到请求, 生成一个HTML文档.
> - 3.服务器把HTML文档作为HTTP响应的Body发送给浏览器.
> - 4.浏览器收到HTTP响应, 从HTTP Body取出HTML文档并显示.
> 
> 所以最简单的Web应用就是先把HTML用文件保存好, 用一个现成的HTTP服务器软件接收用户请求, 从文件中读取HTML，返回.
> 正确的做法是底层代码由专门的服务器软件实现, 使用Python专注于生成HTML文档, 因为我们不希望接触到TCP连接、HTTP原始请求和响应格式, 所以需要一个统一的接口, 专心用Python编写Web业务.
> 
> 这个接口就是`WSGI`：(`Web Server Gateway Interface`)
> 
> WSGI接口定义非常简单, 它只要求Web开发者实现一个函数就可以响应HTTP请求, 下面演示最简单的Web版本的“Hello, web!”
> **1. 定义 WSGI处理函数**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : Web开发 | Web development
> # @File : _14_web_development.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # WSGI 接口 | WSGI interface
> 
> # 定义 HTTP处理函数 | Define HTTP handler function
> '''
> 参数说明:
>             `env` 包含所有HTTP请求信息的字典对象
>             `start_response` 发送HTTP响应的函数
> '''
> 
> 
> def wsgi_function(env, start_response):
>     start_response('200 OK', [('Content-Type', 'text/html')])
>     body = '<h1>Hello %s !</h1>' % (env['PATH_INFO'][1:] or 'web')
>     return [body.encode('UTF-8')]
> ```
> 
> **2. 定义 启动WSGI函数**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : Web开发 | Web development
> # @File : __init__.py.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # 导入模块 | Import module
> from wsgiref.simple_server import make_server as mk
> from _14_web_development._14_web_development import wsgi_function as wd
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 启动WSGI服务器 | Start the WSGI server
>     httpd = mk('', 9800, wd)
>     print('Serving HTTP on port 9800...')
>     httpd.serve_forever()
> ```
> **3. 启动 服务端口**
> ```
> 127.0.0.1 - - [26/] "GET /main HTTP/1.1" 200 21
> 127.0.0.1 - - [26/] "GET /favicon.ico HTTP/1.1" 200 28
> 127.0.0.1 - - [26/] "GET /world HTTP/1.1" 200 22
> 127.0.0.1 - - [26/] "GET /favicon.ico HTTP/1.1" 200 28
> 127.0.0.1 - - [26/] "GET /system HTTP/1.1" 200 23
> ```

#### 8.2.5 Web 框架
> 了解了WSGI框架并发现就是编写一个WSGI的处理函数, 针对每个HTTP请求进行响应.
> 
> 由于用Python开发一个Web框架十分容易, 所以Python有上百个开源的Web框架, 选择一个比较流行的Web框架——Flask来使用.
> 
> **1. 安装flask API**
> ```
> (venv) systemhub:python_server system$ pip install flask
> Collecting flask
> ```
> 
> **2. 编写处理程序**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : flask_server
> # @File : flask_server.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # 导入模块 | Import module
> from flask import Flask
> from flask import request as req
> 
> # 初始化 | initialization
> service = Flask(__name__)
> '''
> 请求类型 & 处理响应说明: 
>     请求类型：GET请求 | 处理响应：'/'  返回Home首页
>    请求类型：GET请求 | 处理响应：`/signin` 返回登录页, 显示登录表单
>     请求类型：POST | 处理响应：`/signin` 处理登录表单，显示登录结果
> '''
> 
> 
> # 定义 处理Home路由 | Define Handle Home routing
> @service.route('/', methods=['GET', 'POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def home():
>     return '''
>     <h1>Welcome to Home</h1> 
>     <p><a href="/signin">Sign In</a></p>
>     '''
> 
> 
> # 定义 处理登录路由 | Definition Handle Login Route
> @service.route('/signin', methods=['GET'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def signin_form():
>     return '''
>     <form action="/signin" method="post">
>     <p><input name="UserName"/></p>
>     <p><input name="PassWord" type="password"/></p>
>     <p><a href="/">Return Home</a></p>
>     <p><button type="submit">Sign In</button></p>
>     </form>
>     '''
> 
> 
> # 定义 登录路由 | Define login routes
> @service.route('/signin', methods=['POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def signin():
>     # 验证登录信息 | Verify login information
>     if req.form['UserName'] == 'Admin' and req.form['PassWord'] == 'password':
>         return '''
>         <h3>Hello Admin!</h3> <p><a href="/">Return Home</a></p>
>         '''
>     return '<h3>Bad UserName or PassWord.</h3>'
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 启动运行服务 | Start running service
>     service.run()
> ```
> 
> **3. 启动 服务端口**
> ```
> * Serving Flask app "flask_server" (lazy loading)
> * Environment: production
> WARNING: This is a development server. Do not use it in a production deployment.
> Use a production WSGI server instead.
> * Debug mode: off
> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
> 127.0.0.1 - - [2] "GET / HTTP/1.1" 200 -
> 127.0.0.1 - - [2] "GET /signin HTTP/1.1" 200 -
> 127.0.0.1 - - [2] "POST /signin HTTP/1.1" 200 -
> 127.0.0.1 - - [2] "GET / HTTP/1.1" 200 -
> ```
> 
> 实际的Web应该拿到用户名和口令后与数据库查询再比对, 来判断用户是否能登录成功.
> 
> 除了Flask, 常见的Python Web框架还有: 
> 
> [全能型Web框架 `Django`](https://www.djangoproject.com/) | [小巧的Web框架 `web.py`](http://webpy.org/)
> 
> [和Flask类似的Web框架 `Bottle`](http://bottlepy.org/) | [Facebook的开源异步Web框架 `Tornado`](http://www.tornadoweb.org/)


#### 8.2.6 Web Template
> Web框架把WSGI中拯救出来了, 现在只需要不断地编写函数带上URL, 就可以继续开发Web App.
> 
> 由于在Python代码里拼字符串是不现实的, 所以模板技术出现了.
> 
> 使用模板, 需要预先准备一个HTML文档, 该HTML文档不是普通的HTML, 而是嵌入了一些变量和指令, 然后根据传入的数据替换后得到最终的HTML发送给用户, 该过程称之为MVC：`Model-View-Controller`: 模型-视图-控制器
> 
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/951383573211136)
> 
> Python处理URL的函数就是C(控制器)：Controller负责业务逻辑, 比如检查用户名是否存在, 获取用户信息等等.
> 
> 包含变量```{{ name }}```的模板就是V(视图层)：View负责显示逻辑, 通过简单地替换一些变量, View最终输出的就是用户看到的HTML.
> 
> Model是用来传给View(视图层), 这样View在替换变量的时候就可以从Model中取出相应的数据, 只是因为Python支持关键字参数, 很多Web框架允许传入关键字参数, 然后在框架内部组装出一个dict作为Model.
> 
> Flask通过```render_template()```函数来实现模板的渲染, 和Web框架类似Python的模板也有很多种, Flask默认支持的模板是`jinja2`
> 
> **1. 安装 jinja2**
> ```
> (venv) systemhub:python_server system$ pip install jinja2
> ```
> 
> **2. 编写 模板**
> 
> - 2.1 home.html | 用来显示首页模板
> 
> ``` html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <title>Home Page</title>
> </head>
> <body>
> <h1 style="font-style:italic">Home</h1>
> </body>
> </html>
> ```
> 
> - 2.2 login.html | 用来显示登录表单模板
> 
> ``` html
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <title>Please Sign In</title>
> </head>
> <body>
> {% if message %}
> <p style="color:red">{{ message }}</p>
> {% endif %}
> <form action="/signin" method="post">
>     <legend>Please sign in:</legend>
>     <p><input name="username" placeholder="Username" value="{{ username }}"></p>
>     <p><input name="password" placeholder="Password" type="password"></p>
>     <p><button type="submit">Sign In</button></p>
> </form>
> </body>
> </html>
> ```
> 
> - 2.3 main.html | 登录成功后个人主页模板
> 
> ```
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <title>Welcome, {{ username }}</title>
> </head>
> <body>
> <p>Welcome, {{ username }}!</p>
> </body>
> </html>
> ```
> 
> **3. 编写控制层 服务**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : mvc_server
> # @File : mvc_server.py
> # @Description : Python 进阶篇 - Web开发 | Advanced Python - Web Development
> 
> # 导入模块 | Import module
> from flask import Flask, request as req, render_template as rt
> 
> # 初始化 | initialization
> service = Flask(__name__)
> 
> '''
> 请求类型 & 处理响应说明: 
>     请求类型：GET请求 | 处理响应：'/'  返回Home首页
>     请求类型：GET请求 | 处理响应：`/signin` 返回登录页, 显示登录表单
>     请求类型：POST | 处理响应：`/signin` 处理登录表单，显示登录结果
> '''
> 
> 
> # 定义 处理Home路由 | Define Handle Home routing
> @service.route('/', methods=['GET', 'POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def home():
>     return rt('home.html')
> 
> 
> # 定义 处理登录路由 | Definition Handle Login Route
> @service.route('/signin', methods=['GET'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def login():
>     return rt('login.html')
> 
> 
> # 定义 登录路由 | Define login routes
> @service.route('/signin', methods=['POST'])
> # 定义 处理响应函数 | Definition Processing Response Function
> def signin():
>     # 验证登录信息 | Verify login information
>     username = req.form['username']
>     password = req.form['password']
>     if username == 'Admin' and password == '0000x':
>         return rt('main.html', username=username)
>     return rt('login.html', message='Bad username or password', username=username)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 启动运行服务 | Start running service
>     service.run()
> ```
> **4. 启动 MVC服务**
> ```
> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
>  * Serving Flask app "mvc_server" (lazy loading)
>  * Environment: production
>    WARNING: This is a development server. Do not use it in a production deployment.
>    Use a production WSGI server instead.
>  * Debug mode: off
>  127.0.0.1 - - [26] "GET / HTTP/1.1" 200 -
>  127.0.0.1 - - [2] "GET /signin HTTP/1.1" 200 -
>  127.0.0.1 - - [2] "POST /signin HTTP/1.1" 200 -
> ```
> 
> 通过MVC在Python代码中处理M：Model和C：Controller，而V：View是通过模板处理的, 这样就成功地把Python代码和HTML代码最大限度地分离了.
> 
> 使用模板的另一大好处是模板改起来很方便, 而且改完保存后刷新浏览器就能看到最新的效果.
> 除了Jinja2, 常见的模板还有: 
> - Mako：用```<% ... %>```和```${xxx}```的一个模板: http://www.makotemplates.org/
> - Cheetah：也是用```<% ... %>```和```${xxx}```的一个模板: http://www.cheetahtemplate.org/
> - Django：Django是一站式框架，内置一个用```{% ... %}```和```{{ xxx }}```的模板: https://www.djangoproject.com/


### 8.3 Python DataBase
#### 8.3.1 前言
> 程序运行的时数据都是在内存中的, 当程序终止的时, 通常都需要将数据保存到磁盘上, 无论是保存到本地磁盘, 还是通过网络保存到服务器上最终都会将数据写入磁盘文件.
> 
> 为了便于程序保存和读取数据, 而且能直接通过条件快速查询到指定的数据, 就出现了数据库(Database)这种专门用于集中存储和查询的软件.
> 
> 数据库软件诞生的历史非常久远, 早在1950年数据库就诞生了, 经历了网状数据库, 层次数据库, 现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的.
> 

#### 8.3.2 SQLite
> SQLite是一种嵌入式数据库, 它的数据库就是一个文件, 由于SQLite本身是C写的而且体积很小, 所以经常被集成到各种应用程序中, 甚至在iOS和Android的App中都可以集成.
> 
> Python定义了一套操作数据库的API接口, 任何数据库要连接到Python, 只需要提供符合Python标准的数据库驱动即可.
> 
> 由于SQLite的驱动内置在Python标准库中, 所以可以直接来操作SQLite数据库.
> 
> 使用Python的DB-API时, 只要搞清楚`Connection`和`Cursor`对象, 打开后一定记得关闭就可以放心地使用.
> 
> 使用`Cursor`对象执行`insert`, `update`, `delete`语句时, 执行结果由`rowcount`返回影响的行数就可以拿到执行结果.
> 
> 使用`Cursor`对象执行`select`语句时通过`featchall()`可以拿到结果集, 结果集是一个`list`, 每个元素都是一个`tuple`对应一行记录.
> 
> 在Python中操作数据库时, 要先导入数据库对应的驱动, 然后通过`Connection对象`和`Cursor对象`操作数据.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据库 | database
> # @File : 15_database.py
> # @Description : Python 进阶篇 - 数据库 | Advanced Python-Database
> 
> # 导入模块 | Import module
> import sqlite3 as sl
> import os as o
> 
> # 数据库 for SQLite | Database for SQLite
> 
> # 定义 函数 | Defining functions
> def database_for_sqlite_insert():
>     '''
>     连接到SQLite数据库, 数据库文件是test.db
>     如果文件不存在则自动在当前目录创建
>     '''
>     connection = sl.connect('test.db')
> 
>     # 创建 Cursor | Create Cursor
>     cursor = connection.cursor()
> 
>     # 创建 数据表 | Create data table
>     cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
> 
>     # 创建 插入语句 | Create insert statement
>     cursor.execute('insert into user (id, name) values (\'1\', \'system\')')
> 
>     # 通过rowcount获得插入的行数 | Get the number of inserted rows by rowcount
>     print('rowcount=', cursor.rowcount)
> 
>     # 关闭Cursor | Close Cursor
>     cursor.close()
> 
>     # 提交事务 | Commit transaction
>     connection.commit()
> 
>     # 关闭资源 | Close resource
>     connection.close()
> 
> 
> def database_for_sqlite_select():
>     '''
>     连接到SQLite数据库, 数据库文件是test.db
>     如果文件不存在则自动在当前目录创建
>     '''
> 
>     connection = sl.connect('test.db')
> 
>     # 创建 Cursor | Create Cursor
>     cursor = connection.cursor()
> 
>     # 执行查询语句 | Execute query
>     cursor.execute('select * from user where id=?', '1')
> 
>     # 获得查询结果集 | Get query result set
>     values = cursor.fetchall()
>     print('values=', values)
> 
>     # 关闭Cursor | Close Cursor
>     cursor.close()
> 
>     # 关闭资源 | Close resource
>     connection.close()
> 
> # 定义 类 | Definition class
> class Student:
>     # 定义 初始化 方法 | Define initialization method
>     def __init__(self):
>         db_file = o.path.join(o.path.dirname(__file__), 'student_test.db')
>         if o.path.isfile(db_file):
>             o.remove(db_file)
>         # 创建 连接 | Create connection
>         conn = sl.connect(db_file)
>         # 创建 Cursor | Create Cursor
>         cursor = conn.cursor()
>         cursor.execute('create table student(id varchar(20) primary key, name varchar(20), score int)')
>         cursor.execute(r"insert into student values ('A-001', 'Adam', 95)")
>         cursor.execute(r"insert into student values ('A-002', 'Bart', 62)")
>         cursor.execute(r"insert into student values ('A-003', 'Lisa', 78)")
>         cursor.close()
>         conn.commit()
>         conn.close()
> 
>     # 定义 方法 | 返回指定分数区间的姓名, 按分数从低到高排序
>     def get_score_in(self, low, high):
>         global cursor, connection
>         try:
>             connection = sl.connect('student_test.db')
>             cursor = connection.cursor()
>             cursor.execute('select name from student where score >=? and score <=? order by score', (low, high))
>             values = cursor.fetchall()
>             return list(map(lambda v: v[0], values))
>         except BaseException as e:
>             print('Connection Error!', e)
>         finally:
>             cursor.close()
>             connection.close()
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     database_for_sqlite_insert()
>     database_for_sqlite_select()
>         s = Student()
>     s.__init__()
>     print('score: 80~95=', s.get_score_in(80, 95))
>     print('score: 60~80=', s.get_score_in(60, 80))
>     print('score: 60~100=', s.get_score_in(60, 100))
> ```

#### 8.3.3 MySQL
> MySQL是Web世界中使用最广泛的数据库服务器, SQLite的特点是轻量级、可嵌入, 但不能承受高并发访问, 适合桌面和移动应用, 而MySQL是为服务器端设计的数据库能承受高并发访问, 同时占用的内存也远远大于SQLite, 此外MySQL内部有多种数据库引擎, 最常用的引擎是支持数据库事务的InnoDB.
> 
> **安装MySQL驱动**
> 由于MySQL服务器以独立的进程运行并通过网络对外服务, 所以需要支持Python的MySQL驱动来连接到MySQL服务器, MySQL官方提供了mysql-connector-python驱动, 但是安装的时候需要给pip命令加上参数`--allow-external`
> ```
> (venv) systemhub:python_server system$ pip install mysql-connector
> ```
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据库 | database
> # @File : 15_database.py
> # @Description : Python 进阶篇 - 数据库 | Advanced Python-Database
> 
> # 导入模块 | Import module
> import sqlite3 as sl
> import os as o
> # install mysql-connector-python:
> # pip3 install mysql-connector-python --allow-external mysql-connector-python
> import mysql.connector
> 
> # 数据库 for MySQL | Database for MySQL
> # 定义 函数 | Defining functions
> def database_for_mysql():
>     # change root password to yours:
>     conn = mysql.connector.connect(user='root', password='password', database='test')
> 
>     cursor = conn.cursor()
>     # 创建user表
>     cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
>     # 插入一行记录，注意MySQL的占位符是%s:
>     cursor.execute('insert into user (id, name) values (%s, %s)', ('1', 'system'))
>     print('rowcount =', cursor.rowcount)
>     # 提交事务 | Commit transaction
>     conn.commit()
>    # 关闭资源 | Close resource
>     cursor.close()
> 
>     # 运行查询
>     cursor = conn.cursor()
>     cursor.execute('select * from user where id = %s', ('1',))
>     values = cursor.fetchall()
>     print(values)
>     # 关闭Cursor和Connection:
>     cursor.close()
>     conn.close()
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     database_for_mysql()
> ```


#### 8.3.4 SQLAlchemy
> 数据库表是一个二维表, 包含多行多列, 把一个表的内容用Python的数据结构表示出来的话, 可以用一个list表示多行, list的每一个元素是tuple表示一行记录, 比如包含id和name的user表: 
> ```
> [
>     ('1', 'system001'),
>     ('2', 'system002'),
>     ('3', 'system003')
> ]
> ```
> Python的DB-API返回的数据结构就是像上面这样表示.
> 
> 但是用tuple表示一行很难看出表的结构, 如果把一个tuple用class实例来表示就可以更容易地看出表的结构来：
> 
> Object-Relational Mapping, 把关系数据库的表结构映射到对象上简称为(对象关系映射)`ORM`.
> 
> ``` py
> class User(object):
>     def __init__(self, id, name):
>         self.id = id
>         self.name = name
> 
> [
>     User('1', 'system001'),
>     User('2', 'system002'),
>     User('3', 'system003')
> ]
> ```
> 
> 在Python中最有名的ORM框架是SQLAlchemy, 下面看看SQLAlchemy用法:
> 
> **安装SQLAlchemy**
> ```
> pip install sqlalchemy
> ```
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 数据库 | database
> # @File : 15_database.py
> # @Description : Python 进阶篇 - 数据库 | Advanced Python-Database
> 
> # 导入模块 | Import module
> import sqlite3 as sl
> import os as o
> # install mysql-connector-python:
> # pip3 install mysql-connector-python --allow-external mysql-connector-python
> import mysql.connector
> from sqlalchemy import Column, String, create_engine
> from sqlalchemy.orm import sessionmaker
> from sqlalchemy.ext.declarative import declarative_base
> 
> # 数据库 for SQL Alchemy | Database for SQL Alchemy
> # 定义 函数 | Defining functions
> def database_for_sqlalchemy():
>     # 创建对象的基类:
>     Base = declarative_base()
> 
>     # 定义User对象:
>     class User(Base):
>         # 表的名字:
>         __tablename__ = 'user'
> 
>         # 表的结构:
>         id = Column(String(20), primary_key=True)
>         name = Column(String(20))
> 
>     # 初始化数据库连接:
>     engine = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')
>     # 创建DBSession类型:
>     DBSession = sessionmaker(bind=engine)
> 
>     # 创建session对象:
>     session = DBSession()
>     # 创建新User对象:
>     new_user = User(id='5', name='Bob')
>     # 添加到session:
>     session.add(new_user)
>     # 提交即保存到数据库:
>     session.commit()
>     # 关闭session:
>     session.close()
> 
>     # 创建Session:
>     session = DBSession()
>     # 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
>     user = session.query(User).filter(User.id == '5').one()
>     # 打印类型和对象的name属性:
>     print('type:', type(user))
>     print('name:', user.name)
>     # 关闭Session:
>     session.close()
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':    
>       database_for_sqlalchemy() 
> ```


### 8.4 Python 网络编程
#### 8.4.1 前言
> 自从互联网诞生以来, 现在基本上所有的程序都是网络程序, 很少有单机版的程序.
> 
> 由于你的电脑上可能不止浏览器, 还有QQ、Skype、Dropbox、邮件客户端等, 不同的程序连接的别的计算机也会不同, 所以, 更确切地说网络通信是两台计算机上的两个进程之间的通信, 比如浏览器进程和新浪服务器上的某个Web服务进程在通信, 而QQ进程是和腾讯的某个服务器上的某个进程在通信.
> 
> 网络编程对所有开发语言都是一样, Python也不例外,使用Python进行网络编程就是在Python程序本身这个进程内, 连接别的服务器进程的通信端口进行通信.
> 
> Python 提供了两个级别访问的网络服务:
> - 1.低级别的网络服务支持基本的Socket, 它提供了标准的 BSD Sockets API, 可以访问底层操作系统Socket接口的全部方法.
> - 2.高级别的网络服务模块 SocketServer, 它提供了服务器中心类, 可以简化网络服务器的开发.

#### 8.4.2 TCP/IP 简介
> 计算机为了联网就必须规定通信协议, 早期的计算机网络都是由各厂商自己规定一套协议, IBM、Apple和Microsoft都有各自的网络协议, 互不兼容, 这就好比一群人有的说英语, 有的说中文, 有的说德语, 说同一种语言的人可以交流, 不同的语言之间就不行了.
> 
> 为了把全世界的所有不同类型的计算机都连接起来就必须规定一套全球通用的协议, 为了实现互联网这个目标, 互联网协议簇（Internet Protocol Suite）就是通用协议标准, Internet是由inter和net两个单词组合起来的, 原意就是连接“网络”的网络有了Internet, 任何私有网络只要支持这个协议就可以联入互联网.
> 
> 因为互联网协议包含了上百种协议标准, 但是最重要的两个协议是TCP和IP协议, 所以把互联网的协议简称TCP/IP协议.
> 
> 通信的时候双方必须知道对方的标识, 好比发邮件必须知道对方的邮件地址, 互联网上每个计算机的唯一标识就是IP地址，类似`123.123.123.123`, 如果一台计算机同时接入到两个或更多的网络, 比如路由器它就会有两个或多个IP地址, 所以IP地址对应的实际上是计算机的网络接口通常是网卡.
> 
> IP协议负责把数据从一台计算机通过网络发送到另一台计算机, 数据被分割成一小块一小块, 然后通过IP包发送出去, 由于互联网链路复杂, 两台计算机之间经常有多条线路, 因此路由器就负责决定如何把一个IP包转发出去, IP包的特点是按块发送, 途径多个路由但不保证能到达也不保证顺序到达.
> 
> TCP协议则是建立在IP协议之上的, TCP协议负责在两台计算机之间建立可靠连接保证数据包按顺序到达, TCP协议会通过握手建立连接, 然后对每个IP包编号, 确保对方按顺序收到, 如果包丢掉了就自动重发.
> 
> 许多常用的更高级的协议都是建立在TCP协议基础上的, 比如用于浏览器的HTTP协议、发送邮件的SMTP协议等.
> 
> 一个TCP报文除了包含要传输的数据外, 还包含源IP地址和目标IP地址, 源端口和目标端口.
> 
> 一个进程也可能同时与多个计算机建立链接, 因此它会申请很多端口.
> 
> 了解了TCP/IP协议的基本概念, IP地址和端口的概念, 下面就可以开始进行网络编程.

#### 8.4.3 TCP 编程
> Socket是网络编程的一个抽象概念, 通常用一个Socket表示“打开了一个网络链接”, 而打开一个Socket需要知道目标计算机的IP地址和端口号再指定协议类型即可.
> 
> **1. 客户端**
> 大多数连接都是可靠的TCP连接, 创建TCP连接时主动发起连接的叫客户端, 被动响应连接的叫服务器.
> 
> **2. 服务器**
> 和客户端编程相比服务器编程就要复杂一些, 服务器进程首先要绑定一个端口并监听来自其他客户端的连接, 如果某个客户端连接过来了, 服务器就与该客户端建立Socket连接随后的通信就靠这个Socket连接了.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : TCP 网络编程 | TCP network programming
> # @File : tcp_socket.py
> # @Description :  Python 进阶篇 - 网络编程 | Advanced Python-Network Programming
> 
> # 导入模块 | Import module
> import socket as sk
> 
> 
> # 定义 函数 | Defining functions
> def socket_function():
>     # 创建 Socket | Create Socket
>     '''
>     参数说明 :
>                 `AF_INET6` 指定IPv6网络协议
>                 `SOCK_STREAM` 指定面向流TCP协议
>     '''
>     s = sk.socket(sk.AF_INET6, sk.SOCK_STREAM)
> 
>     # 创建 连接 | Create connection
>     '''
>     定义 服务器IP地址&端口号
>     '''
>     s.connect(('58.49.227.129', 80))
> 
>     # 发送 数据 | send data
>     '''
>     向服务端发送请求
>     '''
>     s.send(b'GET / HTTP/1.1\r\nHost: 58.49.227.129\r\nConnection: close\r\n\r\n')
> 
>     # 接收 数据 | Receive data
>     buffer = []
>     while True:
>         byte_size = s.recv(1024)
>         if byte_size:
>             buffer.append(byte_size)
>         else:
>             break
>     data = b' '.join(buffer)
> 
>     # 关闭资源 | Close resource
>     s.close()
> 
>     header, html = data.split(b'\r\n\r\n', 1)
>     print(header.decode('UTF-8'))
> 
>     # 数据写入文件
>     with open('test.html', 'wb') as f:
>         f.write(html)
>         
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     socket_function()         
> ```

#### 8.4.4 UDP 编程
> TCP是建立可靠连接并且通信双方都可以以流的形式发送数据, 相对TCP, UDP则是面向无连接的协议.
> 
> 使用UDP协议时不需要建立连接, 只需要知道对方的IP地址和端口号就可以直接发数据包, 但是能不能到达就不知道了.
> 
> 虽然用UDP传输数据不可靠, 但它的优点是和TCP比, 速度快, 对于不要求可靠到达的数据就可以使用UDP协议.
> 
> UDP的使用与TCP类似, 但是不需要建立连接, 此外服务器绑定UDP端口和TCP端口互不冲突, 也就是说UDP的9999端口与TCP的9999端口可以各自绑定.
> 
> **udp_socket_server**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : UDP 网络编程 | UDP network programming
> # @File : udp_socket_server.py
> # @Description : Python 进阶篇 - 网络编程 | Advanced Python-Network Programming
> 
> # 导入模块 | Import module
> import socket as sk
> 
> 
> # 定义 服务端 函数 | Defining Server functions
> def udp_server():
>     # 创建 Socket | Create Socket
>     '''
>     参数说明 :
>                 `AF_INET` 指定IPv4网络协议
>                 `SOCK_STREAM` 指定面向流TCP协议
>     '''
>     s = sk.socket(sk.AF_INET, sk.SOCK_DGRAM)
> 
>     # 绑定 端口 | Bind port
>     s.bind(('127.0.0.1', 9999))
> 
>     print('Bind UDP on 9999...')
> 
>     # 接收 数据 | Receive data
>     while True:
>         data, addr = s.recvfrom(1024)
>         print('Received From %s:%s.' % addr)
>         reply = 'Hello, %s!' % data.decode('UTF-8')
>         s.sendto(reply.encode('UTF-8'), addr)
> 
> 
> # 调用 函数 | call function
> udp_server()
> ```
> 
> **udp_socket_client**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : UDP 网络编程 | UDP network programming
> # @File : udp_socket_client.py
> # @Description : Python 进阶篇 - 网络编程 | Advanced Python-Network Programming
> 
> # 导入模块 | Import module
> import socket as sk
> 
> 
> # 定义 客户端 函数 | Defining Client functions
> def udp_client():
>     # 创建 Socket | Create Socket
>     '''
>     参数说明 :
>                 `AF_INET` 指定IPv4网络协议
>                 `SOCK_STREAM` 指定面向流TCP协议
>     '''
>     s = sk.socket(sk.AF_INET, sk.SOCK_DGRAM)
> 
>     lists = [b'Edward', b'System', b'Juliet', b'Romeo']
> 
>     for x in lists:
>         # 发送数据 | send data
>         s.sendto(x, ('127.0.0.1', 9999))
>         # 接收数据 | Receive data
>         print(s.recv(1024).decode('UTF-8'))
>     # 关闭资源 | Close resource
>     s.close()
> 
> 
> # 调用 函数 | call function
> udp_client()
> ```


### 8.5 Python SMTP
#### 8.5.1 前言
> SMTP (Simple Mail Transfer Protocol)即简单邮件传输协议, 它是一组用于由源地址到目的地址传送邮件的规则, 由它来控制信件的中转方式.
> 
> python的smtplib提供了一种很方便的途径发送电子邮件, 它对smtp协议进行了简单的封装.

#### 8.5.2 SMTP发送邮件
> SMTP是发送邮件的协议, Python内置对SMTP的支持, 可以发送纯文本邮件、HTML邮件以及带附件的邮件.
> 
> Python对SMTP支持有`smtplib`和`email`两个模块, `email`负责构造邮件, `smtplib`负责发送邮件.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 邮件 | mail
> # @File : 17_mail.py
> # @Description : Python 进阶篇 - 邮件 | Advanced Python - Mail
> 
> # 导入模块 | Import module
> from email import encoders as ed
> from email.header import Header as hd
> from email.mime.text import MIMEText as mt
> from email.utils import parseaddr as pa, formataddr as fa
> import smtplib as st
> 
> 
> # 定义 格式化地址 函数 | Definition format address function
> def _format_addr(s):
>     name, addr = pa(s)
>     return fa((hd(name, 'UTF-8').encode(), addr))
> 
> 
> # 定义 发送邮件 函数 | Define send mail function
> def send_function():
>     from_addr = input('From: \n')  # 输入Email地址 | Enter email address
>     password = input('Password: \n')  # 输入Email地址口令 | Enter email address and password
>     to_addr = input('To: \n')  # 输入收件人地址 | Enter recipient address
>     smtp_server = input('SMTP server: \n')  # 输入SMTP服务器地址 | Enter SMTP server address
> 
>     '''
>     构造MIMEText对象
>     参数说明: 
>                 `Hello, Send by Python...` 表示邮件正文
>                 `plain` 表示邮件类型为纯文本
>                 `UTF-8` 表示邮件编码
>     '''
>     message = mt('Hello, Send by Python...', 'plain', 'UTF-8')
>     message['From'] = _format_addr('Dev <%s>' % from_addr)
>     message['To'] = _format_addr('Administrator <%s>' % to_addr)
>     message['Subject'] = hd('Greetings from SMTP……', 'UTF-8').encode()
> 
>     server = st.SMTP(smtp_server, 25)  # 定义 SMTP协议默认端口 | Define the SMTP protocol default port
>     server.set_debuglevel(1)  # 打印SMTP服务器交互信息 | Print SMTP server interaction information
>     server.login(from_addr, password)  # 登录SMTP服务器 | Log in to the SMTP server
>     server.sendmail(from_addr, [to_addr], message.as_string())  # 发送邮件 | send email
>     server.quit()  # 退出SMTP服务器 | Exit SMTP server
> 
> 
> # 调用 函数 | call function
> send_function()
> ```

#### 8.5.3 POP3收取邮件
> 收取邮件就是编写一个MUA作为客户端, MDA把邮件获取到用户的电脑或者手机上, 收取邮件最常用的协议是POP协议, 目前版本号是3, 称之为POP3.
> 
> Python内置`poplib`模块, 实现了POP3协议, 可以直接用来收邮件.
> 
> 注意到POP3协议收取的不是一个已经可以阅读的邮件本身而是邮件的原始文本, 这和SMTP协议很像, SMTP发送的也是经过编码后的一大段文本.
> 
> 要把POP3收取的文本变成可以阅读的邮件, 还需要用email模块提供的各种类来解析原始文本变成可阅读的邮件对象, 所以收取邮件分两步:
> - 1.使用poplib把邮件的原始文本下载到本地.
> - 2.使用email解析原始文本，还原为邮件对象.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 邮件 | mail
> # @File : 17_mail.py
> # @Description : Python 进阶篇 - 邮件 | Advanced Python - Mail
> 
> # 导入模块 | Import module
> from email import encoders as ed
> from email.header import Header as hd
> from email.mime.text import MIMEText as mt
> from email.utils import parseaddr as pa, formataddr as fa
> from email.parser import Parser as ps
> from email.header import decode_header as dh
> import poplib as pl
> 
> # 定义 收取邮件 函数 | Define receive mail function
> def receive_mail():
>     # 输入邮件地址&口令&POP3服务器地址 | Enter email address & password & POP 3 server address
>     email = input('Email: ')
>     password = input('Password: ')
>     pop3_server = input('POP3 server: ')
>     # 连接到POP3服务器:
>     server = pl.POP3(pop3_server)
>     # 可以打开或关闭调试信息:
>     server.set_debuglevel(1)
>     # 可选:打印POP3服务器的欢迎文字:
>     print(server.getwelcome().decode('utf-8'))
>     # 身份认证:
>     server.user(email)
>     server.pass_(password)
>     # stat()返回邮件数量和占用空间:
>     print('Messages: %s. Size: %s' % server.stat())
>     # list()返回所有邮件的编号:
>     resp, mails, octets = server.list()
>     # 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]
>     print(mails)
>     # 获取最新一封邮件, 注意索引号从1开始:
>     index = len(mails)
>     resp, lines, octets = server.retr(index)
>     # lines存储了邮件的原始文本的每一行,
>     # 可以获得整个邮件的原始文本:
>     msg_content = b'\r\n'.join(lines).decode('UTF-8')
>     # 稍后解析出邮件:
>     msg = ps().parsestr(msg_content)
>     print_info(msg)
>     # 可以根据邮件索引号直接从服务器删除邮件:
>     # server.dele(index)
>     # 关闭连接:
>     server.quit()
> 
> 
> # 定义 查找字符集 函数 | Definition Find Character Set Function
> def guess_charset(msg):
>     charset = msg.get_charset()
>     if charset is None:
>         content_type = msg.get('Content-Type', '').lower()
>         pos = content_type.find('charset=')
>         if pos >= 0:
>             charset = content_type[pos + 8:].strip()
>     return charset
> 
> 
> # 定义 解码字符集 函数 | Definition decode character set function
> def decode_str(s):
>     value, charset = dh(s)[0]
>     if charset:
>         value = value.decode(charset)
>     return value
> 
> 
> # 定义 打印信息 函数 | Definition print information function
> def print_info(msg, indent=0):
>     if indent == 0:
>         for header in ['From', 'To', 'Subject']:
>             value = msg.get(header, '')
>             if value:
>                 if header == 'Subject':
>                     value = decode_str(value)
>                 else:
>                     hdr, addr = pa(value)
>                     name = decode_str(hdr)
>                     value = u'%s <%s>' % (name, addr)
>             print('%s%s: %s' % ('  ' * indent, header, value))
>     if (msg.is_multipart()):
>         parts = msg.get_payload()
>         for n, part in enumerate(parts):
>             print('%spart %s' % ('  ' * indent, n))
>             print('%s--------------------' % ('  ' * indent))
>             print_info(part, indent + 1)
>     else:
>         content_type = msg.get_content_type()
>         if content_type == 'text/plain' or content_type == 'text/html':
>             content = msg.get_payload(decode=True)
>             charset = guess_charset(msg)
>             if charset:
>                 content = content.decode(charset)
>             print('%sText: %s' % ('  ' * indent, content + '...'))
>         else:
>             print('%sAttachment: %s' % ('  ' * indent, content_type))
> 
> 
> # 调用 函数 | call function
> receive_mail()
> ```


### 8.6 Python 进程 & 线程
#### 8.6.1 前言
> 现代操作系统比如Mac OS X，UNIX，Linux，Windows等都是支持“多任务”的操作系统.
> 
> 简单地说就是操作系统可以同时运行多个任务, 打个比方你一边在用浏览器上网, 一边在听MP3, 一边在用办公, 这就是多任务, 至少同时有3个任务正在运行, 还有很多任务悄悄地在后台同时运行着, 只是桌面上没有显示而已.
> 
> 真正的并行执行多任务只能在多核CPU上实现, 但是由于任务数量远远多于CPU的核心数量, 所以操作系统也会自动把很多任务轮流调度到每个核心上执行.
> 
> 第一种是启动多个进程, 每个进程虽然只有一个线程, 但多个进程可以一块执行多个任务.
> 
> 第二种方法是启动一个进程, 在一个进程内启动多个线程, 这样多个线程也可以一块执行多个任务.
> 
> 第三种方法就是启动多个进程, 每个进程再启动多个线程, 这样同时执行的任务就更多了, 当然这种模型更复杂, 实际很少采用.
> 
> **多任务实现3种方式**
> - 1.多进程模式
> - 2.多线程模式
> - 3.多进程+多线程模式
> 
> 同时执行多个任务通常各个任务之间并不是没有关联的, 而是需要相互通信和协调, 有时任务1必须暂停等待任务2完成后才能继续执行, 有时任务3和任务4又不能同时执行, 所以多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序.
> 
> Python既支持多进程, 又支持多线程, 接下来将讨论如何编写这两种多任务程序.
> 
> 线程是最小的执行单元, 而进程由至少一个线程组成, 如何调度进程和线程, 完全由操作系统决定, 程序自己不能决定什么时候执行, 执行多长时间, 多进程和多线程的程序涉及到同步、数据共享的问题, 编写起来更复杂.

#### 8.6.2 多进程
> 要让Python程序实现多进程(multiprocessing), 下面先了解操作系统的相关知识.
> 
> Unix/Linux操作系统提供了一个fork()系统调用, 它非常特殊普通的函数调用, 调用一次, 返回一次, 但是fork()调用一次, 返回两次, 因为操作系统自动把当前进程(称为父进程)复制了一份(称为子进程), 然后分别在父进程和子进程内返回.
> 
> 子进程永远返回0, 而父进程返回子进程的ID, 这样做的理由是一个父进程可以fork出很多子进程, 所以父进程要记下每个子进程的ID, 而子进程只需要调用getppid()就可以拿到父进程的ID.
> 
> **1. 子进程**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import os as o
> 
> 
> # 定义 子进程 函数 | Definition Child process function
> def child_process_function():
>     print('Process (%s) start...' % o.getpid())
>     # Only works on Unix/Linux/Mac:
>     pid = o.fork()
>     if pid == 0:
>         print('I am child process (%s) and my parent is %s.' % (o.getegid(), o.getppid()))
>     else:
>         print('I (%s) just created a child process (%s).' % (o.getpid(), pid))
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     child_process_function()
> ```
> 
> **2. 跨平台多进程**
> 
> 由于Python是跨平台, 自然也应该提供一个跨平台的多进程支持, `multiprocessing`模块就是跨平台版本的多进程模块.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import os as o
> from multiprocessing import Process as pes
> 
> # 定义 运行过程 函数 | Definition run function
> def run_proc(name):
>     print('Run child process %s (%s)...' % (name, o.getpid()))
> 
> 
> # 定义 父进程 函数 | Definition parent process function
> def parent_process_function():
>     print('Parent process %s.' % o.getpid())
>     p = pes(target=run_proc, args=('test',))
>     print('Child process will start.')
>     p.start()
>     p.join()
>     print('Child process end.')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     parent_process_function()
> ```
> 
> **3. 进程池**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import os as o, time as te, random as rm
> from multiprocessing import Process as pes, Pool as pl
> 
> # 定义 进程池 函数 | Define process pool function
> def long_time_task(name):
>     print('Run task %s (%s)...' % (name, o.getpid()))
>     start = te.time()
>     te.sleep(rm.random() * 3)
>     end = te.time()
>     print('Task %s runs %0.2f seconds.' % (name, (end - start)))
> 
> 
> # 定义 子进程 函数 | Definition child process function
> def run_task():
>     print('Parent process %s.' % o.getpid())
>     p = pl(4)
>     for i in range(5):
>         p.apply_async(long_time_task, args=(i,))
>     print('Waiting for all subprocesses done...')
>     p.close()
>     p.join()
>     print('All subprocesses done.')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     run_task()
> ```
> 
> **4. 子进程**
> 
> 很多时候子进程并不是自身, 而是一个外部进程, 在创建了子进程后还需要控制子进程的输入和输出.
> 
> `subprocess`模块可以非常方便地启动一个子进程然后控制其输入和输出.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import subprocess as sp
> 
> # 定义 子进程 函数 | Definition child process function
> def child_process():
>     print('$ nslookup www.python.org')
>     r = sp.call(['nslookup', 'www.python.org'])
>     print('Exit code:', r)
> 
>     print('$ nslookup')
>     p = sp.Popen(['nslookup'], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
>     output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
>     print(output.decode('UTF-8'))
>     print('Exit code:', p.returncode)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     child_process()
> ```
> 
> **5. 进程通信**
> 
> Process之间肯定是需要通信的, 操作系统提供了很多机制来实现进程间的通信, Python的multiprocessing模块包装了底层的机制, 提供了Queue、Pipes等多种方式来交换数据.
> 
> 在父进程中创建两个子进程, 一个往Queue里写数据, 一个从Queue里读数据.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import os as o, time as te, random as rm
> from multiprocessing import Process as pes, Pool as pl, Queue as qu
> import subprocess as sp
> 
> # 进程通信 | Process communication
> 
> # 定义 写数据进程 函数 | Definition data write function
> def write_function(queue):
>     print('Process to write: %s' % o.getpid())
>     for value in ['A', 'B', 'C']:
>         print('Put %s to queue...' % value)
>         queue.put(value)
>         te.sleep(rm.random())
> 
> 
> # 定义 读数据进程 函数 | Definition data read function
> def read_function(queue):
>     print('Process to read: %s' % o.getpid())
>     while True:
>         value = queue.get(True)
>         print('Get %s from queue.' % value)
> 
> 
> # 定义 父进程队列 函数 | Define the parent process Queue function
> def parent_process_queue():
>     # 父进程创建Queue, 并传给各个子进程
>     q = qu()
>     pw = pes(target=write_function, args=(q,))
>     pr = pes(target=read_function, args=(q,))
>     # 启动子进程pw写入
>     pw.start()
>     # 启动子进程pr读取
>     pr.start()
>     # 等待pw结束
>     pw.join()
>     # pr进程里是死循环, 无法等待其结束, 只能强行终止:
>     pr.terminate()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     parent_process_function()
> ```
> 
> 在Unix/Linux下可以使用fork()调用实现多进程.
> 
> 要实现跨平台的多进程，可以使用multiprocessing模块.
> 
> 进程间通信是通过Queue、Pipes等实现.


#### 8.6.3 多线程
> 多任务可以由多进程完成也可以由一个进程内的多线程完成.
> 
> 进程是由若干线程组成的, 一个进程至少有一个线程.
> 
> 由于线程是操作系统直接支持的执行单元, 因此高级语言通常都内置多线程的支持, Python也不例外, 并且Python的线程是真正的`Posix Thread`, 而不是模拟出来的线程.
> 
> Python的标准库提供了两个模块：`_thread`和`threading`，`_thread`是低级模块, `threading`是高级模块, 对`_thread`进行了封装, 绝大多数情况下只需要使用`threading`高级模块.
> 
> 启动一个线程就是把一个函数传入并创建Thread实例, 然后调用start()开始执行
> ``` py
> # -*- coding:utf-8 -*-
> #
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation |
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> #
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import os as o, time as te, random as rm, threading as tg
> 
> # 多线程 | Multithreading
> # 定义 函数 | Definition function
> def loops():
>     print('Thread %s is Running...' % tg.current_thread().name)
>     x = 0
>     while x < 5:
>         x = x + 1
>         print('Thread %s >>> %s' % (tg.current_thread().name, x))
>         te.sleep(1)
>     print('Thread %s Ended.' % tg.current_thread().name)
> 
> 
> # 执行 多线程 函数 | Execute multithreaded function
> def run_loop():
>     print('Thread %s is Running...' % tg.current_thread().name)
>     t = tg.Thread(target=loops, name='LoopThread')
>     t.start()
>     t.join()
>     print('Thread %s Ended.' % tg.current_thread().name)
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     run_loop()
> ```

#### 8.6.4 ThreadLocal
> 在多线程环境下每个线程都有自己的数据, 一个线程使用自己的局部变量比使用全局变量好, 因为局部变量只有线程自己能看见, 不会影响其他线程而全局变量的修改必须加锁.
> 
> 一个ThreadLocal变量虽然是全局变量, 但每个线程都只能读写自己线程的独立副本互不干扰, ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题.
> 
> ``` py
> # -*- coding:utf-8 -*-
> #
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation |
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> #
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import os as o, time as te, random as rm, threading as tg
> 
> # 定义 本地线程 函数 | Define local thread function
> local_school = tg.local()
> 
> 
> def process_student():
>     # 获取当前线程关联的student
>     std = local_school.student
>     print('Hello, %s (in %s)' % (std, tg.current_thread().name))
> 
> 
> def process_thread(name):
>     # 绑定ThreadLocal的student
>     local_school.student = name
>     process_student()
> 
> 
> def run_native_thread():
>     t1 = tg.Thread(target=process_thread, args=('SYSTEM',), name='Thread-A')
>     t2 = tg.Thread(target=process_thread, args=('BOUUS',), name='Thread-B')
>     t1.start()
>     t2.start()
>     t1.join()
>     t2.join()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     run_native_thread()
> ```

#### 8.6.5 进程 Vs 线程
> 首先要实现多任务, 通常会设计Master-Worker模式, Master负责分配任务, Worker负责执行任务, 因此多任务环境下通常是一个Master, 多个Worker.
> 
> 如果用多进程实现Master-Worker, 主进程就是Master, 其他进程就是Worker
> 
> 如果用多线程实现Master-Worker, 主线程就是Master, 其他线程就是Worker
> 
> 多进程模式最大的优点就是稳定性高, 因为一个子进程崩溃了, 不会影响主进程和其他子进程


#### 8.6.6 分布式进程
> 在Thread和Process中应当优选Process, 因为Process更稳定, 而且Process可以分布到多台机器上, 而Thread最多只能分布到同一台机器的多个CPU上.
> 
> Python的multiprocessing模块不但支持多进程, 其中managers子模块还支持把多进程分布到多台机器上, 一个服务进程可以作为调度者, 将任务分布到其他多个进程中依靠网络通信, 由于managers模块封装很好, 不必了解网络通信的细节, 就可以很容易地编写分布式多进程程序.
> 
> Python的分布式进程接口简单, 封装良好, 适合需要把繁重任务分布到多台机器的环境下.
> 
> 注意Queue的作用是用来传递任务和接收结果, 每个任务的描述数据量要尽量小, 比如发送一个处理日志文件的任务, 就不要发送几百兆的日志文件本身, 而是发送日志文件存放的完整路径, 由Worker进程再去共享的磁盘上读取文件.
> 
> ``` py
> # -*- coding:utf-8 -*-
> #
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation |
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> #
> # @Author : system
> # @Version : 0.2.5
> # @Program : 线程 | Thread
> # @File : 18_thread.py
> # @Description : Python 进阶篇 - 线程 | Advanced Python - Threads
> 
> # 导入模块 | Import module
> import random as rd, time as t, queue as q, sys as s
> from multiprocessing.managers import BaseManager as bm
> 
> # 定义 发送任务队列 | Definition send task queue
> task_queue = q.Queue()
> 
> # 定义 接收结果队列 | Definition receive result queue
> result_queue = q.Queue()
> 
> 
> # 定义 任务Master 类 | Definition Task Master Class
> class TaskMaster(bm):
> 
>     # 定义 运行任务 方法 | Define Run Task Method
>     def run_task(self):
>         # 将两个Queue注册到网络, callable参数关联Queue对象
>         TaskMaster.register('get_task_queue', callable=lambda: task_queue)
>         TaskMaster.register('get_result_queue', callable=lambda: result_queue)
>         # 绑定5000端口, 设置验证码'abc'
>         manager = TaskMaster(address=('', 5000), authkey=b'abc')
>         # 启动Queue
>         manager.start()
>         # 获得通过网络访问的Queue对象
>         task = manager.get_task_queue()
>         result = manager.get_result_queue()
>         # 追加任务
>         for i in range(10):
>             n = rd.randint(0, 10000)
>             print('Put task %d...' % n)
>             task.put(n)
>         # 从result队列读取结果
>         print('Try get results...')
>         for i in range(10):
>             r = result.get(timeout=10)
>             print('Result: %s' % r)
>         # 关闭任务
>         manager.shutdown()
>         print('master exit.')
> 
> 
> # 定义 任务Worker 类 | Definition Task Worker Class
> class TaskWorker(bm):
> 
>     # 定义 运行任务 方法 | Define Run Task Method
>     def run_task(self):
>         # 由于TaskWorker通过网络获取Queue, 注册时提供队列名称
>         TaskWorker.register('get_task_queue')
>         TaskWorker.register('get_result_queue')
> 
>         # 连接到服务器, 也就是运行TaskMaster机器
>         server_addr = '127.0.0.1'
>         print('Connect to server %s...' % server_addr)
>         # 端口和验证码注意保持与TaskMaster设置完全一致
>         m = TaskWorker(address=(server_addr, 5000), authkey=b'abc')
>         # 网络连接
>         m.connect()
>         # 获取Queue对象
>         task = m.get_task_queue()
>         result = m.get_result_queue()
>         # 从task队列取任务, 并把结果写入result队列
>         for i in range(10):
>             try:
>                 n = task.get(timeout=1)
>                 print('run task %d * %d...' % (n, n))
>                 r = '%d * %d = %d' % (n, n, n * n)
>                 t.sleep(1)
>                 result.put(r)
>             except q.Empty:
>                 print('task queue is empty.')
>         # 处理结束
>         print('worker exit.')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
> 
>     # 创建实例 | Create instance
>     tm = TaskMaster()
>     tw = TaskWorker()
>     
>     # 调用 方法 | Call method
>     tm.run_task()
>     tw.run_task()
> ```


### 8.7 Python GUI 编程 (Tkinter)
#### 8.7.1 前言
> Python提供了多个图形开发界面的库, 常用 Python GUI库如下:
> - 1.`Tkinter`： Tkinter 模块(Tk接口)是 Python 的标准 Tk GUI 工具包的接口, Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里, Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中.
> - 2.`wxPython`：wxPython 是一款开源软件, 是 Python 语言的一套优秀的 GUI 图形库, 允许 Python 程序员很方便的创建完整的、功能健全的 GUI 用户界面.
> - 3.`Jython`：Jython 程序可以和 Java 无缝集成, 除了一些标准模块, Jython 使用 Java 的模块, Jython 几乎拥有标准的Python 中不依赖于 C 语言的全部模块。比如Jython 的用户界面将使用 Swing, AWT或者 SWT。Jython 可以被动态或静态地编译成 Java 字节码.

#### 8.7.2 Tkinter 编程
> Tkinter 是 Python 的标准 GUI 库, Python 使用 Tkinter 可以快速的创建 GUI 应用程序.
> 
> 由于 Tkinter 是内置到 python 的安装包中、只要安装好 Python 之后就能 import Tkinter 库、而且 IDLE 也是用 Tkinter 编写而成、对于简单的图形界面 Tkinter 还是能应付自如.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : GUI 编程 | GUI programming
> # @File : 19_gui_programming.py
> # @Description : Python 进阶篇 - GUI 编程 | Advanced Python - GUI Programming
> 
> # 导入模块 | Import module
> from tkinter import *
> import tkinter.messagebox as mb
> import turtle as te
> 
> 
> # 定义 GUI应用 类 | Define the GUI application class
> class GUIApplication(Frame):
> 
>     # 定义 初始化 方法 | Define initialization method
>     def __init__(self, master=None):
>         Frame.__init__(self, master)
>         self.pack()  # 调用 简单布局方法 | Call simple layout method
>         self.create_widgets()  # 调用 创建组件方法 | Call the create component method
> 
>     # 定义 创建组件 方法 | Definition create component method
>     def create_widgets(self):
>         self.nameInput = Entry(self)
>         self.nameInput.pack()
>         self.alertButton = Button(self, text='Hello', command=self.text_method)
>         self.alertButton.pack()
> 
>     # 定义 文本输出 方法 | Define text output method
>     def text_method(self):
>         name = self.nameInput.get() or 'World'
>         mb.showinfo('Message Info', 'Hello, %s' % name)
> 
> 
> # 定义 绘制长方形图形 函数 | Definition draw rectangle function
> def drawing_rectangle_function(turtles):
>     # 定义 笔刷宽度 | Definition brush width
>     turtles.width(4)
> 
>     # 定义 前进 | Definition go ahead
>     turtles.forward(200)
>     # 定义 右转90度 | Definition 90 degrees right
>     turtles.right(90)
> 
>     # 定义 笔刷颜色 | Definition brush color
>     turtles.pencolor('blue')
>     turtles.forward(100)
>     turtles.right(90)
> 
>     turtles.pencolor('green')
>     turtles.forward(200)
>     turtles.right(90)
> 
>     turtles.pencolor('red')
>     turtles.forward(100)
>     turtles.right(90)
> 
>     # 定义 关闭窗口 | Definition Close window
>     turtles.done()
> 
> 
> # 定义 绘制五角星图形 函数 | Definition draw five-pointed star function
> def drawing_five_pointed_function(turtles, num_x, num_y):
>     turtles.pu()
>     turtles.goto(num_x, num_y)
>     turtles.pd()
>     turtles.seth(0)
>     for i in range(5):
>         turtles.fd(40)
>         turtles.rt(144)
> 
> 
> def run_drawing_five_pointed_function(turtles):
>     for x in range(0, 250, 50):
>         drawing_five_pointed_function(turtles, x, 0)
>     turtles.done()
> 
> 
> # 定义 绘制 分型树图形 函数 | Definition draw fractal tree graph function
> 
> # 定义颜色数值 | Define color values
> te.colormode(255)
> 
> te.lt(90)
> 
> # 定义全局变量 | Defining global variables
> lv = 14
> le = 120
> s = 45
> 
> # 定义宽度 | Define width
> te.width(lv)
> 
> r = 0
> g = 0
> b = 0
> te.pencolor(r, g, b)
> 
> te.penup()
> te.bk(le)
> te.pendown()
> te.fd(le)
> 
> 
> def drawing_fractal_tree_graph_function(turtles, l, level):
>     global r, g, b
>     # save the current pen width
>     w = turtles.width()
> 
>     # narrow the pen width
>     turtles.width(w * 3.0 / 4.0)
>     # set color:
>     r = r + 1
>     g = g + 2
>     b = b + 3
>     turtles.pencolor(r % 200, g % 200, b % 200)
> 
>     l = 3.0 / 4.0 * l
> 
>     turtles.lt(s)
>     turtles.fd(l)
> 
>     if level < lv:
>         drawing_fractal_tree_graph_function(turtles, l, level + 1)
>     turtles.bk(l)
>     turtles.rt(2 * s)
>     turtles.fd(l)
> 
>     if level < lv:
>         drawing_fractal_tree_graph_function(turtles, l, level + 1)
>     turtles.bk(l)
>     turtles.lt(s)
> 
>     # restore the previous pen width
>     turtles.width(w)
> 
> 
> te.speed("fastest")
> drawing_fractal_tree_graph_function(te, le, 4)
> te.done()
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建实例 | Create instance
>     g1 = GUIApplication()
>     # 调用 方法 | Call method
>     g1.master.title('Application')  # 设置窗口标题信息 | Set window title information
>     g1.mainloop()
>     # 调用 函数 | call function
>     drawing_rectangle_function(te)
>     run_drawing_five_pointed_function(te)
> ```


### 8.8 Python XML
#### 8.8.1 前言
> XML是指可扩展标记语言(eXtensible Markup Language).
>  
> XML被设计用来传输和存储数据.
> XML是一套定义语义标记的规则, 这些标记将文档分成许多部件并对这些部件加以标识.
> 
> 它也是元标记语言, 即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言.
> 
> **Python for XML解析**
> 
> 常见的 XML 编程接口有 DOM 和 SAX, 这两种接口处理 XML 文件的方式不同, 当然使用场合也不同.
> 
> Python 有三种方法解析XML, SAX, DOM, 以及 ElementTree
> - 1.`SAX(simple API for XML)`：Python 标准库包含 SAX 解析器, SAX用事件驱动模型, 通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件.
> - 2.`DOM(Document Object Model)`：将 XML 数据在内存中解析成一个树, 通过对树的操作来操作XML.
> - 3.`ElementTree(元素树)`：ElementTree就像一个轻量级的DOM, 具有方便友好的API, 代码可用性好, 速度快, 消耗内存少.

#### 8.8.2 基于SAX解析XML
> SAX是一种基于事件驱动API, 利用SAX解析XML文档牵涉到两个部分: 解析器和事件处理器.
> 
> 解析器负责读取XML文档并向事件处理器发送事件, 如元素开始跟元素结束事件, 而事件处理器则负责对事件作出响应, 对传递的XML数据进行处理.
> 
> [SAX API 文档 | Python SAX APIs](http://docs.python.org/library/xml.sax.html)
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : XML 解析 | XML Parsing
> # @File : 20_xml_parsing.py
> # @Description : Python 进阶篇 - XML 解析 | Advanced Python - XML Parsing
> 
> # 导入模块 | Import module
> import xml.sax
> 
> 
> # 定义 xml解析类 | Definition xml parsing class
> class XmlParsing(xml.sax.ContentHandler):
> 
>     # 定义 初始化方法 | Definition initialization method
>     def __init__(self):
>         self.CurrentData = ""
>         self.type = ""
>         self.format = ""
>         self.year = ""
>         self.rating = ""
>         self.stars = ""
>         self.description = ""
>         super().__init__()
> 
>     # 定义 SAX解析XML 方法 | Define SAX parsing XML method
>     # 元素开始事件处理 | Element start event processing
>     def startElement(self, tag, attributes):
>         self.CurrentData = tag
>         if tag == "movie":
>             print('**********Movie**********')
>             title = attributes["title"]
>             print('Title:', title)
> 
>     # 元素结束事件处理 | Element end event processing
>     def endElement(self, tag):
>         if self.CurrentData == "type":
>             print('Type:', self.type)
>         elif self.CurrentData == "format":
>             print('Format:', self.format)
>         elif self.CurrentData == "year":
>             print('Year:', self.year)
>         elif self.CurrentData == "rating":
>             print('Rating:', self.rating)
>         elif self.CurrentData == "stars":
>             print('Stars:', self.stars)
>         elif self.CurrentData == "description":
>             print('Description:', self.description, '\n')
>         self.CurrentData = ""
> 
>     # 内容事件处理 | Content event processing
>     def characters(self, content):
>         if self.CurrentData == "type":
>             self.type = content
>         elif self.CurrentData == "format":
>             self.format = content
>         elif self.CurrentData == "year":
>             self.year = content
>         elif self.CurrentData == "rating":
>             self.rating = content
>         elif self.CurrentData == "stars":
>             self.stars = content
>         elif self.CurrentData == "description":
>             self.description = content
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 定义文件路径 | Define file path
>     FILE_PATHS = '../resources/xml_file/movies.xml'
>     # 创建 XMLReader | Create XMLReader
>     parser = xml.sax.make_parser()
>     # 关闭命名空间 | turn off namepsaces
>     parser.setFeature(xml.sax.handler.feature_namespaces, 0)
>     # 创建实例 | Create instance
>     x = XmlParsing()
>     parser.setContentHandler(x)
>     # 装载数据进行解析 | Load data for parsing
>     parser.parse(FILE_PATHS)
> ```

#### 8.8.3 基于DOM解析XML
> 文件对象模型(Document Object Model, 简称DOM), 是W3C组织推荐的处理可扩展置标语言的标准编程接口.
> 
> 一个 DOM 的解析器在解析XML文档时, 一次性读取整个文档, 把文档中所有元素保存在内存中的一个树结构里, 之后可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构,也可以把修改过的内容写入xml文件.
> 
> [DOM API 文档 | Python DOM APIs](http://docs.python.org/library/xml.dom.html)
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : XML 解析 | XML Parsing
> # @File : 20_xml_parsing.py
> # @Description : Python 进阶篇 - XML 解析 | Advanced Python - XML Parsing
> 
> # 导入模块 | Import module
> from xml.dom.minidom import parse as pe
> import xml.dom.minidom as mm
> 
> # 定义 xml解析类 | Definition xml parsing class
> class XmlParsing(xml.sax.ContentHandler):
> 
>     # 定义 DOM解析XML 方法 | Define DOM parsing XML method
>     def dom_parsing_xml_method(self, path):
>         # 加载数据 | Load Data
>         dom_tree = pe(path)
>         # 采集元素 | Collecting elements
>         collection = dom_tree.documentElement
>         # 条件判断 | Condition judgment
>         if collection.hasAttribute("shelf"):
>             print('Root element : %s ' % collection.getAttribute("shelf"))
>         # 在集合中获取所有数据 | Get all data in a collection
>         movies = collection.getElementsByTagName("movie")
>         # 打印数据详细信息 | Print data details
>         for data_info in movies:
>             print('**********Movie**********')
>             if data_info.hasAttribute("title"):
>                 print('Title: %s' % data_info.getAttribute("title"))
>             types = data_info.getElementsByTagName('type')[0]
>             print('Type: %s' % types.childNodes[0].data)
>             formats = data_info.getElementsByTagName('format')[0]
>             print('Format: %s' % formats.childNodes[0].data)
>             rating = data_info.getElementsByTagName('rating')[0]
>             print('Rating: %s' % rating.childNodes[0].data)
>             description = data_info.getElementsByTagName('description')[0]
>             print('Description: %s' % description.childNodes[0].data, '\n')
>             
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 定义文件路径 | Define file path
>     FILE_PATHS = '../resources/xml_file/movies.xml'
>     # 创建实例 | Create instance
>     x = XmlParsing()
>     # 调用方法 | Calling method
>     x.dom_parsing_xml_method(FILE_PATHS)
> ```


### 8.9 Python JSON
#### 8.9.1 前言
> JSON(JavaScript Object Notation)是一种轻量级的数据交换格式, 易于阅读和编写.
> 
> 使用Python语言来编码和解码 JSON 对象.

#### 8.9.2 JSON 函数
> 使用JSON函数需要导入json库：`import json` | [更多内容参考](https://docs.python.org/3/library/json.html)
> 
> `json.dumps函数`: 将Python对象编码成JSON字符串.
> 
> `json.loads函数`: 将已编码JSON字符串解码为Python对象.

##### 8.9.2.1 json.dumps
> **1. 函数描述**
> 
> json.dumps用于将Python对象编码成JSON字符串.
> 
> **2. 使用语法**
> 
> ```
> json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding="utf-8", default=None, sort_keys=False, **kw)
> ```
> 
> **3. Python原始类型向Json类型的转化对照表**
> 
> | Python数据类型 | JSON数据类型 |
> | :--------: | :--------: |
> | `dict`    |   object |
> | `list, tuple` |   array |
> | `str, unicode` |  string |
> | `int, long, float` |  number |
> | `True`  |  true |
> | `False` |  false |
> | `None` |  null |
> 
> **4. 数组封装JSON格式**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : JSON 编码 解码 | # @Program : JSON 编码 解码 |
> # @File : 21_json_parsing.py
> # @Description : Python 进阶篇 - JSON 编码 解码 | Advanced Python - JSON encoding and decoding
> 
> # 导入模块 | Import module
> import json as jn
> 
> '''
> 定义数组, 将数组编码为JSON格式数据
> Define an array, encode the array into JSON format data
> '''
> array_data = [{'name': 'Juliet', 'age': 18, 'gender': 'girl', 'Hobby': 'music', 'constellation': 'Libra'}]
> 
> 
> # 定义 数组转换JSON 函数 | Definition array conversion JSON function
> def array_conversion_json(values):
>     '''
>     数据格式化输出 | Data formatted output
>     参数说明 | Parameter Description:
>         `values` 表示加载元数据
>         `sort_keys` 表示key排序选项, False返回升序, True返回降序
>         `indent` 表示缩进长度
>         `separators` 表示分隔符
>     :param values:
>     :return:
>     '''
>     j = jn.dumps(values, sort_keys=False, indent=1, separators=(',', ': '))
>     print('ArrayData to JsonData=', j)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用函数 | call function
>     array_conversion_json(array_data)
> ```

##### 8.9.2.2 json.loads
> **1. 函数描述**
> 
> json.loads用于解码JSON数据, 该函数返回Python字段的数据类型.
> 
> **2. 使用语法**
> 
> ```
> json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])
> ```
> 
> **3. Json类型转换到Python类型对照表**
> | JSON      |     Python |
> | :--------: | :--------:|
> | `object`    |   dict |
> | `array`    |   list |
> | `string`    |   unicode |
> | `number (int)`    |   int, long |
> | `number (real)`    |   float |
> | `true`    |   True |
> | `false`    |   False |
> | `null`    |   None |
> 
> **4. 解码JSON对象**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : JSON 编码 解码 | # @Program : JSON 编码 解码 |
> # @File : 21_json_parsing.py
> # @Description : Python 进阶篇 - JSON 编码 解码 | Advanced Python - JSON encoding and decoding
> 
> # 导入模块 | Import module
> import json as jn
> 
> '''
> 定义JSON, 解码JSON返回Python数据类型
> Define JSON, decode JSON and return Python data type
> '''
> json_data = '{"name":"Juliet","age":18,"gender":"girl","Hobby":"music","constellation":"Libra"}'
> 
> # 定义 JSON 转换为Python数据类型 函数 | Define JSON to Python data type function
> def json_conversion_data(values):
>     text = jn.loads(values)
>     print('JSON to Python data type=', text)
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用函数 | call function
>     json_conversion_data(json_data)
> ```


#### 8.9.3 Demjson
##### 8.9.3.1 前言
> Demjson是Python第三方模块库, 可用于编码和解码JSON数据, 包含JSONLint格式化及校验功能.
> 
> 下载第三方库：[Dow For Github](https://github.com/dmeranda/demjson) | [Dow For 官方地址](http://deron.meranda.us/python/demjson/) | ```pip3 install demjson```

##### 8.9.3.2 JSON 函数
> **函数描述**
> 
> `encode函数`: 将Python对象编码成JSON字符串.
> 
> `decode函数`: 将已编码JSON字符串解码为Python对象.

##### 8.9.3.3 encode
> **1. 函数描述**
> 
> Python encode() 函数用于将 Python 对象编码成 JSON 字符串.
> 
> **2. 使用语法**
> 
> ``` py
> demjson.encode(self, obj, nest_level=0)
> ```
> 
> **3. 数组封装JSON格式**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : JSON 编码 解码 | # @Program : JSON 编码 解码 |
> # @File : 21_json_parsing.py
> # @Description : Python 进阶篇 - JSON 编码 解码 | Advanced Python - JSON encoding and decoding
> 
> # 导入模块 | Import module
> import demjson as dj
> 
> '''
> 定义数组, 将数组编码为JSON格式数据
> Define an array, encode the array into JSON format data
> '''
> array_data = [{'name': 'Juliet', 'age': 18, 'gender': 'girl', 'Hobby': 'music', 'constellation': 'Libra'}] 
> 
> # 定义 数组转换JSON 函数 | Definition array conversion JSON function
> def array_coding_json(values):
>     j = dj.encode(values)
>     print('ArrayData to JsonData=', j)
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用函数 | call function
>     array_coding_json(array_data)
> ```


##### 8.9.3.4 decode
> **1. 函数描述**
> 
> Python encode() 函数用于将 Python 对象编码成 JSON 字符串.
> 
> **2. 使用语法**
> 
> ``` py
> demjson.decode(self, txt)
> ```
> 
> **3. 解码JSON对象**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : JSON 编码 解码 | # @Program : JSON 编码 解码 |
> # @File : 21_json_parsing.py
> # @Description : Python 进阶篇 - JSON 编码 解码 | Advanced Python - JSON encoding and decoding
> 
> # 导入模块 | Import module
> import demjson as dj
> 
> '''
> 定义JSON, 解码JSON返回Python数据类型
> Define JSON, decode JSON and return Python data type
> '''
> json_data = '{"name":"Juliet","age":18,"gender":"girl","Hobby":"music","constellation":"Libra"}'
> 
> # 定义 JSON 转换为Python数据类型 函数 | Define JSON to Python data type function
> def json_coding_data(values):
>     text = dj.decode(values)
>     print('JSON to Python data type=', text)
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用函数 | call function
>     json_coding_data(json_data)
> ```


### 8.10 Python 异步IO
#### 8.10.1 前言
> CPU的速度远远快于磁盘、网络等IO, 在一个线程中CPU执行代码的速度极快, 然而一旦遇到IO操作, 如读写文件、发送网络数据时就需要等待IO操作完成, 才能继续进行下一步操作, 这种情况称为同步IO
> 
> 因为一个IO操作就阻塞了当前线程, 导致其他代码无法执行, 所以必须使用多线程或者多进程来并发执行代码, 为多个用户服务, 每个用户都会分配一个线程, 如果遇到IO导致线程被挂起其他用户的线程不受影响.
> 
> 多线程和多进程的模型虽然解决了并发问题, 但是系统不能无上限地增加线程, 由于系统切换线程的开销也很大, 所以一旦线程数量过多, CPU的时间就花在线程切换上了, 真正运行代码的时间就少了, 结果导致性能严重下降.

#### 8.10.2 协程
> 在学习异步IO模型前先来了解协程, 协程又称微线程(Coroutine)
> 
> 协程的概念很早就提出来了, 但直到最近几年才在某些语言(如Lua编程语言)中得到广泛应用.
> 
> 子程序或者称为函数, 在所有语言中都是层级调用, 比如A调用B, B在执行过程中又调用了C, C执行完毕返回, B执行完毕返回, 最后是A执行完毕, 所以子程序调用是通过栈实现, 一个线程就是执行一个子程序.
> 
> 子程序调用总是一个入口, 一次返回, 调用顺序是明确的, 而协程的调用和子程序不同.
> 
> 协程看上去也是子程序, 但执行过程中在子程序内部可中断, 然后转而执行别的子程序, 在适当的时候再返回来接着执行.
> 
> Python对协程支持是通过generator实现, 在generator中, 不但可以通过for循环来迭代, 还可以不断调用next()函数获取由yield语句返回的下一个值, 但是Python的yield不但可以返回一个值, 它还可以接收调用者发出的参数.
> 
> 传统的生产者-消费者模型是一个线程写消息, 一个线程取消息, 通过锁机制控制队列和等待, 但一不小心就可能死锁, 如果改用协程, 生产者生产消息后直接通过yield跳转到消费者开始执行, 待消费者执行完毕后, 切换回生产者继续生产效率极高.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异步I/O | Asynchronous I / O
> # @File : 22_asynchronous_io.py
> # @Description : Python 进阶篇 - 异步I/O | Advanced Python - Asynchronous I / O
> 
> # 定义 异步IO 类 | Define AsynchronousReadWrite class
> class AsynchronousReadWrite:
>     '''
>     协程生产者&消费者执行流程：子程序就是协程的一种特例
>         `coroutine_consumer()`方法是生成器(generator), 将coroutine_consumer传入`coroutine_producer()`方法
>         1. 首先调用`parameter.send(None)`启动生成器.
>         2. 然后一旦生产消息, 通过`parameter.send(n)`切换到`coroutine_consumer`执行.
>         3. `coroutine_consumer`通过`yield`拿到消息, 处理又通过`yield`把结果回传.
>         4. `coroutine_producer()`拿到`coroutine_consumer`处理结果, 继续生产下一条消息.
>         5. `coroutine_producer决定不生产了, 是通过`parameter.close()`关闭`coroutine_consumer`整个过程结束.
>         整个流程无锁, 由一个线程执行, `produce`和`consumer`协作完成任务, 所以称为“协程”, 而非线程的抢占式多任务
>     '''
> 
>     # 定义 协程 消费者 方法 | Definition coroutine consumer method
>     def coroutine_consumer(self):
>         r = ' '
>         while True:
>             n = yield r
>             if not n:
>                 return
>             print('[CONSUMER] Consuming %s...' % n)
>             r = '200 OK'
> 
>     # 定义 协程 生产者 方法 | Definition coroutine producer method
>     def coroutine_producer(self, parameter):
>         parameter.send(None)
>         n = 0
>         while n < 5:
>             n = n + 1
>             print('[PRODUCER] Producing %s...' % n)
>             r = parameter.send(n)
>             print('[PRODUCER] Consumer Return: %s' % r)
>         parameter.close()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 实例 | Create instance
>     a = AsynchronousReadWrite()
>     # 调用 方法 | Call method
>     consumer = a.coroutine_consumer()
>     a.coroutine_producer(consumer)
> ```


#### 8.10.3 asyncio
> asyncio是Python 3.4版本引入的标准库, 可以直接内置了对异步IO的支持.
> 
> asyncio的编程模型就是一个消息循环, 从asyncio模块中直接获取一个EventLoop的引用, 然后将需要执行的协程编写到EventLoop中执行就实现了异步IO.
> 
> > **1. 异步并发执行**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异步I/O | Asynchronous I / O
> # @File : 22_asynchronous_io.py
> # @Description : Python 进阶篇 - 异步I/O | Advanced Python - Asynchronous I / O
> 
> # 导入模块 | Import module
> import threading as tg
> import asyncio as ao
> 
> # 定义 异步IO 类 | Define AsynchronousReadWrite class
> class AsynchronousReadWrite:
> 
>     # 定义 asyncio 异步IO方法 | Define asyncio asynchronous IO method
>     '''
>     Python 3.5以下使用`asyncio.@coroutine`装饰器 修饰生成器为coroutine类型
>     Python 3.8起已弃用`@coroutine`装饰器, 改用`async def`修饰coroutine类型
>     '''
> 
>     async def asynchronous_method(self, nums):
>         print('Hello World! (%s)' % tg.currentThread())
>         '''
>         Python 3.5以下使用 `yield from asyncio.sleep(nums)`调用异步睡眠
>         '''
>         # 异步调用睡眠
>         await ao.sleep(nums)
>         print('Hello Again! (%s)' % tg.currentThread())
> 
>     # 定义 执行 协程异步IO 方法 | Define execute coroutine asynchronous IO method
>     def run_asyncio(self, func):
>         # 定义 获取循环事件 | Definition Get loop event
>         loop = ao.get_event_loop()
>         # 定义 执行 协程 | Definition execution coroutine
>         tasks = [func, func]
>         loop.run_until_complete(ao.wait(tasks))
>         # 关闭事件 | Close event
>         loop.close()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 实例 | Create instance
>     a = AsynchronousReadWrite()
>     # 调用 方法 | Call method
>     coroutine_method = a.asynchronous_method(3)
>     a.run_asyncio(coroutine_method)
> ```
> 
> **2. 异步获取网站服务**
> 
> asyncio提供了完善的异步IO支持, 异步操作需要在`coroutine`中通过`yield from`完成, 多个`coroutine`可以封装成一组Task然后并发执行.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异步I/O | Asynchronous I / O
> # @File : 22_asynchronous_io.py
> # @Description : Python 进阶篇 - 异步I/O | Advanced Python - Asynchronous I / O
> 
> # 导入模块 | Import module
> import threading as tg
> import asyncio as ao
> 
> # 定义 异步IO 类 | Define AsynchronousReadWrite class
> class AsynchronousReadWrite:
> 
>     # 定义 异步获取网站服务状态 方法 | Define Get website service status asynchronously
>     async def get_website_status(self, host):
>         print('Ge WebSite  %s...' % host, '\n')
>         connect = ao.open_connection(host, 80)
>         reader, writer = await connect
>         header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host
>         writer.write(header.encode('UTF-8'))
>         await writer.drain()
>         while True:
>             line = await reader.readline()
>             if line == b'\r\n':
>                 break
>             print('%s Header => %s' % (host, line.decode('UTF-8').rstrip()))
>         # 关闭流 | Close stream
>         writer.close()
> 
>     # 运行 异步获取网站服务状态 方法 | Run asynchronously to get website service status method
>     def run_get_website(self, url):
>         # 定义 获取循环事件 | Definition Get loop event
>         loop = ao.get_event_loop()
>         # 定义 执行 协程 | Definition execution coroutine
>         tasks = [self.get_website_status(x) for x in url]
>         loop.run_until_complete(ao.wait(tasks))
>         # 关闭事件 | Close event
>         loop.close()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 实例 | Create instance
>     a = AsynchronousReadWrite()
>     # 调用 方法 | Call method
>     HOST = ['www.youtube.com', 'www.google.com', 'www.163.com', 'www.github.com', 'www.python.org']
>     a.run_get_website(HOST)
> ```

#### 8.10.4 async & await
> 使用asyncio提供的`@asyncio.coroutine`可以把一个generator标记为coroutine类型, 然后在coroutine内部使用`yield from`调用另一个coroutine实现异步操作.
> 
> 为了简化并更好地标识异步IO, 从Python 3.5开始引入了新语法`async`和`await`, 可以让coroutine的代码更简洁易读.
> 
> async和await是针对coroutine的新语法, 要使用新的语法, 只需要做两步简单的替换:
> 将`@asyncio.coroutine`替换为`async` / 将`yield from`替换为`await`
> 
> Python从3.5版本开始为asyncio提供了`async`和`await`的新语法, 如果使用3.4版本则仍需使用`@asyncio.coroutine`方案.
> 
> **1. 采用新语法 `async` & `await`异步I/O操作**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异步I/O | Asynchronous I / O
> # @File : 22_asynchronous_io.py
> # @Description : Python 进阶篇 - 异步I/O | Advanced Python - Asynchronous I / O
> 
> # 导入模块 | Import module
> import threading as tg
> import asyncio as ao
> 
> # 定义 异步IO 类 | Define AsynchronousReadWrite class
> class AsynchronousReadWrite:
> 
>     # 定义 asyncio 异步IO方法 | Define asyncio asynchronous IO method
>     '''
>     Python 3.5以下使用`asyncio.@coroutine`装饰器 修饰生成器为coroutine类型
>     Python 3.8起已弃用`@coroutine`装饰器, 改用`async def`修饰coroutine类型
>     '''
> 
>     async def asynchronous_method(self, nums):
>         print('Hello World! (%s)' % tg.currentThread())
>         '''
>         Python 3.5以下使用 `yield from asyncio.sleep(nums)`调用异步睡眠
>         '''
>         # 异步调用睡眠
>         await ao.sleep(nums)
>         print('Hello Again! (%s)' % tg.currentThread())
> 
>     # 定义 执行 协程异步IO 方法 | Define execute coroutine asynchronous IO method
>     def run_asyncio(self, func):
>         # 定义 获取循环事件 | Definition Get loop event
>         loop = ao.get_event_loop()
>         # 定义 执行 协程 | Definition execution coroutine
>         tasks = [func, func]
>         loop.run_until_complete(ao.wait(tasks))
>         # 关闭事件 | Close event
>         loop.close()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 实例 | Create instance
>     a = AsynchronousReadWrite()
>     # 调用 方法 | Call method
>     coroutine_method = a.asynchronous_method(3)
>     a.run_asyncio(coroutine_method)
> ```
> 
> **2. 采用新语法 `async` & `await`异步I/O操作**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异步I/O | Asynchronous I / O
> # @File : 22_asynchronous_io.py
> # @Description : Python 进阶篇 - 异步I/O | Advanced Python - Asynchronous I / O
> 
> # 导入模块 | Import module
> import threading as tg
> import asyncio as ao
> 
> # 定义 异步IO 类 | Define AsynchronousReadWrite class
> class AsynchronousReadWrite:
> 
>     # 定义 异步获取网站服务状态 方法 | Define Get website service status asynchronously
>     async def get_website_status(self, host):
>         print('Ge WebSite  %s...' % host, '\n')
>         connect = ao.open_connection(host, 80)
>         reader, writer = await connect
>         header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host
>         writer.write(header.encode('UTF-8'))
>         await writer.drain()
>         while True:
>             line = await reader.readline()
>             if line == b'\r\n':
>                 break
>             print('%s Header => %s' % (host, line.decode('UTF-8').rstrip()))
>         # 关闭流 | Close stream
>         writer.close()
> 
>     # 运行 异步获取网站服务状态 方法 | Run asynchronously to get website service status method
>     def run_get_website(self, url):
>         # 定义 获取循环事件 | Definition Get loop event
>         loop = ao.get_event_loop()
>         # 定义 执行 协程 | Definition execution coroutine
>         tasks = [self.get_website_status(x) for x in url]
>         loop.run_until_complete(ao.wait(tasks))
>         # 关闭事件 | Close event
>         loop.close()
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 实例 | Create instance
>     a = AsynchronousReadWrite()
>     # 调用 方法 | Call method
>     HOST = ['www.youtube.com', 'www.google.com', 'www.163.com', 'www.github.com', 'www.python.org']
>     a.run_get_website(HOST)
> ```


#### 8.10.5 aiohttp
> **1. 前言**
> 
> `asyncio`可以实现单线程并发IO操作, 如果仅用在客户端发挥的威力不大, 如果把`asyncio`用在服务器端, 例如Web服务器，由于HTTP连接就是IO操作, 因此可以用单线程+coroutine实现多用户高并发支持.
> 
> `asyncio`实现了TCP、UDP、SSL等协议, `aiohttp`则是基于`asyncio`实现的HTTP框架.
> 
> **2. 安装 `aiohttp`**
> 
> pypi 镜像使用帮助, 由于海外镜像下载第三方库较慢, 至此更改为国内镜像.
> 
> 临时使用：
> ```
> pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package
> ```
> 
> 永久使用：
> ```
> # 升级 pip 到最新的版本 (>=10.0.0) 后进行配置：
> pip install pip -U
> 
> # 如pip默认海外源网络连接较差, 可临时使国内镜像站升级pip, 升级后再将pip默认设置为国内镜像
> pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U
> 
> # 将pip默认设置为国内镜像
> pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
> ```
> 
> 开始安装`aiohttp`
> ```
> (venv) systemhub:python_server system$ pip install aiohttp
> ```
> **基于`aiohttp`构建简易HTTP服务器**
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 异步I/O | Asynchronous I / O
> # @File : 22_asynchronous_io.py
> # @Description : Python 进阶篇 - 异步I/O | Advanced Python - Asynchronous I / O
> 
> # 导入模块 | Import module
> import asyncio as ao
> from aiohttp import web as wb
> 
> '''
> 异步Web应用程序 | Async Web Application
> 定义 简易HTTP服务器 方法 | Define a simple HTTP server method
> '''
> # 定义 路由器 | Definition router
> routes = wb.RouteTableDef()
> 
> 
> # 定义 Web应用 首页 方法 | Defining a Web Application Home Method
> @routes.get('/')
> async def home(request):
>     await ao.sleep(0.5)
>     return wb.Response(body=b'<h1>Welcome To Home!</h1>', headers={'content-type': 'text/html'})
> 
> 
> # 定义 Web应用 JSON 方法 | Define web application JSON method
> @routes.get('/json/{name}')
> async def json_method(request):
v    await ao.sleep(0.1)
v    return wb.json_response({'name': request.match_info['name'] or 'index'})
> 
> 
> # 定义 Web应用 主页 方法 | Define Web Application Home Method
> @routes.get('/mains/{name}')
> async def mains(request):
>     await ao.sleep(0.5)
>     return wb.Response(body="<h1>Hello %s</h1>" % request.match_info['name'], headers={'content-type': 'text/html'})
> 
> 
> # 定义 Web应用 初始化 方法 | Define web application initialization method
> async def init():
>     # 初始化服务 | Initialize the service
>     app_server = wb.Application()
>     app_server.add_routes(routes)
>     # 运行HTTP服务 | Run HTTP service
>     runner = wb.AppRunner(app_server)
>     await runner.setup()
>     website = wb.TCPSite(runner, '127.0.0.1', 8000)
>     await website.start()
>     print('======== Running on http://127.0.0.1:8000 ========')
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     init()
> ```

### 8.11 Python 高级特性
#### 8.11.1 前言
> 掌握了Python的数据类型、语句和函数, 基本上就可以编写出很多有用的程序.
> 
> 比如构造一个1, 3, 5, 7, ..., 99的列表可以通过循环实现.
> 
> 在Python中代码不是越多越好, 而是越少越好, 代码不是越复杂越好, 而是越简单越好.
> 
> 基于这一思想下面将介绍Python中非常有用的高级特性, 1行代码能实现的功能决不写5行代码, 请始终牢记代码越少开发效率越高.

#### 8.11.2 切片
> 取一个list或tuple的部分元素是非常常见的操作, 因此Python提供了切片（Slice）操作符, 能大大简化这种操作, 取前3个元素用一行代码就可以完成切片.
> 
> 有了切片操作很多地方循环就不再需要了, Python的切片非常灵活, 一行代码就可以实现很多行循环才能完成的操作.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 高级特性 | Advanced features
> # @File : 23_advanced_features.py
> # @Description : Python 进阶篇 - 高级特性 | Advanced Python - Advanced Features
> 
> 
> # 定义 切片 类 | Definition slice class
> class Slice:
> 
>     # 定义 获取列表元素 方法 | Definition get list element method
>     @staticmethod
>     def get_element():
>         # 定义 列表 | Definition list
>         elements = ['System', 'Karlh', 'Oracy', 'Pob', 'Tack']
>         '''
>         获取列表前3个元素 切片说明:
>         `elements[0:3]` 表示 从索引0开始获取, 直到索引3为止, 但不包括索引3, 即索引 `0, 1, 2`
>         '''
>         print('=============================== Slice Start ===============================\n')
>         print('elements[0:3] =', elements[0:3])
> 
>         '''
>         获取列表前3个元素 切片说明:
>         `elements[:3]` 表示 从索引0开始获取, 如果第一个索引是0, 还可以省略, 直到索引3为止, 但不包括索引3, 即索引 `0, 1, 2`
>         '''
>         print('elements[:3] =', elements[:3])
> 
>         '''
>         从索引1开始获取出2个元素 切片说明:
>         `elements[1:3]` 表示 从索引1开始获取, 直到索引3为止, 但不包括索引3, 即索引 `1, 2`
>         '''
>         print('elements[1:3] =', elements[1:3])
> 
>         '''
>         倒数 切片说明: 
>         Python支持`List[-1]`获取 倒数元素, 倒数第一个元素索引是`-1`
>         `elements[-2:]` 表示 从元素末尾-1开始获取, 直到索引-2为止, 包括索引-2, 即索引 `-1, -2`
>         '''
>         print('elements[-2:] =', elements[-2:])
> 
>         # 定义 数列 | Definition Number List
>         number_elements = list(range(100))
>         print('number_elements = ', number_elements)
> 
>         '''
>         获取列表前10个元素 切片说明:
>         `elements[0:10]` 或 `elements[:10]` 表示 从索引0开始获取, 如果第一个索引是0, 还可以省略,
>         直到索引10为止, 但不包括索引10, 即索引 `0, 1, 2, 3, 4, 5, 6, 7, 8, 9`
>         '''
>         print('number_elements[0:10] = ', number_elements[0:10])
>         print('number_elements[:10] = ', number_elements[:10])
> 
>         '''
>         获取列表后10个元素 切片说明:
>         `elements[-10:]` 表示 从元素末尾-1开始获取, 直到索引-10为止, 包括索引-10, 即索引 `90, 91, 92, 93, 94, 95, 96, 97, 98, 99`
>         '''
>         print('number_elements[-10:] = ', number_elements[-10:])
> 
>         '''
>         获取列表前11~20元素个数 切片说明:
>         `number_elements[10:20]` 表示 从元素索引11开始获取, 直到索引20为止, 不包括索引20, 即索引 `10, 11, 12, 13, 14, 15, 16, 17, 18, 19`
>         '''
>         print('number_elements[10:20] = ', number_elements[10:20])
> 
>         '''
>         获取列表前10个元素, 每2个元素取1个元素 切片说明:
>         `number_elements[0:10:2]` 或 `number_elements[:10:2]` 表示 从索引0开始获取, 如果第一个索引是0, 还可以省略,直到索引10为止, 但不包括索引10, 且每两个元素取一个元素, 即索引 `0, 2, 4, 6, 8`
>         '''
>         print('number_elements[0:10:2] = ', number_elements[0:10:2])
>         print('number_elements[:10:2] = ', number_elements[:10:2])
> 
>         '''
>         获取列表所有元素, 每5个元素取1个元素 切片说明:
>         `number_elements[0:100:5]` 或 `number_elements[::5]` 表示 从索引0开始获取, 直到索引10为止, 
>         且每5个元素取1个元素, , 即索引 `0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95`
>         '''
>         print('number_elements[0:100:5] = ', number_elements[0:100:5])
>         print('number_elements[::5] = ', number_elements[::5])
>         print('\n=============================== Slice End ===============================')
> 
>     # 定义 字符串 格式化 方法 | Definition string formatting method
>     @staticmethod
>     def string_formatting():
>         string = '      Hello World !~      '
>         if string == ' ' or string.isspace():
>             string = ' '
>         else:
>             while string[0] == ' ':
>                 string = string[1:]
>             while string[-1] == ' ':
>                 string = string[:-1]
>         return print('String Formatting =', string)
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建对象实例 | Create object instance
>     s = Slice()
>     # 对象 调用方法 | Object call method
>     s.get_element()
>     s.string_formatting()
> ```


#### 8.11.3 迭代
> 如果给定一个list或tuple可以通过for循环来遍历这个list或tuple, 这种遍历称为迭代(Iteration).
> 
> 在Python中迭代是通过`for ... in`语句来完成, Python的for循环不仅可以用在list或tuple上, 还可以作用在其他可迭代对象上.
> 
> 任何可迭代对象都可以作用于for循环, 包括自定义的数据类型, 只要符合迭代条件就可以使用for循环.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 高级特性 | Advanced features
> # @File : 23_advanced_features.py
> # @Description : Python 进阶篇 - 高级特性 | Advanced Python - Advanced Features
> 
> # 导入模块 | Import module
> from collections import Iterable as ie, Iterator as it
> 
> 
> # 定义 迭代 类 | Define iteration class
> class iterations:
>     # 定义 迭代 静态方法 | Define iterative static method
>     @staticmethod
>     def iterative():
>         print('\n=============================== iterative Start ===============================\n')
>         print('Iterable ? [1, 2, 3]:', isinstance([1, 2, 3], ie))
>         print('Iterator ? [1, 2, 3]:', isinstance([1, 2, 3], it))
> 
>         print('Iterable ? \'abc\':', isinstance('abc', ie))
>         print('Iterator ? \'abc\':', isinstance('abc', it))
> 
>         print('Iterable ? 123:', isinstance(123, ie))
>         print('Iterator ? 123:', isinstance(123, it))
> 
>         print('for x in [1, 2, 3, 4, 5]:')
>         for x in [1, 2, 3, 4, 5]:
>             print('iter List =', x)
> 
>         print('for x in iter([1, 2, 3, 4, 5]):')
>         for x in iter([1, 2, 3, 4, 5]):
>             print('iter List =', x)
> 
>         print('next():')
>         its = iter([1, 2, 3, 4, 5])
>         print('next(its) =', next(its))
> 
>         # iter both key and value:
>         d = {'a': 1, 'b': 2, 'c': 3}
>         print('iter item = ', d)
>         for k, v in d.items():
>             print('item = ', k, v)
> 
>         # iter list with index:
>         print('iter enumerate([\'A\', \'B\', \'C\']')
>         for iters, value in enumerate(['A', 'B', 'C']):
>             print('iter enumerate = ', iters, value)
> 
>         # iter complex list:
>         print('iter [(1, 1), (2, 4), (3, 9)]:')
>         for x, y in [(1, 1), (2, 4), (3, 9)]:
>             print('iter = ', x, y)
>         print('\n=============================== iterative End ===============================')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建对象实例 | Create object instance
>     i = iterations()
>     # 对象 调用方法 | Object call method
>     i.iterative()
> ```

#### 8.11.4 列表生成式
> 列表生成式即`List Comprehensions`, 是Python内置的非常简单却强大的可以用来创建list的生成式.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 高级特性 | Advanced features
> # @File : 23_advanced_features.py
> # @Description : Python 进阶篇 - 高级特性 | Advanced Python - Advanced Features
> 
> # 定义 列表生成式 类 | Definition list generation class
> class ListGeneration:
>     # 定义 列表生成式 静态方法 | Definition list-generating static method
>     @staticmethod
>     def list_generating():
>         print('\n=============================== List Generation Start ===============================\n')
>         print('[x * x for x in range(1, 11)] =', [x * x for x in range(1, 11)])
>         print('[x * x for x in range(1, 11) if x % 2 == 0] = ', [x * x for x in range(1, 11) if x % 2 == 0])
>         print("[m + n for m in 'ABC' for n in 'XYZ'] = ", [m + n for m in 'ABC' for n in 'XYZ'])
> 
>         d = {'x': 'A', 'y': 'B', 'z': 'C'}
>         print([k + '=' + v for k, v in d.items()])
> 
>         lis = ['Hello', 'World', 'IBM', 'Apple']
>         print([strings.lower() for strings in lis])
>         print('\n=============================== List Generation End ===============================')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建对象实例 | Create object instance
>     l = ListGeneration()
>     # 对象 调用方法 | Object call method
>     l.list_generating()
> ```

#### 8.11.5 生成器
> 通过列表生成式可以直接创建一个列表, 但是受到内存限制, 列表容量肯定是有限的, 而且创建一个包含100万个元素的列表, 不仅占用很大的存储空间, 如果仅仅需要访问前面几个元素, 那后面绝大多数元素占用的空间都白白浪费了, 所以如果列表元素可以按照某种算法推算出来, 就不必创建完整的list, 从而节省大量的空间, 在Python中这种一边循环一边计算的机制, 称为生成器：`generator`.
> 
> generator是非常强大的工具, 在Python中可以简单地把列表生成式改成generator, 也可以通过函数实现复杂逻辑的generator.
> 
> generator的工作原理是在for循环的过程中不断计算出下一个元素, 并在适当的条件结束for循环, 对于函数改成的generator来说遇到return语句或者执行到函数体最后一行语句就是结束generator的指令, for循环随之结束.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 高级特性 | Advanced features
> # @File : 23_advanced_features.py
> # @Description : Python 进阶篇 - 高级特性 | Advanced Python - Advanced Features
> 
> # 定义 生成器 类 | Definition generator class
> class Generators:
> 
>     # 定义 斐波拉契数列 静态方法 | Definition Fibonacci sequence static method
>     @staticmethod
>     def fibonacci(max_num):
>         n, a, b = 0, 0, 1
>         while n < max_num:
>             yield b
>             a, b = b, a + b
>             n = n + 1
>         return 'Done'
> 
>     # 定义 生成器 方法 | Definition generator method
>     def generators(self):
>         print('\n=============================== Generator Start ===============================\n')
> 
>         string = (x * x for x in range(5))
>         print('Returns a Generator Object =', string)
>         for x in string:
>             print('element =', x)
> 
>         # 调用 斐波拉契 | Call Fibonacci
>         f = self.fibonacci(10)
>         print('\n`fibonacci(10)` Returns a Generator Object =', f)
>         for x in f:
>             print('fibonacci =', x)
>         print('\n')
> 
>         # 调用 生成器 | Call generator
>         gen = self.fibonacci(5)
>         while 1:
>             try:
>                 x = next(gen)
>                 print('generator =', x)
>             except StopIteration as e:
>                 print('Generator return value =', e.value)
>                 break
>         print('\n=============================== Generators End ===============================')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建对象实例 | Create object instance
>     g = Generators()
>     # 对象 调用方法 | Object call method
>     g.generators()
> ```


#### 8.11.6 迭代器
> 可以直接作用于for循环的数据类型有以下几种:
> - 1.集合数据类型, 如list、tuple、dict、set、str等.
> - 2.generator, 包括生成器和带yield的generator function
> 
> 可以直接作用于for循环的对象统称为可迭代对象：Iterable, 也可以使用isinstance()判断一个对象是否是Iterable对象.
> 
> Python的Iterator对象表示的是一个数据流, Iterator对象可以被next()函数调用并不断返回下一个数据, 直到没有数据时抛出StopIteration错误, 可以把这个数据流看做是一个有序序列, 但却不能提前知道序列的长度, 只能不断通过next()函数实现按需计算下一个数据所以Iterator的计算是惰性的, 只有在需要返回下一个数据时它才会计算.
> 
> Iterator甚至可以表示一个无限大的数据流, 例如全体自然数, 而使用list是永远不可能存储全体自然数.
> 
> 凡是可作用于for循环的对象都是Iterable类型, 凡是可作用于next()函数的对象都是Iterator类型, 它们表示一个惰性计算的序列, 集合数据类型如list、dict、str等是Iterable但不是Iterator, 不过可以通过iter()函数获得一个Iterator对象.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 高级特性 | Advanced features
> # @File : 23_advanced_features.py
> # @Description : Python 进阶篇 - 高级特性 | Advanced Python - Advanced Features
> 
> # 导入模块 | Import module
> from collections import Iterable as ie, Iterator as it
> 
> 
> # 定义 迭代 类 | Define iteration class
> class iterations:
>     # 定义 迭代 静态方法 | Define iterative static method
>     @staticmethod
>     def iterative():
>         print('\n=============================== iterative Start ===============================\n')
>         print('Iterable ? [1, 2, 3]:', isinstance([1, 2, 3], ie))
>         print('Iterator ? [1, 2, 3]:', isinstance([1, 2, 3], it))
> 
>         print('Iterable ? \'abc\':', isinstance('abc', ie))
>         print('Iterator ? \'abc\':', isinstance('abc', it))
> 
>         print('Iterable ? 123:', isinstance(123, ie))
>         print('Iterator ? 123:', isinstance(123, it))
> 
>         print('for x in [1, 2, 3, 4, 5]:')
>         for x in [1, 2, 3, 4, 5]:
>             print('iter List =', x)
> 
>         print('for x in iter([1, 2, 3, 4, 5]):')
>         for x in iter([1, 2, 3, 4, 5]):
>             print('iter List =', x)
> 
>         print('next():')
>         its = iter([1, 2, 3, 4, 5])
>         print('next(its) =', next(its))
> 
>         # iter both key and value:
>         d = {'a': 1, 'b': 2, 'c': 3}
>         print('iter item = ', d)
>         for k, v in d.items():
>             print('item = ', k, v)
> 
>         # iter list with index:
>         print('iter enumerate([\'A\', \'B\', \'C\']')
>         for iters, value in enumerate(['A', 'B', 'C']):
>             print('iter enumerate = ', iters, value)
> 
>         # iter complex list:
>         print('iter [(1, 1), (2, 4), (3, 9)]:')
>         for x, y in [(1, 1), (2, 4), (3, 9)]:
>             print('iter = ', x, y)
>         print('\n=============================== iterative End ===============================')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建对象实例 | Create object instance
>     i = iterations()
>     # 对象 调用方法 | Object call method
>     i.iterative()
> ```


### 8.12 Python 常用内建模块 & 常用第三方模块
#### 8.12.1 常用内建模块
> Python之所以自称“batteries included”, 就是因为内置了许多非常有用的模块, 无需额外安装和配置, 即可直接使用.
##### 8.12.1.1 datetime
> datetime是Python处理日期和时间的标准库.
> 
> datetime表示的时间需要时区信息才能确定一个特定的时间否则只能视为本地时间.
> 
> 如果要存储datetime最佳方法是将其转换为timestamp再存储, 因为timestamp的值与时区完全无关.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from datetime import datetime as dt, timedelta as td, timezone as tz
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
> 
>     # 定义 日期时间 静态方法 | Definition datetime static method
>     @staticmethod
>     def datetime_method():
>         print('\n=============================== DateTime Method Start ===============================\n')
>         # 获取当前日期时间 | Get the current date and time
>         now = dt.now()
>         print('Now DateTime =', now, '| Type(now) =', type(now))
> 
>        # 获取指定日期和时间 | Get the specified date and time
>         dts = dt(2019, 8, 19, 23, 00)
>         print('DateTime =', dts)
> 
>         # 日期时间转换为时间戳 | Datetime to timestamp
>         '''
>         `timestamp`说明：
>                     在计算机中时间实际上是用数字表示, 把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为EpochTime, 记为0
>                     (1970年以前的时间timestamp为负数), 当前时间就是相对于EpochTime的秒数, 称为timestamp(时间戳).
>                     可见timestamp的值与时区毫无关系, 因为timestamp一旦确定, 其UTC时间就确定了, 
>                     转换到任意时区的时间也是完全确定的, 这就是为什么计算机存储的当前时间是以timestamp表示的，
>                     因为全球各地的计算机在任意时刻的timestamp都是完全相同的(假定时间已校准)
>         '''
>         print('DateTime -> TimeStamp =', dt.now().timestamp())
> 
>         # 时间戳转换为日期时间 | Timestamp to datetime
>         '''
>         注意到timestamp是一个浮点数, 它没有时区的概念, 而datetime是有时区, 转换是指在timestamp和本地时间做转换
>         本地时间是指当前操作系统设定的时区, 例如北京时区是东8区: `2019-02-01 04:20:10`, 实际上就是UTC+8:00时区的时间: `2019-02-01 04:20:10 UTC+8:00`,
>         而此刻的格林威治标准时间与北京时间差了8小时, 也就是UTC+0:00时区的时间应该是：`2019-02-01 04:20:10 UTC+0:00`
>         '''
>         new_now = dt.now().timestamp()
>         print('TimeStamp -> DateTime =', dt.fromtimestamp(new_now))  # 转换为本地时间
>         print('TimeStamp -> DateTime as UTC+0 =', dt.utcfromtimestamp(new_now))  # 转换为UTC标准时区时间
> 
>         # 字符串转换为日期时间 | String to datetime
>         string_datetime = dt.strptime('2019-02-01 04:20:10', '%Y-%m-%d %H:%M:%S')
>         print('StringDateTime -> DateTime =', string_datetime)
> 
>         # 日期时间转换为字符串 | datetime to String
>         print('DateTime -> StringDateTime =', now.strftime('%a, %b %d %H:%M'))
> 
>         # 日期时间 加减运算 | Date and time addition and subtraction
>         '''
>         对日期和时间进行加减实际上就是把datetime往后或往前计算得到新的datetime, 加减可以直接用+和-运算符
>         '''
>         print('Current DateTime =', string_datetime)
>         print('Current + 10 Hours =', string_datetime + td(hours=10))
>         print('Current - 1 Day =', string_datetime - td(days=1))
>         print('Current + 2.5 Days =', string_datetime + td(days=2, hours=12))
> 
>         # 本地时间转换为UTC时间 | Local time to UTC time
>         '''
>         本地时间是指系统设定时区的时间, 例如北京时间是UTC+8:00时区的时间, 而UTC时间指UTC+0:00时区的时间.
>         时区转换的关键在于得到一个datetime时, 需要获知其正确的时区, 然后强制设置时区作为基准时间.
>         利用带时区的datetime, 通过astimezone()方法, 可以转换到任意时区.
>         '''
>         utc_dt = dt.utcnow().replace(tzinfo=tz.utc)  # 设置时区为UTC+0:00
>         utc8_dt = utc_dt.astimezone(tz(td(hours=8)))  # 将转换时区为北京时间
>         tokyo_dt = utc_dt.astimezone(tz(td(hours=9)))  # 将转换时区为东京时间
>         print('UTC+0:00 Now =', utc_dt)
>         print('UTC+8:00 Now =', utc8_dt)
>         print('UTC+9:00 Now =', tokyo_dt)
> 
>         print('\n=============================== DateTime Method End ===============================\n')
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.datetime_method()
> ```


##### 8.12.1.2 collections
> collections是Python内建的一个集合模块, 提供了许多有用的集合类, 可以根据需要选用.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from collections import namedtuple as nt, deque as dq, defaultdict as dd, OrderedDict as odd, Counter as cr
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
> 
>     # 定义 集合 静态方法 | Definition collection static method
>     @staticmethod
>     def collections_method():
>         print('\n=============================== Collections Method Start ===============================\n')
>         # 元祖 | Tuple
>         '''
>         函数说明：
>         `namedtuple`是一个函数, 它用来创建一个自定义的tuple对象, 并且规定了tuple元素的个数, 并可以用属性而不是索引来引用tuple的某个元素
>         使用`namedtuple`可以很方便地定义一种数据类型, 它具备tuple的不变性, 又可以根据属性来引用, 使用十分方便.
>         '''
>         Point = nt('Point', ['x', 'y'])
>         Circle = nt('Circle', ['x', 'y', 'r'])
>        p = Point(1, 2)
>         c = Circle(1, 2, 10)
>         print('Point =', p.x, p.y, isinstance(p, Point), isinstance(p, tuple))
>         print('Circle =', c.x, c.y, c.r, isinstance(c, Point), isinstance(c, tuple))
> 
>         # deque
>         '''
>         使用list存储数据时按索引访问元素很快, 但是插入和删除元素就很慢, 因为list是线性存储, 数据量大的时候, 插入和删除效率很低.
>         `deque`是为了高效实现插入和删除操作的双向列表, 适合用于队列和栈.
>         `deque`除了实现list的`append()`和`pop()`外, 还支持`appendleft()`和`popleft()`, 这样就可以非常高效地往头部添加或删除元素.
>         '''
>         q = dq(['a', 'b', 'c'])
>         q.append('x')
>         q.pop()
>         q.appendleft('y')
>         q.popleft()
>         print('deque =', q)
> 
>         # defaultdict
>         '''
>         使用dict时如果引用的Key不存在, 就会抛出KeyError, 如果希望key不存在时返回一个默认值, 就可以用`defaultdict`
>         注意默认值是调用函数返回的, 而函数在创建`defaultdict`对象时传入.
>         除了在Key不存在时返回默认值, `defaultdict`的其他行为跟dict是完全一样.
>         '''
>         ddt = dd(lambda: 'N/A')
>         ddt['key1'] = 'abc'
>         print('ddt[\'key1\'] =', ddt['key1'])
>         print('ddt[\'key2\'] =', ddt['key2'])
> 
>         # OrderedDict
>         '''
>         使用dict时Key是无序, 在对dict做迭代时无法确定Key的顺序, 如果要保持Key的顺序可以用`OrderedDict`
>         注意OrderedDict的Key会按照插入的顺序排列, 不是Key本身排序.
>         '''
>         d = dict([('a', 1), ('b', 2), ('c', 3)])
>         print('Dict =', d)
>         od = odd(d)
>         print('OrderedDict =', od)
> 
>         od = odd()
>         od['z'] = 1
>         od['y'] = 2
>         od['x'] = 3
>         ods = list(od.keys())
>         print('OrderedDict =', ods)
> 
>         # ChainMap
>         '''
>         ChainMap可以把一组dict串起来并组成一个逻辑上的dict, 
>         ChainMap本身也是一个dict, 但是查找的时会按照顺序在内部的dict依次查找.
>         '''
> 
>         # Counter | 统计字陆运出现个数
>         character = 'https://www.geekparkhub.com'
>         c = cr()
>         # Statistics Type 1
>         c.update(character)
>         print('Character Counter =', c)
>         # Statistics Type 2
>         for ch in character:
>             c[ch] = c[ch] + 1
>         print('Character Counter =', c)
> 
>         print('\n=============================== Collections Method End ===============================\n')
>         
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.collections_method()
> ```


##### 8.12.1.3 base64
> Base64是一种用64个字符来表示任意二进制数据的方法.
> 
> 用记事本打开exe、jpg、pdf这些文件时都会看到一大堆乱码, 因为二进制文件包含很多无法显示和打印的字符, 所以如果要让记事本这样的文本处理软件能处理二进制数据就需要一个二进制到字符串的转换方法, Base64是一种最常见的二进制编码方法.
> 
> Base64原理很简单, 首先准备一个包含64个字符的数组, 然后对二进制数据进行处理, 每3个字节一组, 一共是3x8=24bit, 划为4组, 每组正好6个bit.
> ```
> ['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
> ```
> ![enter image description here | center](https://www.liaoxuefeng.com/files/attachments/949444125467040)
> 
> 这样得到4个数字作为索引然后查表, 获得相应的4个字符就是编码后的字符串.
> 
> 所以Base64编码会把3字节的二进制数据编码为4字节的文本数据, 长度增加33%, 好处是编码后的文本数据可以在邮件正文、网页等直接显示.
> 
> 如果要编码的二进制数据不是3的倍数, 最后会剩下1个或2个字节怎么办, Base64用`\x00`字节在末尾补足后, 再在编码的末尾加上1个或2个`=`号表示补了多少字节, 解码的时候会自动去掉.
> 
> Python内置base64可以直接进行base64的编解码, Base64是一种任意二进制到文本字符串的编码方法, 常用于在URL、Cookie、网页中传输少量二进制数据, Base64适用于小段内容的编码, 比如数字证书签名、Cookie的内容等.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import base64 as b64
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
>     
>     # 定义 base64 静态方法 | Defining a base64 static method
>     @staticmethod
>     def base64_method():
>         print('\n=============================== Base64 Method Start ===============================\n')
>         # Base64 编码 | Base64 encoding
>         base64_encoding = b64.b64encode('BASE64 编码'.encode('UTF-8'))
>         print('Base64 encoding =', base64_encoding)
>         # Base64 解码 | Base64 decoding
>         base64_decoding = b64.b64decode(base64_encoding).decode('UTF-8')
>         print('Base64 decoding =', base64_decoding)
> 
>         '''
>         由于标准的Base64编码后可能出现字符+和/, 在URL中就不能直接作为参数, 
>         所以又有一种"url safe"的base64编码,  其实就是把字符+和/分别变成-和_
>         '''
>         # Base64 编码 for Url Safe | Base64 encoding for Url Safe
>         base64_encoding_for_urlsafe_1 = b64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')
>         base64_encoding_for_urlsafe_2 = b64.urlsafe_b64encode('Base64 encoding for Url Safe'.encode('UTF-8'))
>         print('Base64 encoding for Url Safe 1 =', base64_encoding_for_urlsafe_1)
>         print('Base64 encoding for Url Safe 2 =', base64_encoding_for_urlsafe_2)
> 
>         # Base64 解码 for Url Safe | Base64 decoding for Url Safe
>         base64_decoding_for_urlsafe_1 = b64.urlsafe_b64decode(base64_encoding_for_urlsafe_1)
>         base64_decoding_for_urlsafe_2 = b64.urlsafe_b64decode(base64_encoding_for_urlsafe_2).decode('UTF-8')
>         print('Base64 decoding for Url Safe 1 =', base64_decoding_for_urlsafe_1)
>         print('Base64 decoding for Url Safe 2 =', base64_decoding_for_urlsafe_2)
> 
>         print('\n=============================== Base64 Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.base64_method()
> ```

##### 8.12.1.4 struct
> Python没有专门处理字节的数据类型, 但由于`b'str'`可以表示字节, 所以字节数组＝二进制str, 而在C语言中可以很方便地用struct、union来处理字节, 以及字节和int，float的转换.
> 
> Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import struct as st
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
>     
>     # 定义 结构 静态方法 | Definition structure static method
>     @staticmethod
>     def struct_method():
>         print('\n=============================== Struct Method Start ===============================\n')
>         # 将任意数据类型转换为字节类型 | Convert any data type to byte type
>         '''
>         struct中pack函数把任意数据类型变成bytes, `pack`的第一个参数是处理指令
>         `>I`参数说明：`>` 表示字节顺序是big-endian, 也就是网络序, `I`表示4字节无符号整数, 后面的参数个数要和处理指令一致.
>         根据`>IH`的说明, 后面的bytes依次变为 `I`为4字节无符号整数 `H`为2字节无符号整数.
>         '''
>         # 包装为字节类型 | Packed as a byte type
>         packing_byte_type = st.pack('>I', 10240099)
>         print('Packing ByteType (`10240099`)=', packing_byte_type)
> 
>         # 解包为数据类型 | Unpacked as a data type
>         unpacking_data_type = st.unpack('>IH', b'\xf0\xf0\xf0\xf0\x80\x80')
>         print("Unpacking DataType =", unpacking_data_type)
> 
>         '''
>         BMP 说明：
>         bmp是Windows操作系统中一种非常简单位图的文件格式.
>         BMP格式采用小端方式存储数据, 文件头的结构按顺序如下
>         
>         BMP结构按顺序 说明：
>         两个字节：`BM`表示Windows位图, `BA`表示OS/2位图. | 一个4字节整数：表示位图大小
>         一个4字节整数：保留位, 始终为0 | 一个4字节整数：实际图像的偏移量
>         一个4字节整数：Header的字节数 | 一个4字节整数：图像宽度
>         一个4字节整数：图像高度 | 一个2字节整数：始终为1 | 一个2字节整数：颜色数
>         '''
>         bmp_header = b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68' \
>                      b'\x01\x00\x00\x01\x00\x18\x00'
>         unpacking_bmp = st.unpack('<ccIIIIIIHH', bmp_header)
>         print('BMP All Info =', unpacking_bmp)
>         print('BMP Type Info =', unpacking_bmp[0], unpacking_bmp[1])
>         print('BMP Size Info =', unpacking_bmp[2])
>         print('BMP Reserved bit Info =', unpacking_bmp[3])
>         print('BMP Offset Info =', unpacking_bmp[4])
>         print('BMP Header bytes Info =', unpacking_bmp[5])
>         print('BMP width * height Info = ', unpacking_bmp[6], '*', unpacking_bmp[7])
>         print('BMP Number of colors Info =', unpacking_bmp[9])
>         print('\n=============================== Struct Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.struct_method()
> ```


##### 8.12.1.5 hashlib
> 摘要算法又称哈希算法、散列算法, 它通过一个函数把任意长度的数据转换为一个长度固定的数据串(通常用16进制的字符串表示).
> 
> Python的hashlib提供了常见的摘要算法, 如MD5, SHA1等等.
> 
> 摘要算法在很多地方都有广泛的应用, 要注意摘要算法不是加密算法, 不能用于加密(因为无法通过摘要反推明文), 只能用于防篡改, 但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import hashlib as hl
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
>     
>     # 定义 摘要 静态方法 | Definition summary static method
>     @staticmethod
>     def summary_method():
>         print('\n=============================== Summary Method Start ===============================\n')
>         # 定义 MD5 摘要算法 | Define MD5 Digest Algorithm
>         '''
>         MD5是最常见的摘要算法, 速度很快, 生成结果是固定的128 bit字节, 通常用一个32位的16进制字符串表示.
>         '''
>         md5 = hl.md5()
>         md5.update('Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.'.encode('UTF-8'))
>         md5.update('In the spirit of fearless exploration, create unknown technology and worship of technology.'.encode( 'UTF-8'))
>         md5.update('Advanced Python - Built-in Modules & Third-Party Modules'.encode('UTF-8'))
>        print('MD5 Digest Algorithm =', md5.hexdigest())
> 
>         # 定义 SHA1 摘要算法 | Define the SHA1 digest algorithm
>         '''
>         SHA1的结果是160 bit字节, 通常用一个40位的16进制字符串表示.
>         '''
>         sha1 = hl.sha1()
>         sha1.update(
>             'Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.'.encode('UTF-8'))
>         sha1.update(
>             'In the spirit of fearless exploration, create unknown technology and worship of technology.'.encode(
>                 'UTF-8'))
>         sha1.update('Advanced Python - Built-in Modules & Third-Party Modules'.encode('UTF-8'))
>         print('SHA1 Digest Algorithm =', sha1.hexdigest())
>         print('\n=============================== Summary Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.summary_method()
> ```


##### 8.12.1.6 hmac
> 通过哈希算法可以验证一段数据是否有效, 方法就是对比该数据的哈希值, 例如判断用户口令是否正确, 用保存在数据库中的password_md5对比计算md5(password)的结果, 如果一致用户输入的口令就是正确.
> 
> Python自带的hmac模块实现了标准的Hmac算法, 使用hmac和普通hash算法非常类似, hmac输出的长度和原始哈希算法的长度一致, 需要注意传入的key和message都是bytes类型, str类型需要首先编码为bytes.
> 
> Python内置的hmac模块实现了标准的Hmac算法, 它利用一个key对message计算“杂凑”后的hash, 使用hmac算法比标准hash算法更安全, 因为针对相同的message, 不同的key会产生不同的hash.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import hmac as hm
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
>     
>     # 定义 hmac 静态方法 | Define hmac static method
>     @staticmethod
>     def hmac_method():
>         print('\n=============================== HMAC Method Start ===============================\n')
>         message = b'Hello, World!'  # 定义 原始消息 | Definition Original Message
>         key = b'secret'  # 定义 随机Key | Definition Random Key
>         h = hm.new(key, message, digestmod='MD5')
>         print('HMAC Digest Algorithm =', h.hexdigest())
>         print('\n=============================== HMAC Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.hmac_method()
> ```



##### 8.12.1.7 itertools
> Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数.
> 
> itertools模块提供的全部是处理迭代功能的函数, 它们的返回值不是list, 而是Iterator, 只有用for循环迭代的时候才真正计算.
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import itertools as its
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
>     
>     # 定义 itertools 静态方法 | Define itertools static method
>     @staticmethod
>     def itertools_method():
>         print('\n=============================== itertools Method Start ===============================\n')
>         # count()
>         '''
>         count() 将创建一个无限的迭代器, 所以代码会打印出自然数序列无法自动退出, 只能按Ctrl+C退出
>         '''
>         natuals = its.count(1)
>         for x in natuals:
>             print('natuals =', x)
>             if x >= 10:
>                 break
> 
>         # cycle()
>         '''
>         cycle() 将传入的序列无限重复循环
>         '''
>         cs = its.cycle('ABC')
>         frequency = 10
>         for c in cs:
>             print('Infinite repeat loop Frequency = %d Values = %s ' % (frequency, c))
>             frequency = frequency - 1
>             if frequency == 0:
>                 break
> 
>         # repeat()
>         '''
>         repeat()负责把一个元素无限重复循环, 不过如果提供第二个参数就可以限定重复次数
>         '''
>         ns = its.repeat('A', 3)
>         for n in ns:
>             print('Limited number of repetitions =', n)
> 
>         # takewhile()
>         '''
>         无限序列只有在for迭代时才会无限地迭代下去, 如果只是创建了一个迭代对象,
>         它不会事先把无限个元素生成出来, 事实上也不可能在内存中创建无限多个元素.
>         无限序列虽然可以无限迭代下去, 但是通常会通过`takewhile()`等函数根据条件判断来截取出一个有限的序列.
>         '''
>         natuals = its.count(1)
>         tw = its.takewhile(lambda x: x <= 10, natuals)
>         print('natuals =', list(tw))
> 
>         # chain()
>         '''
>         chain() 将一组迭代对象串联起来形成一个更大的迭代器
>         '''
>         for cn in its.chain('ABC', 'XYZ'):
>             print('Tandem Iterator =', cn)
> 
>         # groupby()
>         '''
>         groupby() 将迭代器中相邻的重复元素挑出来放在一起
>         '''
>         for key1, group1 in its.groupby('AAABBBCCAAA'):
>             print(f'Key_1 = {key1}', list(group1))
> 
>         for key2, group2 in its.groupby('AaaBBbcCAAa', lambda cc: cc.upper()):
>             print(f'Key_2 = {key2}', list(group2))
>         print('\n=============================== itertools Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.itertools_method()
> ```


##### 8.12.1.8 contextlib
> 在Python中读写文件这样的资源要特别注意, 必须在使用完毕后正确关闭它们, 正确关闭文件资源的一个方法是使用`try...finally`.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from contextlib import contextmanager as cm
> from contextlib import closing as cg
> from urllib.request import urlopen as uo
> 
> 
> # 定义 上下文库 | Definition context library
> class BuiltInModuleForContextLibrary(object):
>     # 定义 初始化 方法 | Define initialization method
>     def __init__(self, name):
>         self.name = name
> 
>     # 自定义 方法 | Custom method
>     def query(self):
>         print('Query info about %s...' % self.name)
> 
> 
> '''
> `@contextmanager`这个decorator接受一个generator, 用yield语句把`with ... as var`把变量输出, 然后with语句就可以正常执行
> 代码执行顺序 说明：
> 1.with语句首先执行yield之前的语句,因此打印出<h1>
> 2.yield调用会执行with语句内部的所有语句, 因此打印出Hello和World
> 3.最后执行yield之后的语句打印出</h1>
> 因此`@contextmanager`通过编写generator来简化上下文管理
> '''
> 
> 
> @cm
> def create_query(name):
>     print('Begin')
>     q = BuiltInModuleForContextLibrary(name)
>     yield q
>     print('End')
> 
> 
> # `@contextmanager`实现在某段代码执行前后自动执行特定代码
> @cm
> def tag(name):
>     print("<%s>" % name)
>     yield
>     print("</%s>" % name)
> 
> 
> with tag("h1"):
>     print("Hello")
>     print("World")
> 
> '''
> 如果一个对象没有实现上下文就不能把它用于with语句, 这个时候可以用closing()来把该对象变为上下文对象, 
> 例如用with语句使用urlopen(), closing也是一个经过`@contextmanager`装饰的generator, 作用就是把任意对象变为上下文对象并支持with语句
> '''
> with cg(uo('http://www.baidu.com')) as page:
>     for line in page:
>         print('line =', line)
> 
> 
> @cm
> def closing(thing):
>     try:
>         yield thing
>     finally:
>         thing.close()
>     
> 
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 调用 函数 | call function
>     create_query('1')
>     closing('2')
> ```



##### 8.12.1.9 urllib
> urllib提供了一系列用于操作URL的功能, urllib提供的功能就是利用程序去执行各种HTTP请求, 如果要模拟浏览器完成特定功能就需要把请求伪装成浏览器, 伪装的方法是先监控浏览器发出的请求再根据浏览器的请求头来伪装, User-Agent头就是用来标识浏览器的.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from urllib import request as req, parse as pe
> 
> 
> # 定义 内建模块 类 | Definition built-in module class
> class BuiltInModule:
>     
>     # 定义 请求 静态方法 | Definition request static method
>     @staticmethod
>     def request_library_method():
>         print('\n=============================== Request Method Start ===============================\n')
>         # 定义 Get请求 | Define Get Request
>         reqs = req.Request('http://www.baidu.com')
>         reqs.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
>         with req.urlopen(reqs) as f:
>             data = f.read()
>             print('Status =>', f.status, f.reason)
>             for k, v in f.getheaders():
>                 print('%s: %s' % (k, v))
>             print('Data =>\n', data.decode('UTF-8'))
> 
>         # 定义 Post请求 | Define Post Request
>         print('Login to weibo.cn...')
>         email = 'xxx@xxx.org'
>         passwd = 'xxxxx'
>         login_data = pe.urlencode([
>             ('username', email),
>             ('password', passwd),
>             ('entry', 'mweibo'),
>             ('client_id', ''),
>             ('savestate', '1'),
>             ('ec', ''),
>             ('pagerefer',
>              'http://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F%3Fjumpfrom%3Dweibocom&jumpfrom=weibocom')
>         ])
>         login_req = req.Request('http://passport.weibo.cn/sso/login')
>         login_req.add_header('Origin', 'http://passport.weibo.cn')
>         login_req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
>         login_req.add_header('Referer',
>                              'http://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F%3Fjumpfrom%3Dweibocom')
>         with req.urlopen(login_req, data=login_data.encode('utf-8')) as func:
>             print('Status:', func.status, func.reason)
>             for keys, values in func.getheaders():
>                 print('%s: %s' % (keys, values))
>             print('Data:', func.read().decode('UTF-8'))
> 
>         # 定义 代理身份验证 | Define proxy authentication
>         proxy_handler = req.ProxyHandler({'http': 'http://www.example.com:3128/'})
>         proxy_auth_handler = req.ProxyBasicAuthHandler()
>         proxy_auth_handler.add_password('realm', 'host', 'username', 'password')
>         opener = req.build_opener(proxy_handler, proxy_auth_handler)
>         with opener.open('http://www.example.com/login.html') as fn:
>             pass
> 
>         print('\n=============================== Request Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     b = BuiltInModule()
>     # 对象实例 调用方法 | Object instance call method
>     b.request_library_method()
> ```


##### 8.12.1.10 XML
> XML虽然比JSON复杂, 在Web中应用也不如以前多了, 不过仍有很多地方在用, 所以有必要了解如何操作XML.
> 
> 操作XML有两种方法：DOM和SAX, DOM会把整个XML读入内存, 解析为树, 因此占用内存大, 解析慢, 优点是可以任意遍历树的节点, SAX是流模式, 边读边解析, 占用内存小, 解析快, 缺点是需要自己处理事件.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from xml.parsers.expat import ParserCreate as pc
> 
> 
> # 定义 SAX 解析类 | Define the SAX parsing class
> class DefaultSaxHandler(object):
>     
>     def start_element(self, name, attrs):
>         print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))
> 
>     def end_element(self, name):
>         print('sax:end_element: %s' % name)
> 
>     def char_data(self, text):
>         print('sax:char_data: %s' % text)
> 
> 
> xml = r'''<?xml version="1.0"?>
> <ol>
>     <li><a href="/python">Python</a></li>
>     <li><a href="/ruby">Ruby</a></li>
> </ol>
> '''
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>      handler = DefaultSaxHandler()
>      parser = pc()
>     # 对象实例 调用方法 | Object instance call method
>      parser.StartElementHandler = handler.start_element
>      parser.EndElementHandler = handler.end_element
>      parser.CharacterDataHandler = handler.char_data
>      parser.Parse(xml)
> ```


##### 8.12.1.11 HTMLParser
> HTML本质上是XML的子集, 但是HTML的语法没有XML那么严格, 所以不能用标准的DOM或SAX来解析HTML, Python提供了HTMLParser来非常方便地解析HTML, 利用HTMLParser可以将网页中的文本、图像等进行解析.
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from html.parser import HTMLParser as hp
> from html.entities import name2codepoint as nc
> 
> 
> # 定义 HTML解析类 | Define HTML parsing class
> class HTMLParsers(hp):
> 
>     def handle_starttag(self, tag, attrs):
>         print('<%s>' % tag)
> 
>     def handle_endtag(self, tag):
>         print('</%s>' % tag)
> 
>     def handle_startendtag(self, tag, attrs):
>         print('<%s/>' % tag)
> 
>     def handle_data(self, data):
>         print(data)
> 
>     def handle_comment(self, data):
>         print('<!--', data, '-->')
> 
>     def handle_entityref(self, name):
>         print('&%s;' % name)
> 
>     def handle_charref(self, name):
>         print('&#%s;' % name)
>     
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     parsers = HTMLParsers()
>     # 对象实例 调用方法 | Object instance call method
>     '''
>     feed()方法可以多次调用, 可以一部分一部分追加
>     特殊字符有两种， 一种是英文表示的`&nbsp;`, 一种是数字表示的`&#1234;`, 这两种字符都可以通过Parser进行解析
>     '''
>     parsers.feed('''<html>
>     <head></head>
>     <body>
>     <!-- test html parser -->
>         <p>Some <a href=\"#\">html</a> HTML&nbsp;tutorial...<br>END</p>
>     </body></html>''')
> ```



#### 8.12.2 常用第三方模块
> 除了内建的模块外Python还有大量的第三方模块, 基本上所有的第三方模块都会在[PyPI - the Python Package Index](https://pypi.python.org/)上注册, 只要找到对应的模块名称即可用pip安装.

##### 8.12.2.1 Pillow
> PIL：Python Imaging Library, 是Python平台中图像处理标准库, PIL不仅功能非常强大,API非常简单易用.
> 由于PIL仅支持到Python 2.7， 加上年久失修于是一群志愿者在PIL的基础上创建了兼容的版本, 名字叫Pillow, 支持最新Python 3.x, 又加入了许多新特性, 因此可以直接安装使用Pillow.
> 
> **安装 Pillow**
> ```
> pip install pillow
> ```
> 
> **Pillow 官方文档**
> 
> https://pillow.readthedocs.org/
> 
> PIL提供了操作图像的强大功能可以通过简单的代码完成复杂的图像处理.
> 
> **参考源码**
> 
> https://github.com/michaelliao/learn-python3/blob/master/samples/packages/pil/use_pil_resize.py
> 
> https://github.com/michaelliao/learn-python3/blob/master/samples/packages/pil/use_pil_blur.py
> 
> https://github.com/michaelliao/learn-python3/blob/master/samples/packages/pil/use_pil_draw.py
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from PIL import Image as ims, ImageFilter as imf, ImageDraw as imd, ImageFont as imft
> import random as rd
> 
> 
> # 定义 第三方模块 类 | Defining third-party module classes
> class ThirdPartyModule:
> 
>     # 定义 操作图像 静态方法 | Definition Operating image Static method
>     @staticmethod
>     def operating_image_method():
>         print('\n=============================== Operating image Method Start ===============================\n')
>         # 定义 抛出异常代码块 | Definition throw exception code block
>         try:
>             # 获取图片路径 | Get image path
>             FILE_PATHS = '../resources/row_file/demo.jpg'
>             SAVE_FILE_PATHS = '../resources/row_file/demo_thumbnail.jpg'
>             SAVE_BLUR_FILE_PATHS = '../resources/row_file/demo_blur.jpg'
>             im = ims.open(FILE_PATHS)
>             # 获取图像尺寸 | Get image size
>             w, h = im.size
>             print('Original image Size = %s * %s' % (w, h))
> 
>             # 将图片尺寸缩放至50% | Scale image size to 50%
>             im.thumbnail((w // 2, h // 2))
>             print('Resize image To: %s * %s' % (w // 2, h // 2))
>             # 将缩放后的图像保存为jpeg格式 | Save the scaled image in jpeg format
>             im.save(SAVE_FILE_PATHS, 'jpeg')
> 
>             # 应用模糊滤镜 | Apply blur filter
>             im2 = im.filter(imf.BLUR)
>             im2.save(SAVE_BLUR_FILE_PATHS, 'jpeg')
>         except Exception as e:
>             print('Error message details =', e)
>         finally:
>             # 信息输出 | Information output
>             print('Zoom picture Saved successfully!')
>             print('Blur picture Saved successfully!')
> 
>         '''
>         生成字母验证码图片 | Generate Letter Verification Picture
>         '''
> 
>         # 定义 随机字母 函数 | Definition random letters function
>         def rnd_char():
>             return chr(rd.randint(50, 60))
> 
>         # 定义 随机颜色样式1 函数 | Definition random color style 1 function
>         def rnd_color1():
>             return (rd.randint(64, 255), rd.randint(64, 255), rd.randint(64, 255))
> 
>         # 定义 随机颜色样式2 函数 | Definition random color style 2 function
>         def rnd_color2():
>             return (rd.randint(32, 127), rd.randint(32, 127), rd.randint(32, 127))
> 
>         # 定义 抛出异常代码块 | Definition throw exception code block
>         try:
>             # 定义 变量 验证码 宽度 | Definition variable captcha width
>             photo_width = 64 * 4
> 
>             # 定义 变量 验证码 高度 | Definition variable captcha height
>             photo_height = 60
> 
>             # 定义 验证码图片 | Definition Captcha Picture
>             image = ims.new('RGB', (photo_width, photo_height), (255, 255, 255))
> 
>             # 定义 字体对象 | Definition font object
>             FONT_PATHS = '../resources/font_file/Comic_Sans_MS_Bold.ttf'
>             font = imft.truetype(FONT_PATHS, 36)
> 
>             # 创建绘图对象 | Create drawing objects
>             draw = imd.Draw(image)
> 
>             # 填充像素 | Fill pixel
>             for x in range(photo_width):
>                 for y in range(photo_width):
>                     draw.point((x, y), fill=rnd_color1())
> 
>             # 输出文字 | Output text
>             for txt in range(6):
>                 draw.text((60 * txt + 5, 10), rnd_char(), font=font, fill=rnd_color2())
> 
>             # 应用模糊滤镜 | Apply blur filter
>             image = image.filter(imf.BLUR)
> 
>             # 定义 保存 验证码路径 | Definition Save Captcha Path
>             SAVE_CODE_FILE_PATHS = '../resources/row_file/demo_code.jpg'
>             image.save(SAVE_CODE_FILE_PATHS, 'jpeg')
>         except Exception as e:
>             print('Error message details =', e)
>         finally:
>             # 信息输出 | Information output
>             print('Captcha picture Saved successfully!')
>         print('\n=============================== Operating image Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     t = ThirdPartyModule()
>     # 对象实例 调用方法 | Object instance call method
>     t.operating_image_method()
> ```


##### 8.12.2.2 requests
> Python内置的urllib模块用于访问网络资源, 但是它用起来比较麻烦, 而且缺少很多实用的高级功能.
> 
> 更好的方案是使用requests, 它是一个Python第三方库处理URL资源特别方便.
> 
> **安装 requests**
> 
> 如果安装了Anaconda, requests就已经可以使用, 否则需要在命令行下通过pip安装
> ```
> pip install requests
> ```
> 
> **使用 requests**
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import requests as reqs
> 
> # 定义 第三方模块 类 | Defining third-party module classes
> class ThirdPartyModule:
> 
>     # 定义 requests 静态方法 | Define requests static method
>     @staticmethod
>     def requests_method():
>         print('\n=============================== Requests Method Start ===============================\n')
>         # GET访问页面 | GET access page
>         url = 'https://www.baidu.com/'
>         cs = {'token': '12345', 'status': 'working'}
>         # 指定超时, 传入以秒为单位的timeout参数
>         r1 = reqs.get(url, cookies=cs, timeout=2.5)
>         print('Request Status =', r1.status_code)
>         print('Return Context =\n', r1.text)
>         # 获取指定Cookie | Get the specified cookie
>         # print('Cookies =', r1.cookies['ts'])
> 
>         # 携带参数访问页面 | Visit page with parameters
>         r2 = reqs.get(url + 's?', params={'wd': 'Python'})
>         print('Detection Encoding =', r2.encoding)
>         print('Request Link =', r2.url)
>         print('Return Context =', r2.content)
> 
>         # 访问 JSON | Access JSON
>         json_url = 'http://www.kuaidi100.com/query?type=yuantong&postid=11111111111&format=json'
>         r3 = reqs.get(json_url)
>         print('Return JSON Context', r3.json())
> 
>         # 携带headers参数访问页面 | Visit the page with the headers parameter
>         r4 = reqs.get(url, headers={'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'})
>         print('Return Context =\n', r4.content)
>         # 获取响应头 | Get response header
>         print('Response Header =', r4.headers)
> 
> 
>         # POST请求 | POST request
>         r5 = reqs.post('https://accounts.douban.com/login',
>                        data={'form_email': 'xxx@example.org', 'form_password': 'xxxxxx'})
>         print('Return Context =\n', r5.content)
>         '''
>         requests默认使用application/x-www-form-urlencoded对POST数据编码, 如果要传递JSON数据可以直接传入json参数.
>         '''
>         params = {'key': 'value'}
>         r6 = reqs.post('https://graph.baidu.com/upload?tn=pc&from=pc', json=params)  # 内部自动序列化为JSON
>         print('Return Context =\n', r6.content)
> 
>         # 上传文件 | upload files
>         '''
>         在读取文件时注意务必使用'rb'即二进制模式读取这样获取的bytes长度才是文件的长度
>         post()方法替换为put()，delete()等，就可以以PUT或DELETE方式请求资源
>         '''
>         upload_files = {'file': open('../resources/row_file/demo.jpg', 'rb')}
>         r7 = reqs.post('https://graph.baidu.com/upload?tn=pc&from=pc', files=upload_files)
>         print('Return Context =\n', r7.content)
> 
>         print('\n=============================== Requests Method End ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     t = ThirdPartyModule()
>     # 对象实例 调用方法 | Object instance call method
>     t.requests_method()
> ```


##### 8.12.2.3 chardet
> 字符串编码一直是令人非常头疼的问题, 尤其是在处理一些不规范的第三方网页的时候, 虽然Python提供了Unicode表示的str和bytes两种数据类型, 并且可以通过encode()和decode()方法转换.
> 
> 对于未知编码的bytes要把它转换成str, 需要先“猜测”编码, 猜测的方式是先收集各种编码的特征字符, 根据特征字符判断，就能有很大概率“猜对”.
> 
> chardet第三方库正好就派上了用场, 用它来检测编码简单易用.
> 
> **安装 chardet**
> 
> 如果安装了Anaconda, chardet可以使用, 否则需要在命令行下通过pip安装
> ```
> pip install chardet
> ```
> 
> **使用 chardet**
> 
> hardet支持检测的编码列表请参考官方文档[Supported encodings](https://chardet.readthedocs.io/en/latest/supported-encodings.html)
> 
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> import chardet as chd
> 
> 
> # 定义 第三方模块 类 | Defining third-party module classes
> class ThirdPartyModule:
> 
>     # 定义 字符串编码 静态方法 | Definition string encoding static method
>     @staticmethod
>     def chardet_method():
>         print('\n=============================== Chardet Method Start ===============================\n')
>         # 检测编码 | Detection code
>         '''
>         检测出的编码是`ascii`, `confidence`字段表示检测的概率是1.0 (即100%)
>         '''
>         detection_code = chd.detect(b'Hello, world!')
>         print('Detection Code =', detection_code)
> 
>         # 检测GBK中文编码 | Detect GBK Chinese encoding
>         '''
>         检测的编码是GB2312, 因GBK是GB2312的超集, 两者是同一种编码, 检测正确的概率是99%, language字段指出的语言是'Chinese'
>         '''
>         text = 'Python 进阶篇 - 内建模块 & 第三方模块'.encode('gbk')
>         detection_gbk = chd.detect(text)
>         print('Detection GBK =', detection_gbk)
> 
>         # 检测 UTF-8编码 | Detecting UTF-8 encoding
>         text2 = '检测 UTF-8编码'.encode('utf-8')
>         detection_utf8 = chd.detect(text2)
>         print('Detection UTF-8 =', detection_utf8)
> 
>         # 检查 日文编码 | Check Japanese encoding
>         text3 = '最新の主要ニュース'.encode('euc-jp')
>         detection_jp = chd.detect(text3)
>         print('Detection Japanese =', detection_jp)
> 
>         print('\n=============================== Chardet Method Start ===============================\n')
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     t = ThirdPartyModule()
>     # 对象实例 调用方法 | Object instance call method
>     t.chardet_method()
> ```



##### 8.12.2.4 psutil
> ``` py
> # -*- coding:utf-8 -*-
> # 
> # Geek International Park | 极客国际公园
> # GeekParkHub | 极客实验室
> # Website | https://www.geekparkhub.com
> # Description | Open · Creation | 
> # Open Source Open Achievement Dream, GeekParkHub Co-construction has never been seen before.
> # HackerParkHub | 黑客公园
> # Website | https://www.hackerparkhub.org
> # Description | In the spirit of fearless exploration, create unknown technology and worship of technology.
> # GeekDeveloper : JEEP-711
> # 
> # @Author : system
> # @Version : 0.2.5
> # @Program : 内建模块 & 第三方模块 | Built-in modules & third-party modules
> # @File : 24_built_in_module.py
> # @Description : Python 进阶篇 - 内建模块 & 第三方模块 | Advanced Python - Built-in Modules & Third-Party Modules
> 
> # 导入模块 | Import module
> from PIL import Image as ims, ImageFilter as imf, ImageDraw as imd, ImageFont as imft
> import random as rd
> 
> 
> # 定义 第三方模块 类 | Defining third-party module classes
> class ThirdPartyModule:
> 
> # 定义 主模块 | Definition Main module
> if __name__ == '__main__':
>     # 创建 对象实例 | Create object instance
>     t = ThirdPartyModule()
>     # 对象实例 调用方法 | Object instance call method
>     t.operating_image_method()
> ```


## 9. 修仙之道 技术架构迭代 登峰造极之势
![Alt text](https://raw.githubusercontent.com/geekparkhub/geekparkhub.github.io/master/technical_guide/assets/media/main/technical_framework.jpg)

-----

## 💡如何对该开源文档进行贡献💡

1. Blog内容大多是手敲,所以难免会有笔误,你可以帮我找错别字。
2. 很多知识点我可能没有涉及到,所以你可以对其他知识点进行补充。
3. 现有的知识点难免存在不完善或者错误,所以你可以对已有知识点的修改/补充。
4. 💡欢迎贡献`各领域开源野生Blog`&`笔记`&`文章`&`片段`&`分享`&`创想`&`OpenSource Project`&`Code`&`Code Review`
5. 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈 issues: [geekparkhub.github.io/issues](https://github.com/geekparkhub/geekparkhub.github.io/issues) 🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈🙈

### 希望每一篇文章都能够对读者们提供帮助与提升,这乃是每一位笔者的初衷                          


-----


## 💌感谢您的阅读 欢迎您的留言与建议💌

- FaceBook：[JEEP SevenEleven](https://www.facebook.com/profile.php?id=100018099483403)
- Twitter：[@JEEP7ll](https://twitter.com/JEEP7ll)
- Sina Weibo: [@JEEP-711](https://weibo.com/JEEP511)
- GeekParkHub GithubHome：<https://github.com/geekparkhub>
- GeekParkHub GiteeHome：<https://gitee.com/geekparkhub>
- Blog GardenHome：<http://www.cnblogs.com/JEEP711/>
- W3C/BlogHome：<https://www.w3cschool.cn/jeep711blog/>
- CSDN/BlogHome：<http://blog.csdn.net/jeep911>
- 51CTO/BlogHome：<http://jeep711.blog.51cto.com/>
- **`Official Public Email`**
- Group Email：<geekparkhub@outlook.com> —— <hackerparkhub@outlook.com> —— <hackerpark@hotmail.com>
- User Email：<jeep711.home.@gmail.com> —— <jeep-711@outlook.com>
- System Email：<systemhub-711@outlook.com>
- Service Email：<servicehub-711@outlook.com>



### 捐助 项目的发展离不开你的支持,请开发者喝杯☕Coffee☕吧!
![enter image description here](https://www.geekparkhub.com/docs/images/pay.jpg)

#### `致谢`：
**捐助时请备注 UserName**
| ID| UserName | Donation | Money | Consume |
|:-| :-------- | --------:| :--: |:--: |
|1 | Object | WeChatPay |  5RMB | 一杯可乐 | 
|2| 泰迪熊看月亮  | AliPay |  20RMB  | 一杯咖啡 | 
|3| 修仙道长  | WeChatPay |  10RMB | 两杯可乐 | 


## License 开源协议
[Apache License Version 2.0](https://github.com/geekparkhub/geekparkhub.github.io/blob/master/LICENSE)

---------


